---
title: "JSP 실행 과정 심층 분석: 브라우저 렌더링 메커니즘"
date: 2025-06-11 17:30:47 +09:00
categories: [jsp]
lang: ko
locale: ko
words_per_minute: 30

---

## JSP 실행 과정 심층 분석: 브라우저 렌더링 메커니즘

우리가 생성한 `.jsp` 파일은 웹 브라우저에서 직접 실행되지 않습니다. 대신, 웹 컨테이너(WAS, 예를 들면 Tomcat)의 정교한 처리 과정을 거쳐야만 최종적으로 웹 브라우저가 이해하고 렌더링할 수 있는 **HTML 페이지로 변환**되어 사용자에게 전달됩니다. 이 문서는 JSP 파일이 클라이언트의 요청부터 브라우저에 표시되기까지의 모든 단계를 상세한 코드 예시와 함께 설명합니다.

---

### 🌟 1. JSP의 변환 과정: 요청부터 응답까지

JSP 파일은 처음 요청되거나 변경될 때 웹 컨테이너에 의해 내부적으로 **서블릿(.java) 파일로 변환되고 컴파일(.class)된 후 실행**됩니다. 이러한 과정은 클라이언트로부터의 요청을 효율적으로 처리하고 동적 콘텐츠를 생성하는 핵심 메커니즘입니다.

#### 1. 클라이언트의 요청

사용자가 웹 브라우저에 `http://localhost:8080/myWebApp/example.jsp`와 같은 URL을 입력하고 요청을 보냅니다. 이 요청은 웹 서버(예: Apache HTTP Server)를 거쳐 웹 컨테이너(WAS, Web Application Server)로 전달됩니다.

#### 2. 웹 컨테이너의 확인

이 요청을 받은 **웹 컨테이너(WAS)**는 내부적으로 해당 JSP 파일(`example.jsp`)에 대한 **서블릿 인스턴스**가 이미 메모리에 로드되어 있는지 확인합니다. 이 정보는 **서블릿 컨텍스트(Servlet Context)**라는 애플리케이션 전역 저장소에 저장되어 관리됩니다.

#### 3. 최초 요청 또는 변경 사항 발생 시 (변환 시작)

만약 JSP 파일이 **최초로 요청되거나**, 이전 요청 이후 JSP 파일의 내용이 **수정되어 최신 버전이 아닌 경우**, 웹 컨테이너는 다음 절차를 수행하여 JSP를 실행 가능한 서블릿으로 변환하고 컴파일합니다.

* **JSP를 서블릿 코드로 변환 (Translation)**:
    * 웹 컨테이너는 `.jsp` 파일을 파싱하여 해당 JSP 파일의 HTML, JSP 요소(지시어, 스크립트릿, 표현식 등)를 자바 서블릿 코드(`.java` 파일)로 변환합니다. 이 변환된 자바 파일은 일반적으로 `_example_jsp.java`와 같은 이름으로 임시 디렉토리에 생성됩니다.
    * 이때, JSP 파일 내의 모든 정적 HTML 내용은 `out.write()` 또는 `out.print()`와 같은 서블릿 출력 스트림 메서드로 변환되고, 스크립트릿(`<&#37; %>`) 내부의 자바 코드는 서블릿의 `_jspService()` 메서드 안으로 삽입됩니다.

    **[예시: JSP 파일]**
    `hello.jsp`
    ```jsp
    <%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
    <!DOCTYPE html>
    <html>
    <head>
    <meta charset="UTF-8">
    <title>Hello JSP</title>
    </head>
    <body>
        <h1>안녕하세요, <% out.print("JSP 세계에 오신 것을 환영합니다!"); %></h1>
        <p>현재 시간: <%= new java.util.Date() %></p>
    </body>
    </html>
    ```

    **[예시: 변환된 서블릿 `.java` 코드 (일부 발췌)]**
    *실제 코드는 훨씬 더 복잡하지만, 핵심 부분은 다음과 같습니다.*
    ```java
    // Generated by Apache Tomcat
    public final class _hello_jsp extends org.apache.jasper.runtime.HttpJspBase
        implements org.apache.jasper.runtime.JspSourceDependent,
                   org.apache.jasper.runtime.JspSourceImports {

        // ... (생략: _jspInit(), _jspDestroy() 등 생명주기 메서드)

        public void _jspService(final jakarta.servlet.http.HttpServletRequest request,
                                final jakarta.servlet.http.HttpServletResponse response)
            throws java.io.IOException, jakarta.servlet.ServletException {

            final jakarta.servlet.jsp.PageContext pageContext;
            jakarta.servlet.http.HttpSession session = null;
            final jakarta.servlet.ServletContext application;
            final jakarta.servlet.ServletConfig config;
            jakarta.servlet.jsp.JspWriter out = null;
            final java.lang.Object page = this;
            jakarta.servlet.jsp.JspWriter _jspx_out = null;
            jakarta.servlet.jsp.PageContext _jspx_page_context = null;

            try {
                // ... (생략: 페이지 컨텍스트 및 내장 객체 초기화)

                out = _jspx_page_context.getOut(); // JspWriter 객체 (out 내장 객체)

                // JSP 파일의 정적 HTML 부분이 out.write()로 변환됨
                out.write("<!DOCTYPE html>\n");
                out.write("<html>\n");
                out.write("<head>\n");
                out.write("<meta charset=\"UTF-8\">\n");
                out.write("<title>Hello JSP</title>\n");
                out.write("</head>\n");
                out.write("<body>\n");
                out.write("    <h1>안녕하세요, ");
                // 스크립트릿의 Java 코드가 그대로 삽입됨
                out.print("JSP 세계에 오신 것을 환영합니다!");
                out.write("</h1>\n");
                out.write("    <p>현재 시간: ");
                // 표현식의 Java 코드가 out.print()로 변환됨
                out.print( new java.util.Date() );
                out.write("</p>\n");
                out.write("</body>\n");
                out.write("</html>\n");

            } catch (java.lang.Throwable t) {
                // ... (예외 처리 로직)
            } finally {
                // ... (자원 해제)
            }
        }
    }
    ```

* **서블릿 코드 컴파일 (Compilation)**:
    * 변환된 `.java` 서블릿 파일은 자바 컴파일러(Javac)에 의해 컴파일됩니다. 이 과정에서 실행 가능한 **서블릿 클래스 파일(`.class`)**이 생성됩니다. 이 `.class` 파일은 `WEB-INF/classes` 디렉토리나 웹 컨테이너의 임시 작업 디렉토리에 저장됩니다. (예: `_example_jsp.class`)

* **서블릿 인스턴스 생성 (Loading & Instantiation)**:
    * 생성된 `.class` 파일을 JVM(Java Virtual Machine)이 메모리로 로딩하고, 해당 클래스의 **서블릿 인스턴스(객체)**를 생성합니다. 이제 JSP 파일이 메모리상에서 서블릿 객체로 존재하게 됩니다.

* **초기화 (`jspInit()` 호출)**:
    * 서블릿 인스턴스가 성공적으로 생성되면, 웹 컨테이너는 이 인스턴스의 `jspInit()` 메서드를 **단 한 번** 호출하여 초기화 작업을 수행합니다. 이 `jspInit()` 메서드는 서블릿의 `init()` 메서드와 동일한 역할을 하며, 애플리케이션 시작 시 필요한 자원(예: 데이터베이스 연결 풀, 설정 파일 로딩)을 미리 준비하는 데 사용됩니다.

    **[예시: `jspInit()` 메서드 사용]**
    `counter.jsp`
    ```jsp
    <%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
    <%!
        // JSP 선언부: 이 변수는 서블릿의 멤버 변수로 변환됩니다.
        private int visitCount = 0;

        // jspInit() 오버라이드: 서블릿 초기화 시 한 번만 실행
        @Override
        public void jspInit() {
            super.jspInit();
            System.out.println("counter.jsp 서블릿이 초기화되었습니다. visitCount = " + visitCount);
            // 실제 애플리케이션에서는 DB 연결 등 무거운 초기화 작업 수행
        }

        // jspDestroy() 오버라이드: 서블릿 소멸 시 한 번만 실행
        @Override
        public void jspDestroy() {
            super.jspDestroy();
            System.out.println("counter.jsp 서블릿이 소멸되었습니다. 최종 visitCount = " + visitCount);
            // 실제 애플리케이션에서는 자원 해제 작업 수행
        }
    %>
    <!DOCTYPE html>
    <html>
    <head>
    <meta charset="UTF-8">
    <title>방문자 카운터</title>
    </head>
    <body>
        <h1>이 페이지는 <%= ++visitCount %>번 방문되었습니다.</h1>
        <p>페이지를 새로고침할 때마다 숫자가 증가합니다.</p>
        <p>서버 재시작 전까지 visitCount는 유지됩니다.</p>
    </body>
    </html>
    ```
    (콘솔 출력 예시)
    ```
    INFO: Initializing Servlet 'org.apache.jsp.counter_jsp'
    counter.jsp 서블릿이 초기화되었습니다. visitCount = 0
    ```

#### 4. 재요청 시 (즉시 실행)

이후 동일한 JSP 파일에 대한 요청이 들어오면, 웹 컨테이너는 이미 메모리에 해당 서블릿 인스턴스가 존재함을 확인합니다. 이 경우에는 3번의 복잡한 변환 및 컴파일 과정을 **생략**하고 즉시 다음 단계로 넘어갑니다. 이는 성능 최적화를 위한 중요한 메커니즘입니다.

#### 5. 핵심 기능 실행 (`_jspService()` 호출)

이제 메모리에 준비된 서블릿 인스턴스의 `_jspService()` 메서드가 호출됩니다. 이 `_jspService()` 메서드는 서블릿의 `service()` 메서드와 동일한 역할을 하며, 클라이언트의 요청이 들어올 때마다 **반복적으로 실행되는 핵심 로직**을 담고 있습니다.

이 `_jspService()` 메서드 내에서 실제 JSP 페이지의 스크립트릿(`<&#37; %>`)과 표현식(`<&#37;= %>`)에 작성된 자바 코드가 실행되고, 그 결과로 동적인 내용이 포함된 **HTML 코드가 생성됩니다.**

**[예시: `_jspService()` 동작]**
위 `hello.jsp`의 변환된 `.java` 코드에서 볼 수 있듯이, 모든 HTML과 동적 결과물이 `out.write()` 또는 `out.print()` 메서드를 통해 클라이언트로 전송될 데이터를 버퍼에 기록합니다.

#### 6. 클라이언트에게 응답

`_jspService()` 메서드가 생성한 최종 HTML 결과(웹 컨테이너의 출력 버퍼에 담긴 내용)가 HTTP 응답의 `body` 부분에 담겨 클라이언트(웹 브라우저)로 전송됩니다. 웹 브라우저는 이 HTML을 파싱하여 사용자에게 보이는 웹 페이지로 나타냅니다.


---

## 서블릿 생명주기 완벽 이해: `init()`, `service()`, `destroy()`

앞서 JSP가 웹 컨테이너에 의해 서블릿으로 변환되고 실행되는 과정을 살펴보았습니다. 이때 JSP에서 변환된 서블릿을 포함한 모든 서블릿은 웹 컨테이너(WAS)에 의해 관리되는 특별한 '생명주기'를 가집니다. 이 생명주기는 크게 **초기화, 요청 처리, 소멸**의 세 단계로 나뉘며, 각 단계마다 특정 메서드가 호출됩니다. 이 문서에서는 서블릿 생명주기의 핵심 메서드인 `init()`, `service()`, `destroy()`에 대해 코드 예시와 함께 상세히 알아봅니다.

---

### 🌟 서블릿의 생명주기 메서드

서블릿의 생명주기는 웹 컨테이너가 서블릿 객체를 생성하고, 요청을 처리하며, 소멸시키는 일련의 과정입니다. 이 과정에서 컨테이너는 특정 시점에 미리 정의된 메서드를 호출하여 서블릿이 필요한 작업을 수행하도록 합니다.

#### 1. `init()` (초기화 단계)

* **역할**: 서블릿 객체가 웹 컨테이너에 의해 **최초로 생성될 때** (또는 웹 컨테이너 시작 시) **단 한 번만** 호출되는 메서드입니다.
* **특징**:
    * 서블릿이 클라이언트 요청을 처리하기 전에 필요한 모든 초기화 작업을 수행하는 데 사용됩니다.
    * **데이터베이스 연결 풀 초기화**, 설정 파일 로딩, 애플리케이션 시작 시 필요한 자원 로딩 등 **무겁거나 시간이 오래 걸리는 작업**을 이 메서드에서 처리합니다.
    * 이 메서드는 한 번만 호출되므로, 여러 요청이 동시에 들어와도 중복 실행되지 않아 **성능상 이점**이 있습니다.
* **코드 스니펫 예시:**

    ```java
    package com.example.servlet;

    import jakarta.servlet.ServletConfig;
    import jakarta.servlet.ServletException;
    import jakarta.servlet.annotation.WebServlet;
    import jakarta.servlet.http.HttpServlet;

    @WebServlet(urlPatterns = "/myServlet", loadOnStartup = 1) // loadOnStartup = 1 은 웹 컨테이너 시작 시 서블릿을 미리 초기화하도록 지시
    public class MyLifeCycleServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        private int counter; // 서블릿의 멤버 변수

        public MyLifeCycleServlet() {
            super();
            System.out.println("1. MyLifeCycleServlet 객체 생성자 호출됨");
        }

        @Override
        public void init(ServletConfig config) throws ServletException {
            super.init(config);
            counter = 0; // 초기화 시점에 카운터 0으로 설정
            System.out.println("2. init() 메서드 호출됨: 서블릿이 초기화되었습니다.");
            System.out.println("   (예: 데이터베이스 연결 풀 초기화, 설정 파일 로딩 등)");
        }

        // ... (service() 및 destroy() 메서드는 아래에서 설명)
    }
    ```
    **[콘솔 출력 예시 (웹 컨테이너 시작 시 또는 첫 요청 시)]**
    ```
    1. MyLifeCycleServlet 객체 생성자 호출됨
    2. init() 메서드 호출됨: 서블릿이 초기화되었습니다.
       (예: 데이터베이스 연결 풀 초기화, 설정 파일 로딩 등)
    ```
    `loadOnStartup` 속성을 사용하면 웹 컨테이너가 시작될 때 이 서블릿을 미리 초기화하여 첫 요청 시 지연 시간을 줄일 수 있습니다.

#### 2. `service()` (요청 처리 단계)

* **역할**: 클라이언트로부터 **요청이 들어올 때마다 반복적으로 호출**되는 메서드입니다. 실제 클라이언트의 요청을 받아 비즈니스 로직을 처리하고 응답을 생성하는 **핵심 역할**을 담당합니다.
* **특징**:
    * `HttpServlet` 클래스의 `service()` 메서드는 클라이언트의 HTTP 요청 메서드(GET, POST, PUT, DELETE 등)를 자동으로 감지하여 내부적으로 `doGet()`, `doPost()`, `doPut()`, `doDelete()`와 같은 해당 메서드를 호출합니다.
    * 따라서 개발자는 보통 `service()` 메서드를 직접 오버라이드하기보다는, 처리하려는 HTTP 메서드에 맞춰 `doGet()`이나 `doPost()` 등을 오버라이드하여 구현합니다.
* **코드 스니펫 예시:**

    ```java
    package com.example.servlet;

    // ... (imports 생략)

    @WebServlet(urlPatterns = "/myServlet", loadOnStartup = 1)
    public class MyLifeCycleServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        private int counter;

        // ... (생성자, init() 생략)

        @Override
        protected void doGet(HttpServletRequest request, HttpServletResponse response)
                throws ServletException, IOException {
            counter++; // 요청이 올 때마다 카운터 증가
            System.out.println("3. doGet() 메서드 호출됨: 클라이언트 요청 처리 (현재 카운터: " + counter + ")");

            response.setContentType("text/html;charset=UTF-8");
            response.getWriter().println("<h1>요청이 " + counter + "번째 처리되었습니다.</h1>");
            response.getWriter().println("<p>현재 시간: " + new java.util.Date() + "</p>");
        }

        @Override
        protected void doPost(HttpServletRequest request, HttpServletResponse response)
                throws ServletException, IOException {
            System.out.println("3. doPost() 메서드 호출됨: POST 요청 처리");
            response.setContentType("text/html;charset=UTF-8");
            response.getWriter().println("<h1>POST 요청이 성공적으로 처리되었습니다.</h1>");
            // 실제로는 request.getParameter()를 사용하여 POST 데이터를 처리
        }

        // ... (destroy() 메서드는 아래에서 설명)
    }
    ```
    **[콘솔 출력 예시 (클라이언트가 `/myServlet`에 GET 요청을 보낼 때마다)]**
    ```
    3. doGet() 메서드 호출됨: 클라이언트 요청 처리 (현재 카운터: 1)
    3. doGet() 메서드 호출됨: 클라이언트 요청 처리 (현재 카운터: 2)
    ...
    ```

#### 3. `destroy()` (소멸 단계)

* **역할**: 서블릿이 메모리에서 제거될 때 (예: 웹 컨테이너 종료, 서블릿 파일 변경으로 인한 재배포, 웹 애플리케이션 종료 등) **단 한 번만** 호출되는 메서드입니다.
* **특징**:
    * `init()` 메서드에서 할당했던 자원들을 **해제(클로즈)**하는 역할을 수행합니다.
    * **데이터베이스 연결 종료**, 열려 있는 파일 닫기, 스레드 풀 종료 등 메모리 누수를 방지하고 애플리케이션을 **깔끔하게 마무리**하는 데 사용됩니다.
    * 이 메서드 호출 후에는 서블릿 객체가 더 이상 사용되지 않으므로, 이 시점에 자원 해제 작업을 완료해야 합니다.
* **코드 스니펫 예시:**

    ```java
    package com.example.servlet;

    // ... (imports 생략)

    @WebServlet(urlPatterns = "/myServlet", loadOnStartup = 1)
    public class MyLifeCycleServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
        private int counter;

        // ... (생성자, init(), doGet(), doPost() 생략)

        @Override
        public void destroy() {
            System.out.println("4. destroy() 메서드 호출됨: 서블릿이 소멸됩니다.");
            System.out.println("   (예: 데이터베이스 연결 해제, 열린 파일 닫기 등)");
            // 여기에서 자원 해제 로직을 구현합니다.
            super.destroy(); // 항상 부모 클래스의 destroy()를 호출하는 것이 좋습니다.
        }
    }
    ```
    **[콘솔 출력 예시 (웹 컨테이너 종료 시)]**
    ```
    4. destroy() 메서드 호출됨: 서블릿이 소멸됩니다.
       (예: 데이터베이스 연결 해제, 열린 파일 닫기 등)
    INFO: Destroying Servlet 'org.apache.jsp.myServlet'
    ```

---


### 📝 마무리

JSP의 실행 과정은 단순한 파일 로딩이 아닌, 웹 컨테이너에 의한 복잡하지만 효율적인 **변환, 컴파일, 로딩, 실행 단계**를 거칩니다. 이 메커니즘을 이해하는 것은 JSP 기반 웹 애플리케이션의 성능 최적화와 문제 해결에 필수적입니다. 개발자는 이 과정을 통해 JSP가 단순히 HTML에 Java 코드를 삽입하는 것을 넘어, 강력한 서버 사이드 기술인 서블릿으로 변환되어 동적 웹 페이지를 생성한다는 것을 이해할 수 있습니다. 또한 서블릿의 생명주기는 웹 컨테이너가 서블릿을 효율적으로 관리하고 실행하는 핵심 메커니즘입니다. `init()` 메서드를 통한 초기 자원 준비, `service()` (또는 `doGet()`, `doPost()`)를 통한 반복적인 요청 처리, 그리고 `destroy()` 메서드를 통한 자원 해제는 서블릿 기반 웹 애플리케이션의 안정성과 성능을 보장하는 중요한 요소입니다. 이 생명주기를 정확히 이해하는 것은 JSP/서블릿 개발뿐만 아니라 Spring MVC와 같은 프레임워크 학습에도 필수적인 기반 지식이 됩니다
