---
title: "JSP - 용어 정리(3)"
date: 2025-06-11 17:21:55 +09:00
categories: [jsp]
lang: ko
locale: ko
words_per_minute: 30

---

---
## JSP 완전 정복 2탄: 에러 잡고, 코드 깔끔하게! (feat. 실행 과정의 비밀)

지난 시간 JSP 1탄에서는 동적인 웹 페이지의 개념과 JSP의 탄생 배경, 그리고 서블릿과의 차이점, 기본적인 파일 구조에 대해 알아보았죠. 오늘은 조금 더 심화된 내용으로 들어가서, JSP 개발을 하면서 꼭 알아두면 좋을 **에러 처리 노하우**, **JSP 지시어**의 알찬 활용법, 그리고 **JSP 파일이 브라우저에 나타나기까지 어떤 일이 일어나는지** 그 실행 과정을 파헤쳐 볼 거예요. 

---

### 🚨 JSP 에러 처리, 선택이 아닌 필수! (feat. 사용자 경험과 보안)

여러분, 웹 페이지를 이용하다가 갑자기 알 수 없는 복잡한 오류 메시지와 코드들이 가득한 흰 화면을 본 적 있으신가요? 보통 '500 Internal Server Error'라고 뜨는 그런 화면 말이에요. 개발자 입장에서는 버그를 찾아야 하니 도움이 될 수 있지만, 일반 사용자 입장에서는 정말 불쾌하고 당황스럽기 그지없죠. "이 사이트 믿을 수 있는 거야?"라는 생각이 절로 들 겁니다. 게다가, 자바 코드의 일부가 그대로 노출되는 것은 **보안상으로도 아주 치명적인 문제**가 될 수 있어요!

JSP 페이지에서 이런 불상사를 막기 위한 해결책은 크게 두 가지가 있습니다.

#### 1. `try-catch` 블록으로 코드 안에서 우아하게 예외 처리하기

자바 개발 좀 해보셨다면 익숙하실 거예요! `try-catch` 블록은 예외 발생 가능성이 있는 코드를 `try` 블록 안에 넣고, 만약 예외가 발생하면 `catch` 블록에서 정의한 코드를 실행하게 하는 자바의 기본 예외 처리 메커니즘이죠. JSP 스크립트릿 안에서도 똑같이 사용할 수 있어요.

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>try-catch로 에러 잡기</title>
</head>
<body>
<%
    // 사용자가 'age'라는 이름의 파라미터를 안 보내거나, 숫자가 아닌 값을 보낼 때를 가정해볼까요?
    // 이럴 때 Integer.parseInt()는 'NumberFormatException'이라는 에러를 뿜어낼 거예요.
    try {
        int myAge = Integer.parseInt(request.getParameter("age")) + 10;
        out.println("<h3>10년 후 당신의 나이는: " + myAge + "세 입니다.</h3>");
    } catch (NumberFormatException e) { // 숫자가 아닌 값을 받았을 때 발생하는 예외
        // 에러가 발생했을 때 사용자에게 보여줄 친절한 메시지!
        out.println("<h3>죄송합니다! 나이는 숫자로 입력해 주셔야 해요. 😅</h3>");
        // 개발자만 볼 수 있게 에러 메시지를 콘솔에 출력할 수도 있어요.
        // e.printStackTrace(); 
    } catch (Exception e) { // 그 외 모든 예외를 잡을 때
        out.println("<h3>알 수 없는 오류가 발생했어요! 다시 시도해주세요.</h3>");
    }
%>
</body>
</html>
```

**코드를 자세히 보면:**
* `try` 블록 안에는 `Integer.parseInt()`처럼 예외가 터질 수 있는 코드를 넣었어요.
* 만약 여기서 `NumberFormatException`이라는 특정 예외가 발생하면 첫 번째 `catch` 블록이 잡아서 친절한 안내 문구를 출력해 줍니다.
* 예상치 못한 다른 종류의 예외가 발생하면 `Exception` 타입의 두 번째 `catch` 블록이 처리하도록 했죠.

**장점**: 해당 페이지 내에서 에러를 깔끔하게 처리하고, 필요하다면 복구 로직까지 수행할 수 있습니다.
**단점**: 모든 예외 발생 가능 코드에 일일이 `try-catch`를 적용하는 건 귀찮을 수 있겠죠? 코드도 길어지고요.

#### 2. `errorPage`, `isErrorPage` 속성으로 전문적인 에러 페이지 보여주기

이 방법은 '에러가 나면 특정 페이지로 이동해서 거기서 에러 정보를 보여줘!'라고 설정하는 거예요. 사용자에게 훨씬 깔끔하고 일관된 에러 화면을 제공할 수 있어서 실제 서비스에서 많이 활용됩니다.

먼저, 에러 정보를 보여줄 JSP 페이지를 만들어야 해요. 예를 들어 `errorPage.jsp`라고 이름 붙여보겠습니다.

**`errorPage.jsp` (에러를 처리할 전용 페이지)**

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" isErrorPage="true"%> <%--  이 페이지는 에러 전용입니다! --%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>앗! 오류가 발생했어요 😱</title>
<style>
    body { font-family: Arial, sans-serif; text-align: center; margin-top: 50px; }
    h2 { color: #e74c3c; }
    .error-details { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; padding: 20px; margin: 20px auto; width: 60%; border-radius: 8px; }
</style>
</head>
<body>
    <h2>서비스에 일시적인 오류가 발생했습니다.</h2>
    <p>불편을 드려 죄송합니다. 잠시 후 다시 시도해 주세요.</p>

    <div class="error-details">
        <h3>오류 상세 정보 (개발자용)</h3>
        <p><strong>오류명:</strong> <%= exception.getClass().getName() %></p> <%-- 발생한 예외의 클래스명 --%>
        <p><strong>오류 메시지:</strong> <%= exception.getMessage() %></p> <%-- 발생한 예외의 상세 메시지 --%>
    </div>
    <p><a href="/">메인 페이지로 돌아가기</a></p>
</body>
</html>
```

**핵심**: `isErrorPage="true"` 이 속성이 있어야 JSP 페이지 내부에서 `exception`이라는 특별한 내장 객체를 사용할 수 있어요. 이 `exception` 객체가 바로 발생한 에러의 모든 정보를 가지고 있습니다.

이제, 에러가 발생할 수 있는 일반 JSP 페이지에 이 `errorPage.jsp`를 연결해볼게요.

**`mainPage.jsp` (에러가 발생할 수 있는 일반 페이지)**

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" errorPage="errorPage.jsp"%> <%-- 에러 나면 errorPage.jsp로 가십시오. --%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>나이 입력 페이지</title>
</head>
<body>
    <h1>당신의 나이를 입력해주세요!</h1>
    <form action="mainPage.jsp" method="get">
        나이: <input type="text" name="age">
        <input type="submit" value="제출">
    </form>
<%
    // 사용자가 'age' 파라미터를 안 보내거나 숫자가 아닌 값을 보내면 여기서 NumberFormatException 발생!
    // 그럼 자동으로 위에 지정한 errorPage.jsp로 이동해요.
    if (request.getParameter("age") != null && !request.getParameter("age").isEmpty()) {
        int age = Integer.parseInt(request.getParameter("age"));
        out.println("<p>입력하신 나이는: " + age + "세 입니다.</p>");
    } else {
        out.println("<p>나이를 입력해주세요.</p>");
    }
%>
</body>
</html>
```

**이 방식의 흐름은 이래요:**
1.  `mainPage.jsp`에서 `age` 파라미터 관련 예외(예: 사용자가 'abc'를 입력)가 발생합니다.
2.  `mainPage.jsp`의 `errorPage="errorPage.jsp"` 속성 덕분에 JSP 엔진이 자동으로 요청을 `errorPage.jsp`로 넘겨줍니다.
3.  `errorPage.jsp`는 `isErrorPage="true"`로 설정되어 있어서, `exception` 내장 객체를 통해 발생한 예외 정보를 받아서 사용자에게 보여줄 수 있습니다.

**장점**: 사용자가 보기에도 훨씬 깔끔하고, 개발자는 에러 처리 로직을 별도의 페이지로 분리할 수 있어서 코드 관리도 쉬워져요. 사이트의 신뢰도도 팍팍 올라가겠죠!

---

### `page` 지시어, 숨겨진 재주꾼! (feat. `trimDirectiveWhitespaces`, `include`, `taglib`)

`page` 지시어는 JSP 페이지의 '성격'을 정의하는 아주 중요한 역할을 한다고 말씀드렸죠? 이전에 다룬 `language`, `contentType`, `pageEncoding`, `import`, `errorPage`, `isErrorPage` 외에도 유용한 속성들이 더 있습니다!

#### 1. `trimDirectiveWhitespaces="true"`: HTML 소스 코드 깔끔하게!

JSP 코드를 작성하다 보면 `<%@ ... %>` 같은 지시어 때문에 실제 웹 페이지의 HTML 소스 코드를 보면 불필요한 빈 줄이나 공백이 상단에 생기는 경우가 있어요. 이런 지저분한 공백들을 자동으로 제거해주는 속성이 바로 `trimDirectiveWhitespaces`입니다.

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" trimDirectiveWhitespaces="true"%> <%-- 불필요한 공백 제거 요청 --%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>공백 없는 깨끗한 JSP</title>
</head>
<body>
    <p>안녕하세요. 저는 공백 없이 깔끔한 JSP 페이지입니다.</p>
</body>
</html>
```

**설명**:
`trimDirectiveWhitespaces="true"`를 설정하면, JSP 엔진이 이 페이지를 서블릿 코드로 변환할 때 지시어들이 남기는 불필요한 공백을 싹 다 정리해줘요. 웹 브라우저에서 '페이지 소스 보기'를 했을 때, 지시어 때문에 생겼던 빈 줄들이 사라진 걸 확인할 수 있을 거예요.

**목적**: 생성되는 HTML 소스 코드를 보기 좋게 만들고, 아주 미세하게 파일 크기를 줄여 네트워크 전송량을 아낄 수도 있습니다.

#### 2. `include` 지시어: 공통 코드 재활용의 마법!

웹 페이지를 만들다 보면 헤더, 푸터, 내비게이션 바처럼 여러 페이지에 **반복해서 등장하는 부분**들이 많아요. 이런 공통 코드를 매번 모든 페이지에 복사+붙여넣기 하는 건 비효율적이고, 나중에 수정할 때도 모든 파일을 다 찾아 고쳐야 하는 불상사가 생기죠. 이럴 때 `include` 지시어가 빛을 발합니다.

```jsp
<%-- includeFile.jsp (포함될 파일) --%>
<%@ page import="java.time.LocalDate, java.time.LocalDateTime" %> <%-- 필요한 클래스 임포트 --%>
<%
    // 스크립트릿: 현재 날짜와 내일 날짜 계산
    LocalDate today = LocalDate.now();
    LocalDate tomorrow = LocalDate.now().plusDays(1);
%>
<header>
    <h1>우리 웹사이트</h1>
    <nav>
        <a href="/">홈</a> | <a href="/about">소개</a> | <a href="/contact">문의</a>
    </nav>
</header>
```

```jsp
<%-- includeMain.jsp (포함시키는 파일) --%>
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ include file="includeFile.jsp" %> <%-- includeFile.jsp의 내용을 여기에 그대로 넣어 주십시오. --%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>include 지시어 활용</title>
</head>
<body>
    <%-- includeFile.jsp에 포함된 header 내용이 여기에 출력됨 --%>
    <p>오늘 날짜: <%= today %></p>
    <p>내일 날짜: <%= tomorrow %></p>
    <footer>
        <p>&copy; 2024 내 웹사이트. 모든 권리 보유.</p>
    </footer>
</body>
</html>
```

**어떻게 동작할까?**:
`<%@ include file="includeFile.jsp" %>` 이 한 줄이 핵심이에요. 이 지시어는 JSP 파일이 **컴파일되는 시점**에 `includeFile.jsp`의 내용을 `includeMain.jsp` 안으로 **그대로 복사해서 합쳐버립니다.** 그래서 `includeMain.jsp`에서는 `includeFile.jsp`에서 선언된 `today`, `tomorrow` 변수나 `<header>` 태그를 마치 자기 코드인 것처럼 사용할 수 있게 되는 거죠.

**장점**: 코드의 재사용성을 높이고, 유지보수를 훨씬 쉽게 만들어줘요. 공통 부분을 한 곳에서 관리하면 된답니다!

#### 3. `taglib` 지시어: 고급 기능을 태그처럼 쓰기!

JSP는 HTML 안에 자바 코드를 직접 쓰는 스크립트릿 방식 외에도, 마치 HTML 태그처럼 생긴 **커스텀 태그**들을 사용해서 더 깔끔하고 강력한 기능을 구현할 수 있도록 해줘요. 이때 필요한 것이 바로 `taglib` 지시어입니다.

```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> <%-- JSTL Core 라이브러리 선언 --%>
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %> <%-- JSTL Format 라이브러리 선언 --%>
```

**설명**:
* `prefix="c"`: 이 라이브러리에 속한 태그들을 사용할 때 `<c:if>`, `<c:forEach>`처럼 `c:`라는 접두사를 붙이겠다는 의미예요.
* `uri="http://java.sun.com/jsp/jstl/core"`: 이 접두사에 해당하는 태그 라이브러리가 어디에 정의되어 있는지 그 '주소(URI)'를 알려주는 역할을 합니다.

이 지시어를 통해 **JSTL(JSP Standard Tag Library)**이라는 아주 유용한 표준 태그 라이브러리를 JSP 페이지에서 사용할 수 있게 됩니다. JSTL은 반복문, 조건문, 숫자/날짜 형식 지정 등 자주 사용되는 기능을 미리 태그 형태로 만들어 둔 것이어서, JSP 코드 안에서 자바 스크립트릿을 직접 쓰는 것보다 훨씬 깔끔하고 읽기 쉬운 코드를 작성할 수 있도록 도와줘요.

---

### 스크립트 요소: HTML 속에 살아 숨 쉬는 자바 코드!

JSP의 가장 핵심적인 문법이죠! HTML 문서 안에 자바 코드를 직접 삽입해서 동적인 기능을 구현하게 해주는 영역을 **스크립트 요소**라고 해요. 크게 세 가지 종류가 있습니다.

#### 1. 선언부 (`<%! ... %>`)

* **역할**: JSP 페이지 전체에서 공유하고 사용할 **멤버 변수(필드)**나 **메서드**를 정의하는 곳이에요.
* **특징**: JSP 파일이 서블릿으로 변환될 때, 이 안의 코드는 서블릿 클래스의 `_jspService()` 메서드 **바깥쪽**에 위치하게 됩니다. 그래서 이 변수나 메서드들은 해당 서블릿 클래스의 모든 메서드에서 접근할 수 있는 '전역'적인 요소가 되죠.
* **비유**: 클래스 설계도에 적어두는 '공통으로 사용할 재료'나 '공통 기능' 같은 거예요.

```jsp
<%! 
    // 멤버 변수: 페이지 방문 횟수를 저장 (모든 요청에서 공유)
    private int visitCount = 0; 

    // 멤버 메서드: 두 숫자를 더하는 기능 (어디서든 호출 가능)
    public int calculateSum(int num1, int num2) {
        return num1 + num2;
    }
%>
```

#### 2. 스크립트릿 (`<% ... %>`)

* **역할**: JSP 페이지가 클라이언트의 **요청을 받을 때마다 실행되어야 할 자바 코드 로직**을 작성하는 영역이에요. 대부분의 자바 코드는 여기에 작성합니다.
* **특징**: 서블릿으로 변환될 때 `_jspService()` 메서드 **안쪽**에 그대로 들어갑니다. 따라서 이곳에 선언된 변수는 이 스크립트릿 내부에서만 유효한 **지역 변수**가 돼요.
* **제약**: 자바의 메서드 안에 또 다른 메서드를 선언할 수 없는 것처럼, 스크립트릿 안에서도 새로운 메서드를 선언할 수는 없어요. 하지만 선언부에서 정의한 메서드는 호출해서 사용할 수 있습니다.
* **비유**: 요청이 올 때마다 '이걸 하고 저걸 계산해라!' 하고 지시하는 '일꾼' 같은 코드 덩어리에요.

```jsp
<% 
    // 지역 변수: 이 스크립트릿 내에서만 유효
    String userName = request.getParameter("name"); 
    
    // 방문 횟수 증가 (선언부의 멤버 변수 사용)
    visitCount++; 

    // 선언부의 메서드 호출 및 결과 출력
    int sum = calculateSum(5, 7);
    out.println("<p>" + userName + "님, 안녕하세요! 반갑습니다.</p>");
    out.println("<p>두 숫자의 합: " + sum + "</p>");
%>
```

#### 3. 표현식 (`<%= ... %>`)

* **역할**: 실행 결과로 **하나의 값** (변수, 수식, 상수, 반환 값이 있는 메서드 호출 결과 등)을 **웹 브라우저 화면에 직접 출력**하고 싶을 때 사용합니다.
* **특징**: 마치 `System.out.println()`이나 `out.print()`를 쓰는 것과 동일한 효과를 냅니다. 값을 '표현'하는 아주 간결한 방법이죠.
* **비유**: 계산된 결과값을 '톡'하고 화면에 내뱉는 작은 스피커 같습니다.

```jsp
<body>
    <%-- 스크립트릿에서 계산된 값이나 선언부의 변수를 바로 출력 --%>
    <p>현재 방문 횟수: <%= visitCount %></p>
    <p>간단한 계산: <%= 10 * 5 %></p>
    <p>메서드 결과: <%= calculateSum(100, 200) %></p>
</body>
```

**스크립트 요소 활용 예시 (한 번에 보기)**

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>JSP 스크립트 요소 총집합</title>
</head>
<body>
    <%! // <%! ... %> 선언부: 멤버 변수와 메서드 선언
        private int totalAccess = 0; // 이 JSP 페이지의 총 접근 횟수 (멤버 변수)

        public String getWebsiteName() { // 웹사이트 이름 반환 메서드 (멤버 메서드)
            return "내 멋진 웹사이트";
        }
    %>

    <% // <% ... %> 스크립트릿: 요청마다 실행되는 로직
        totalAccess++; // 페이지 접근 시마다 totalAccess 1 증가
        String userName = "방문객";
        // 파라미터가 있다면 사용자 이름으로 설정
        if (request.getParameter("name") != null && !request.getParameter("name").isEmpty()) {
            userName = request.getParameter("name");
        }
    %>

    <h1><%= getWebsiteName() %>에 오신 것을 환영합니다!</h1> <%-- <%= ... %> 표현식: 메서드 결과 출력 --%>
    <p><%= userName %>님, 안녕하세요!</p> <%-- 표현식: 변수 값 출력 --%>
    <p>이 페이지는 지금까지 <%= totalAccess %>번 방문되었습니다.</p> <%-- 표현식: 멤버 변수 출력 --%>
    <p>오늘의 행운의 숫자: <%= Math.random() * 100 %></p> <%-- 표현식: 수식 결과 출력 --%>

    <% // 스크립트릿: 조건문 예시
        if (totalAccess < 5) {
    %>
        <p>아직 새로운 방문객이 많네요!</p>
    <%
        } else {
    %>
        <p>꾸준히 찾아주셔서 감사합니다!</p>
    <%
        }
    %>
</body>
</html>
```

**출력 결과 (예시):**
처음 접속 시:
```
내 멋진 웹사이트에 오신 것을 환영합니다!
방문객님, 안녕하세요!
이 페이지는 지금까지 1번 방문되었습니다.
오늘의 행운의 숫자: 72.123456...
아직 새로운 방문객이 많네요!
```
두 번째 접속 시:
```
내 멋진 웹사이트에 오신 것을 환영합니다!
방문객님, 안녕하세요!
이 페이지는 지금까지 2번 방문되었습니다.
오늘의 행운의 숫자: 34.56789...
아직 새로운 방문객이 많네요!
```
(그리고 `http://localhost:8080/your_app/example.jsp?name=윤효재` 로 접속 시)
```
내 멋진 웹사이트에 오신 것을 환영합니다!
윤효재님, 안녕하세요!
이 페이지는 지금까지 3번 방문되었습니다.
오늘의 행운의 숫자: 12.34567...
아직 새로운 방문객이 많네요!
```

---

### 🔄 JSP, 어떻게 화면으로 나올까? (실행 과정과 서블릿의 생명주기)

우리가 만든 `.jsp` 파일은 사실 그 자체로 바로 실행되는 게 아니에요. 웹 컨테이너(WAS, 예를 들면 Tomcat)가 작업을 해줘야만 비로소 웹 브라우저에서 볼 수 있는 HTML 페이지로 변합니다.

#### 🪄 JSP의 변신 과정: 요청부터 응답까지!

1.  **클라이언트의 요청**: 사용자가 웹 브라우저에 `http://localhost:8080/myWebApp/twoDice.jsp`와 같은 URL을 입력하고 Enter를 누릅니다. (`twoDice.jsp`는 여러분이 만든 JSP 파일이라고 상상해보세요!)

2.  **웹 컨테이너의 확인**: 이 요청은 웹 컨테이너(WAS)로 전달됩니다. 웹 컨테이너는 '어? `twoDice.jsp` 요청이 들어왔네? 혹시 이 JSP 파일에 해당하는 서블릿 인스턴스(객체)가 이미 메모리에 올라와 있나?' 하고 확인해요. 이 정보는 **서블릿 컨텍스트(Servlet Context)**라는 곳에 저장되어 있습니다. (서블릿 컨텍스트는 웹 애플리케이션 전체에서 공유되는 정보나, 등록된 서블릿 객체들의 목록 등을 관리하는 공간입니다.)

3.  **최초 요청 또는 변경 사항 발생 시 (변신 시작!)**:
    * 만약 `twoDice.jsp`가 **처음 요청되거나**, 또는 JSP 파일이 **수정되어서 최신 버전이 아닐 경우**에는 웹 컨테이너가 마법을 부리기 시작해요.
    * **JSP를 서블릿 코드로 변환**: 먼저, `.jsp` 파일을 자바 서블릿 코드(`.java` 파일)로 바꿔줍니다. 예를 들면 `twoDice_jsp.java` 같은 파일이 만들어지는 거죠. 이 과정에서 지시어, 스크립트 요소들이 실제 서블릿 코드로 변환됩니다.
    * **서블릿 코드 컴파일**: 변환된 `.java` 파일을 자바 컴파일러가 컴파일하여 실행 가능한 **서블릿 클래스 파일(`.class`)**을 생성합니다. (예: `twoDice_jsp.class`)
    * **서블릿 인스턴스 생성**: 생성된 `.class` 파일을 JVM(Java Virtual Machine)이 로딩하여 메모리에 **서블릿 인스턴스(객체)**를 만듭니다.
    * **초기화 (`jspInit()` 호출)**: 서블릿 인스턴스가 생성되면, 웹 컨테이너는 이 인스턴스의 `jspInit()` 메서드를 **단 한 번** 호출하여 초기화 작업을 수행합니다. (이 `jspInit()`은 서블릿의 `init()` 메서드와 동일한 역할을 해요.)

4.  **재요청 시 (바로 실행!)**:
    * 이후 동일한 `twoDice.jsp`에 대한 요청이 들어오면, 웹 컨테이너는 이미 메모리에 서블릿 인스턴스가 존재한다는 것을 확인하고 3번의 복잡한 변환 및 컴파일 과정을 생략합니다.

5.  **핵심 기능 실행 (`_jspService()` 호출)**:
    * 이제 메모리에 준비된 서블릿 인스턴스의 `_jspService()` 메서드가 호출됩니다. (이 `_jspService()`는 서블릿의 `service()` 메서드와 동일한 역할을 해요.)
    * 이 `_jspService()` 메서드 안에서 실제 JSP 페이지의 스크립트릿과 표현식에 작성된 자바 코드가 실행되고, 그 결과로 동적인 내용이 포함된 **HTML 코드가 생성**됩니다.

6.  **클라이언트에게 응답**: `_jspService()` 메서드가 만들어낸 최종 HTML 결과가 클라이언트(웹 브라우저)로 전송되어 우리 눈에 보이는 웹 페이지로 나타나는 거죠!

#### 🕰️ 서블릿의 생명주기: `init()`, `service()`, `destroy()`

방금 JSP 실행 과정에서 잠깐 언급된 `init()`, `service()`, `destroy()` 메서드들은 모든 서블릿(JSP에서 변환된 서블릿 포함)이 웹 컨테이너에 의해 관리되는 중요한 '생명주기' 메서드들이에요. (생명주기.. 이거 Java의 변수 포스팅에서도 나온 그거 맞습니다!)

* **`init()` (초기화 단계)**:
    * **역할**: 서블릿 객체가 웹 컨테이너에 의해 **최초로 생성될 때** (또는 웹 컨테이너 시작 시) **단 한 번만** 호출되는 메서드예요.
    * **특징**: 데이터베이스 연결 풀 초기화, 설정 파일 로딩 등 서블릿이 동작하는 데 필요한 무거운 자원들을 한 번만 미리 준비하는 데 사용됩니다. 이렇게 하면 매 요청마다 반복적으로 자원을 로딩하는 비효율을 막을 수 있어요.

* **`service()` (요청 처리 단계)**:
    * **역할**: 클라이언트로부터 **요청이 들어올 때마다 반복적으로 호출**되는 메서드예요. 실제 클라이언트의 요청을 받아 비즈니스 로직을 처리하고 응답을 생성하는 핵심 역할을 담당합니다.
    * **특징**: HTTP 메서드(GET, POST 등)에 따라 내부적으로 `doGet()`, `doPost()` 등의 메서드를 호출하여 적절하게 요청을 처리해요.

* **`destroy()` (소멸 단계)**:
    * **역할**: 서블릿이 메모리에서 제거될 때 (예: 웹 컨테이너 종료, 서블릿 파일 변경으로 인한 재배포 등) **단 한 번만** 호출되는 메서드예요.
    * **특징**: `init()`에서 할당했던 자원들을 해제(DB 연결 종료, 파일 닫기 등)하여 메모리 누수를 방지하고 깔끔하게 마무리하는 역할을 합니다.

---

### 📝 마치며

어떠셨나요? 오늘은 JSP의 에러 처리부터 지시어, 스크립트 요소, 그리고 JSP 파일이 실제로 어떻게 동작하는지 그 내부 과정을 상세하게 들여다봤어요. 단순히 코드를 따라 치는 것을 넘어, JSP와 서블릿이 웹 컨테이너 안에서 어떻게 상호작용하고 생명주기를 가지는지 이해하는 것은 웹 개발의 깊이를 더하는 데 정말 중요합니다.

이 모든 개념들이 처음에는 조금 복잡하게 느껴질 수 있지만, 직접 코드를 작성하고 실행해보면서 웹 페이지가 눈앞에 나타나는 경험을 하다 보면 어느새 친숙해질 거예요!

---
