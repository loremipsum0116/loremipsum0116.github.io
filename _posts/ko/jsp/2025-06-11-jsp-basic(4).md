알겠습니다. 기존의 딱딱하고 전문적인 톤을 유지하면서, 요청하신 대로 "-에요" 말투를 필요한 부분에 "살짝"만 추가하여 자연스럽게 어우러지도록 수정하겠습니다. `-답니다` 말투는 여전히 사용하지 않습니다.

---
title: "JSP - 용어 정리(3)"
date: 2025-06-11 17:21:55 +09:00
categories: [jsp]
lang: ko
locale: ko
words_per_minute: 30

---

---
## JSP 심층 분석 2부: 효율적인 에러 처리 및 실행 메커니즘 이해

지난 JSP 1부에서는 동적 웹 페이지의 개념, JSP의 등장 배경, 서블릿과의 관계, 그리고 기본적인 파일 구조에 대해 살펴보았습니다. 본 문서에서는 JSP 개발 시 필수적으로 고려해야 할 **에러 처리 기법**, **JSP 지시어**의 심층적인 활용법, 그리고 **JSP 파일이 브라우저에 렌더링되기까지의 실행 과정**을 심층적으로 분석하고자 합니다.

---

### 🚨 JSP 에러 처리: 사용자 경험 및 보안 강화를 위한 필수 요소

웹 페이지 사용 중 예상치 못한 복잡한 오류 메시지와 소스 코드가 노출되는 '500 Internal Server Error'와 같은 화면은 사용자에게 불쾌감을 줄 뿐만 아니라, 웹사이트의 신뢰도를 저하시키는 요인이 됩니다. 특히, 자바 코드의 일부가 노출되는 것은 **보안상 심각한 취약점을 야기할 수 있습니다.**

JSP 페이지에서 이러한 문제를 방지하기 위한 해결책은 크게 두 가지로 분류됩니다.

#### 1. `try-catch` 블록을 활용한 코드 내부 예외 처리

자바 개발자에게 익숙한 `try-catch` 블록은 예외 발생 가능성이 있는 코드를 `try` 블록 내에 배치하고, 예외 발생 시 `catch` 블록에 정의된 예외 처리 로직을 실행하는 자바의 기본적인 예외 처리 메커니즘입니다. 이 방식은 JSP 스크립트릿 내부에서도 동일하게 적용 가능합니다.

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>try-catch를 통한 에러 처리</title>
</head>
<body>
<%
    // 'age' 파라미터가 누락되거나 숫자가 아닌 값이 전달될 경우를 가정합니다.
    // Integer.parseInt() 메서드는 이러한 경우 'NumberFormatException'을 발생시킬 수 있습니다.
    try {
        int myAge = Integer.parseInt(request.getParameter("age")) + 10;
        out.println("<h3>10년 후 당신의 나이는: " + myAge + "세 입니다.</h3>");
    } catch (NumberFormatException e) { // 숫자가 아닌 값 수신 시 발생하는 예외
        // 사용자에게 제공할 안내 메시지를 출력합니다.
        out.println("<h3>죄송합니다! 나이는 숫자로 입력해야 해요. 😅</h3>");
        // 개발자 디버깅을 위해 콘솔에 스택 트레이스를 출력할 수 있습니다.
        // e.printStackTrace(); 
    } catch (Exception e) { // 그 외 모든 예외 처리
        out.println("<h3>알 수 없는 오류가 발생했습니다! 다시 시도해 주십시오.</h3>");
    }
%>
</body>
</html>
```

**코드 분석:**
* `try` 블록 내에 `Integer.parseInt()`와 같이 예외 발생 가능성이 있는 코드를 포함합니다.
* `NumberFormatException`과 같은 특정 예외가 발생하면 첫 번째 `catch` 블록에서 해당 예외를 처리하고 사용자 친화적인 메시지를 출력합니다.
* 예상치 못한 다른 종류의 예외는 `Exception` 타입의 두 번째 `catch` 블록에서 처리하도록 구성되었습니다.

**장점**: 해당 페이지 내에서 에러를 즉각적으로 처리하고, 필요한 경우 복구 로직을 수행할 수 있습니다.
**단점**: 모든 예외 발생 가능 코드에 `try-catch`를 개별적으로 적용하는 것은 코드의 가독성을 저하시키고 복잡성을 증가시킬 수 있습니다.

#### 2. `errorPage`, `isErrorPage` 속성을 활용한 전역적인 에러 페이지 처리

이 방법은 예외 발생 시 요청을 특정 에러 페이지로 전달하여, 사용자에게 일관되고 전문적인 에러 화면을 제공하는 방식입니다. 실제 서비스 환경에서 광범위하게 활용됩니다.

먼저, 에러 정보를 표시할 JSP 페이지를 생성합니다. 예를 들어 `errorPage.jsp`로 명명합니다.

**`errorPage.jsp` (에러 처리 전용 페이지)**

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" isErrorPage="true"%> <%-- 이 페이지는 에러 처리를 위한 전용 페이지입니다. --%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>오류 발생 😱</title>
<style>
    body { font-family: Arial, sans-serif; text-align: center; margin-top: 50px; }
    h2 { color: #e74c3c; }
    .error-details { background-color: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; padding: 20px; margin: 20px auto; width: 60%; border-radius: 8px; }
</style>
</head>
<body>
    <h2>서비스에 일시적인 오류가 발생했습니다.</h2>
    <p>불편을 드려 죄송합니다. 잠시 후 다시 시도해 주십시오.</p>

    <div class="error-details">
        <h3>오류 상세 정보 (개발자용)</h3>
        <p><strong>오류명:</strong> <%= exception.getClass().getName() %></p> <%-- 발생한 예외의 클래스명 --%>
        <p><strong>오류 메시지:</strong> <%= exception.getMessage() %></p> <%-- 발생한 예외의 상세 메시지 --%>
    </div>
    <p><a href="/">메인 페이지로 돌아가기</a></p>
</body>
</html>
```

**핵심**: `isErrorPage="true"` 속성은 해당 JSP 페이지에서 `exception`이라는 특별한 내장 객체를 사용할 수 있도록 합니다. 이 `exception` 객체는 발생한 예외에 대한 모든 정보를 포함하고 있어요.

이제, 예외가 발생할 수 있는 일반 JSP 페이지에 `errorPage.jsp`를 연결합니다.

**`mainPage.jsp` (예외 발생 가능 페이지)**

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" errorPage="errorPage.jsp"%> <%-- 예외 발생 시 errorPage.jsp로 이동합니다. --%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>나이 입력 페이지</title>
</head>
<body>
    <h1>귀하의 나이를 입력해 주십시오!</h1>
    <form action="mainPage.jsp" method="get">
        나이: <input type="text" name="age">
        <input type="submit" value="제출">
    </form>
<%
    // 'age' 파라미터가 누락되거나 숫자가 아닌 값이 전달될 경우 NumberFormatException이 발생합니다.
    // 이 경우 자동으로 위에 지정된 errorPage.jsp로 이동됩니다.
    if (request.getParameter("age") != null && !request.getParameter("age").isEmpty()) {
        int age = Integer.parseInt(request.getParameter("age"));
        out.println("<p>입력하신 나이는: " + age + "세 입니다.</p>");
    } else {
        out.println("<p>나이를 입력해 주십시오.</p>");
    }
%>
</body>
</html>
```

**이 방식의 처리 흐름은 다음과 같습니다:**
1.  `mainPage.jsp`에서 `age` 파라미터와 관련된 예외(예: 사용자가 'abc' 입력)가 발생합니다.
2.  `mainPage.jsp`의 `errorPage="errorPage.jsp"` 속성에 의해 JSP 엔진이 자동으로 요청을 `errorPage.jsp`로 포워딩합니다.
3.  `errorPage.jsp`는 `isErrorPage="true"`로 설정되어 있으므로, `exception` 내장 객체를 통해 발생한 예외 정보를 수신하고 이를 사용자에게 표시할 수 있어요.

**장점**: 사용자에게는 보다 전문적이고 일관된 에러 화면을 제공하며, 개발자는 에러 처리 로직을 별도의 페이지로 분리하여 코드 관리가 용이해집니다. 이는 웹사이트의 신뢰도를 향상시키는 데 기여합니다.

---

### `page` 지시어: JSP 페이지의 메타데이터 정의

`page` 지시어는 JSP 페이지의 '성격'을 정의하는 핵심적인 역할을 수행합니다. 이전에 다룬 `language`, `contentType`, `pageEncoding`, `import`, `errorPage`, `isErrorPage` 외에도 다음과 같은 유용한 속성들이 존재합니다.

#### 1. `trimDirectiveWhitespaces="true"`: HTML 소스 코드의 공백 관리

JSP 코드 작성 시 `<%@ ... %>`와 같은 지시어는 최종 렌더링되는 HTML 소스 코드에 불필요한 빈 줄이나 공백을 생성할 수 있습니다. 이러한 불필요한 공백을 자동으로 제거해주는 속성이 바로 `trimDirectiveWhitespaces`입니다.

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" trimDirectiveWhitespaces="true"%> <%-- 불필요한 공백 제거를 요청합니다. --%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>공백 없는 JSP</title>
</head>
<body>
    <p>안녕하세요. 본 페이지는 공백 없이 깔끔하게 처리된 JSP 페이지입니다.</p>
</body>
</html>
```

**설명**:
`trimDirectiveWhitespaces="true"`를 설정하면, JSP 엔진이 이 페이지를 서블릿 코드로 변환할 때 지시어들이 남기는 불필요한 공백을 효과적으로 제거합니다. 웹 브라우저에서 '페이지 소스 보기' 기능을 활용하여 지시어 때문에 발생했던 빈 줄들이 사라진 것을 확인할 수 있을 거예요.

**목적**: 생성되는 HTML 소스 코드의 가독성을 향상시키고, 미미하게나마 파일 크기를 줄여 네트워크 전송 효율을 개선할 수 있습니다.

#### 2. `include` 지시어: 공통 코드 재활용의 효율성 증대

웹 페이지 개발 시 헤더, 푸터, 내비게이션 바와 같이 여러 페이지에 **반복적으로 사용되는 공통 컴포넌트**가 다수 존재합니다. 이러한 공통 코드를 매번 모든 페이지에 복사-붙여넣기 하는 것은 비효율적이며, 향후 수정이 필요할 경우 모든 관련 파일을 수동으로 업데이트해야 하는 번거로움을 초래합니다. 이때 `include` 지시어의 활용이 매우 효과적입니다.

```jsp
<%-- includeFile.jsp (포함될 파일) --%>
<%@ page import="java.time.LocalDate, java.time.LocalDateTime" %> <%-- 필요한 클래스를 임포트합니다. --%>
<%
    // 스크립트릿: 현재 날짜와 내일 날짜를 계산합니다.
    LocalDate today = LocalDate.now();
    LocalDate tomorrow = LocalDate.now().plusDays(1);
%>
<header>
    <h1>우리 웹사이트</h1>
    <nav>
        <a href="/">홈</a> | <a href="/about">소개</a> | <a href="/contact">문의</a>
    </nav>
</header>
```

```jsp
<%-- includeMain.jsp (포함시키는 파일) --%>
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ include file="includeFile.jsp" %> <%-- includeFile.jsp의 내용을 여기에 포함시킵니다. --%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>include 지시어 활용</title>
</head>
<body>
    <%-- includeFile.jsp에 포함된 header 내용이 여기에 출력됩니다. --%>
    <p>오늘 날짜: <%= today %></p>
    <p>내일 날짜: <%= tomorrow %></p>
    <footer>
        <p>&copy; 2024 내 웹사이트. 모든 권리 보유.</p>
    </footer>
</body>
</html>
```

**동작 방식**:
`<%@ include file="includeFile.jsp" %>` 지시어는 JSP 파일이 **컴파일되는 시점**에 `includeFile.jsp`의 내용을 `includeMain.jsp` 내부로 **정적으로 병합합니다.** 따라서 `includeMain.jsp`에서는 `includeFile.jsp`에서 선언된 `today`, `tomorrow` 변수나 `<header>` 태그를 마치 자가 소유의 코드인 것처럼 활용할 수 있습니다.

**장점**: 코드의 재사용성을 극대화하고, 유지보수 효율성을 크게 향상시킵니다. 공통 컴포넌트를 단일 지점에서 관리할 수 있게 됩니다.

#### 3. `taglib` 지시어: 고급 기능의 태그 기반 구현

JSP는 HTML 내부에 자바 코드를 직접 삽입하는 스크립트릿 방식 외에도, HTML 태그와 유사한 형태의 **커스텀 태그**를 사용하여 보다 간결하고 강력한 기능을 구현할 수 있도록 지원합니다. 이때 필요한 것이 바로 `taglib` 지시어입니다.

```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> <%-- JSTL Core 라이브러리를 선언합니다. --%>
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %> <%-- JSTL Format 라이브러리를 선언합니다. --%>
```

**설명**:
* `prefix="c"`: 해당 라이브러리에 속한 태그들을 사용할 때 `<c:if>`, `<c:forEach>`와 같이 `c:`라는 접두사를 사용하겠다는 의미입니다.
* `uri="http://java.sun.com/jsp/jstl/core"`: 이 접두사에 해당하는 태그 라이브러리가 정의된 '주소(URI)'를 명시합니다.

이 지시어를 통해 **JSTL(JSP Standard Tag Library)**과 같은 표준 태그 라이브러리를 JSP 페이지에서 활용할 수 있게 됩니다. JSTL은 반복문, 조건문, 숫자/날짜 형식 지정 등 자주 사용되는 기능을 미리 태그 형태로 구현해 놓은 것이므로, JSP 코드 내에서 자바 스크립트릿을 직접 사용하는 것보다 훨씬 깔끔하고 가독성 높은 코드를 작성하는 데 기여합니다.

---

### 스크립트 요소: HTML 내부에 통합된 자바 코드 블록

JSP의 핵심 문법으로서, HTML 문서 내부에 자바 코드를 직접 삽입하여 동적인 기능을 구현하게 해주는 영역을 **스크립트 요소**라고 합니다. 크게 세 가지 종류로 구성됩니다.

#### 1. 선언부 (`<%! ... %>`)

* **역할**: JSP 페이지 전체에서 공유 및 활용될 **멤버 변수(필드)** 또는 **메서드**를 정의하는 영역입니다.
* **특징**: JSP 파일이 서블릿으로 변환될 때, 이 코드 블록은 서블릿 클래스의 `_jspService()` 메서드 **바깥쪽**에 위치하게 됩니다. 따라서 이 변수나 메서드들은 해당 서블릿 클래스의 모든 메서드에서 접근 가능한 '전역' 요소로 동작합니다.
* **비유**: 클래스의 설계도에 명시된 '공통 자원' 또는 '공통 기능'과 유사합니다.

```jsp
<%! 
    // 멤버 변수: 페이지 방문 횟수를 저장합니다 (모든 요청에서 공유됩니다).
    private int visitCount = 0; 

    // 멤버 메서드: 두 숫자를 더하는 기능을 제공합니다 (어디서든 호출 가능합니다).
    public int calculateSum(int num1, int num2) {
        return num1 + num2;
    }
%>
```

#### 2. 스크립트릿 (`<% ... %>`)

* **역할**: 클라이언트의 **요청이 발생할 때마다 실행되어야 할 자바 코드 로직**을 작성하는 영역입니다. 대부분의 자바 코드가 이 영역에 작성됩니다.
* **특징**: 서블릿으로 변환될 때 `_jspService()` 메서드 **안쪽**에 직접 포함됩니다. 따라서 이곳에 선언된 변수는 해당 스크립트릿 내부에서만 유효한 **지역 변수**로 간주됩니다.
* **제약**: 자바의 메서드 내부에 또 다른 메서드를 선언할 수 없는 것과 마찬가지로, 스크립트릿 내부에서는 새로운 메서드를 선언할 수 없습니다. 그러나 선언부에서 정의된 메서드는 호출하여 사용할 수 있습니다.
* **비유**: 요청 처리 시 '특정 작업을 수행하고 계산하라!'는 지시를 내리는 '작업 로직'과 같습니다.

```jsp
<% 
    // 지역 변수: 이 스크립트릿 내에서만 유효합니다.
    String userName = request.getParameter("name"); 
    
    // 방문 횟수를 증가시킵니다 (선언부의 멤버 변수를 사용).
    visitCount++; 

    // 선언부의 메서드를 호출하고 결과를 출력합니다.
    int sum = calculateSum(5, 7);
    out.println("<p>" + userName + "님, 안녕하세요! 반갑습니다.</p>");
    out.println("<p>두 숫자의 합: " + sum + "</p>");
%>
```

#### 3. 표현식 (`<%= ... %>`)

* **역할**: 실행 결과로 **하나의 값** (변수, 수식, 상수, 반환 값이 있는 메서드 호출 결과 등)을 **웹 브라우저 화면에 직접 출력**하고자 할 때 사용됩니다.
* **특징**: Java의 `System.out.println()` 또는 `out.print()`와 동일한 출력을 생성합니다. 값을 '표현(expression)'하는 매우 간결한 방법입니다.
* **비유**: 계산된 결과값을 '즉시' 화면에 표시하는 작은 출력 장치와 같습니다.

```jsp
<body>
    <%-- 스크립트릿에서 계산된 값이나 선언부의 변수를 직접 출력합니다. --%>
    <p>현재 방문 횟수: <%= visitCount %></p>
    <p>간단한 계산: <%= 10 * 5 %></p>
    <p>메서드 결과: <%= calculateSum(100, 200) %></p>
</body>
```

**스크립트 요소 활용 예시 (종합)**

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>JSP 스크립트 요소 총집합</title>
</head>
<body>
    <%! // <%! ... %> 선언부: 멤버 변수와 메서드 선언
        private int totalAccess = 0; // 이 JSP 페이지의 총 접근 횟수 (멤버 변수)

        public String getWebsiteName() { // 웹사이트 이름 반환 메서드 (멤버 메서드)
            return "내 멋진 웹사이트";
        }
    %>

    <% // <% ... %> 스크립트릿: 요청마다 실행되는 로직
        totalAccess++; // 페이지 접근 시마다 totalAccess를 1 증가시킵니다.
        String userName = "방문객";
        // 파라미터가 있다면 사용자 이름으로 설정합니다.
        if (request.getParameter("name") != null && !request.getParameter("name").isEmpty()) {
            userName = request.getParameter("name");
        }
    %>

    <h1><%= getWebsiteName() %>에 오신 것을 환영합니다!</h1> <%-- <%= ... %> 표현식: 메서드 결과 출력 --%>
    <p><%= userName %>님, 안녕하세요!</p> <%-- 표현식: 변수 값 출력 --%>
    <p>이 페이지는 지금까지 <%= totalAccess %>번 방문되었습니다.</p> <%-- 표현식: 멤버 변수 출력 --%>
    <p>오늘의 행운의 숫자: <%= Math.random() * 100 %></p> <%-- 표현식: 수식 결과 출력 --%>

    <% // 스크립트릿: 조건문 예시
        if (totalAccess < 5) {
    %>
        <p>아직 새로운 방문객이 많아요!</p>
    <%
        } else {
    %>
        <p>꾸준히 찾아주셔서 감사합니다!</p>
    <%
        }
    %>
</body>
</html>
```

**출력 결과 (예시):**
처음 접속 시:
```
내 멋진 웹사이트에 오신 것을 환영합니다!
방문객님, 안녕하세요!
이 페이지는 지금까지 1번 방문되었습니다.
오늘의 행운의 숫자: 72.123456...
아직 새로운 방문객이 많아요!
```
두 번째 접속 시:
```
내 멋진 웹사이트에 오신 것을 환영합니다!
방문객님, 안녕하세요!
이 페이지는 지금까지 2번 방문되었습니다.
오늘의 행운의 숫자: 34.56789...
아직 새로운 방문객이 많아요!
```
(그리고 `http://localhost:8080/your_app/example.jsp?name=윤효재` 로 접속 시)
```
내 멋진 웹사이트에 오신 것을 환영합니다!
윤효재님, 안녕하세요!
이 페이지는 지금까지 3번 방문되었습니다.
오늘의 행운의 숫자: 12.34567...
아직 새로운 방문객이 많아요!
```

---

### 🔄 JSP 실행 과정: 브라우저 렌더링 메커니즘 분석

우리가 생성한 `.jsp` 파일은 그 자체로 직접 실행되지 않습니다. 웹 컨테이너(WAS, 예를 들면 Tomcat)의 처리 과정을 거쳐야만 최종적으로 웹 브라우저에서 볼 수 있는 HTML 페이지로 변환됩니다.

#### 🪄 JSP의 변환 과정: 요청부터 응답까지

1.  **클라이언트의 요청**: 사용자가 웹 브라우저에 `http://localhost:8080/myWebApp/twoDice.jsp`와 같은 URL을 입력하고 요청을 보냅니다. (`twoDice.jsp`는 예시 JSP 파일입니다.)

2.  **웹 컨테이너의 확인**: 이 요청은 웹 컨테이너(WAS)로 전달됩니다. 웹 컨테이너는 해당 JSP 파일에 대한 서블릿 인스턴스(객체)가 이미 메모리에 로드되어 있는지 확인합니다. 이 정보는 **서블릿 컨텍스트(Servlet Context)**에 저장되어 관리됩니다. (서블릿 컨텍스트는 웹 애플리케이션 전반에 걸쳐 공유되는 정보 및 등록된 서블릿 객체 목록 등을 관리하는 공간입니다.)

3.  **최초 요청 또는 변경 사항 발생 시 (변환 시작)**:
    * 만약 `twoDice.jsp`가 **최초로 요청되거나**, JSP 파일이 **수정되어 최신 버전이 아닌 경우** 웹 컨테이너는 다음과 같은 변환 절차를 수행합니다.
    * **JSP를 서블릿 코드로 변환**: 먼저, `.jsp` 파일을 자바 서블릿 코드(`.java` 파일)로 변환합니다. 예를 들어 `twoDice_jsp.java`와 같은 파일이 생성됩니다. 이 과정에서 JSP의 지시어, 스크립트 요소 등이 실제 서블릿 코드로 변환돼요.
    * **서블릿 코드 컴파일**: 변환된 `.java` 파일을 자바 컴파일러가 컴파일하여 실행 가능한 **서블릿 클래스 파일(`.class`)**을 생성합니다. (예: `twoDice_jsp.class`)
    * **서블릿 인스턴스 생성**: 생성된 `.class` 파일을 JVM(Java Virtual Machine)이 로딩하여 메모리에 **서블릿 인스턴스(객체)**를 생성합니다.
    * **초기화 (`jspInit()` 호출)**: 서블릿 인스턴스가 생성되면, 웹 컨테이너는 이 인스턴스의 `jspInit()` 메서드를 **단 한 번** 호출하여 초기화 작업을 수행합니다. (이 `jspInit()` 메서드는 서블릿의 `init()` 메서드와 동일한 역할을 합니다.)

4.  **재요청 시 (즉시 실행)**:
    * 이후 동일한 `twoDice.jsp`에 대한 요청이 들어오면, 웹 컨테이너는 이미 메모리에 서블릿 인스턴스가 존재함을 확인하고 3번의 복잡한 변환 및 컴파일 과정을 생략합니다.

5.  **핵심 기능 실행 (`_jspService()` 호출)**:
    * 이제 메모리에 준비된 서블릿 인스턴스의 `_jspService()` 메서드가 호출됩니다. (이 `_jspService()` 메서드는 서블릿의 `service()` 메서드와 동일한 역할을 합니다.)
    * 이 `_jspService()` 메서드 내에서 실제 JSP 페이지의 스크립트릿과 표현식에 작성된 자바 코드가 실행되고, 그 결과로 동적인 내용이 포함된 **HTML 코드가 생성됩니다.**

6.  **클라이언트에게 응답**: `_jspService()` 메서드가 생성한 최종 HTML 결과가 클라이언트(웹 브라우저)로 전송되어 사용자에게 보이는 웹 페이지로 나타나는 거죠!

#### 🕰️ 서블릿의 생명주기: `init()`, `service()`, `destroy()`

JSP 실행 과정에서 언급된 `init()`, `service()`, `destroy()` 메서드들은 모든 서블릿(JSP에서 변환된 서블릿 포함)이 웹 컨테이너에 의해 관리되는 중요한 '생명주기' 메서드들입니다.

* **`init()` (초기화 단계)**:
    * **역할**: 서블릿 객체가 웹 컨테이너에 의해 **최초로 생성될 때** (또는 웹 컨테이너 시작 시) **단 한 번만** 호출되는 메서드입니다.
    * **특징**: 데이터베이스 연결 풀 초기화, 설정 파일 로딩 등 서블릿이 동작하는 데 필요한 무거운 자원들을 한 번만 미리 준비하는 데 사용됩니다. 이를 통해 매 요청마다 반복적으로 자원을 로딩하는 비효율성을 방지합니다.

* **`service()` (요청 처리 단계)**:
    * **역할**: 클라이언트로부터 **요청이 들어올 때마다 반복적으로 호출**되는 메서드입니다. 실제 클라이언트의 요청을 받아 비즈니스 로직을 처리하고 응답을 생성하는 핵심 역할을 담당합니다.
    * **특징**: HTTP 메서드(GET, POST 등)에 따라 내부적으로 `doGet()`, `doPost()` 등의 메서드를 호출하여 적절하게 요청을 처리합니다.

* **`destroy()` (소멸 단계)**:
    * **역할**: 서블릿이 메모리에서 제거될 때 (예: 웹 컨테이너 종료, 서블릿 파일 변경으로 인한 재배포 등) **단 한 번만** 호출되는 메서드입니다.
    * **특징**: `init()`에서 할당했던 자원들을 해제(DB 연결 종료, 파일 닫기 등)하여 메모리 누수를 방지하고 깔끔하게 마무리하는 역할을 수행합니다.

---

### 📝 결론

본 문서에서는 JSP의 에러 처리 방안, `page` 지시어의 추가적인 활용법, 스크립트 요소의 세부적인 기능, 그리고 JSP 파일이 최종적으로 웹 페이지로 변환되어 실행되는 과정과 서블릿의 생명주기를 상세히 살펴보았습니다. 단순히 코드를 작성하는 것을 넘어, JSP와 서블릿이 웹 컨테이너 내에서 어떻게 상호작용하고 관리되는지를 이해하는 것은 웹 개발 역량 심화에 있어 매우 중요합니다.

이 모든 개념들이 처음에는 다소 복잡하게 느껴질 수 있으나, 직접 코드를 작성하고 실행하며 웹 페이지의 동작을 관찰하는 경험을 통해 점차 익숙해질 것입니다.

---