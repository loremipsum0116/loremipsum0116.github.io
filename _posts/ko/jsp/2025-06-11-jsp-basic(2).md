---
title: "JSP - 용어 정리(1)"
date: 2025-06-11 16:48:25 +09:00
categories: [jsp]
lang: ko
locale: ko
words_per_minute: 30
---

---
## 📘 JSP 완전 정복 0탄: 웹 개발, 아는 만큼 보인다! (기본 용어 총정리)
처음 개발을 시작할 때 가장 어려운 것 중 하나가 바로 '용어'의 벽이죠. 특히 웹 기반 애플리케이션을 만들려면 알아야 할 개념들이 정말 많아요. 그래서 오늘은 웹 개발의 첫 단추를 잘 꿰맬 수 있도록, 프로그램이 어떻게 발전해왔는지부터 시작해서 **HTTP**, **클라이언트/서버**, **웹 서버와 WAS의 차이**, 그리고 **웹 컨테이너**와 **서블릿**까지, 중요한 용어들을 쉽고 자세하게 풀어드릴게요.

---

### 💡 프로그램 발전사: 내 PC 속 계산기에서 전 세계 웹 서비스까지!
소프트웨어는 끊임없이 진화해 왔어요. 사용자들이 더 편하게, 더 안전하게 서비스를 이용할 수 있도록 말이죠. 그 발전의 핵심에는 '데이터를 어떻게 처리하고 사용자에게 전달할 것인가?'라는 고민이 담겨 있습니다.

#### 1. 클라이언트 PC 기반 프로그램 (옛날 옛적에...)
가장 초기에는 우리가 쓰는 컴퓨터(클라이언트 PC)에 프로그램을 직접 설치해서 사용했어요. 예를 들어, 자바로 만든 '시간 계산기' 앱을 내 컴퓨터에 설치하고 실행하는 방식이죠.

* **클라이언트**: 내 컴퓨터에서 직접 돌아가며, 숫자 입력받고 계산하고 결과를 화면에 보여주는 모든 걸 다 했어요.

* **문제점**:
    * **업데이트가 지옥**: 만약 계산기 기능이 바뀌거나 버그가 생기면, 전 세계 사용자들 컴퓨터마다 일일이 찾아다니면서 프로그램을 업데이트하거나 새로 설치해줘야 했죠. 생각만 해도 아찔합니다.
    * **보안이 허술해**: 만약 이 계산기 프로그램에 아주 중요한 정보(예: 데이터베이스 접속 비밀번호)가 들어있다면, 내 컴퓨터가 해킹당했을 때 그 정보가 고스란히 노출될 수 있었어요. 보안에 너무 취약했죠.
이런 불편함과 위험성 때문에 등장한 게 바로 **클라이언트-서버 기반 프로그램**입니다.

---

#### 2. 클라이언트-서버 기반 프로그램 (역할 분담의 시작!)
클라이언트 PC 기반 프로그램의 단점을 해결하기 위해, 프로그램의 핵심 기능과 데이터 처리를 전담하는 서버라는 개념이 도입되었어요. 마치 회사에서 업무를 분담하는 것처럼요.

* **클라이언트**: 이제 내 컴퓨터는 단순해졌어요. 데이터를 서버로 '보내주고', 서버가 처리한 결과를 '받아서' 화면에 보여주는 역할만 하게 됩니다. 즉, '화면'만 담당하는 거죠.

* **서버**: 반대로 서버는 정말 바빠졌어요. 클라이언트로부터 데이터를 받아서 실질적인 계산이나 복잡한 비즈니스 로직을 모두 수행하고, 그 결과를 클라이언트에게 다시 돌려주는 역할을 합니다. '핵심 기능'을 담당하는 셈이죠.

* **어떻게 돌아가나?**:
    * 클라이언트가 뭔가 처리할 데이터가 생기면, **네트워크(인터넷)**를 통해 서버에 보내요.
    * 서버는 그걸 받아서 열심히 계산하고 처리한 다음, 처리된 결과를 다시 네트워크를 통해 클라이언트에 보내주죠. 그럼 클라이언트는 그걸 받아서 화면에 예쁘게 보여주는 거예요.
* **장점**:
    * **유지보수가 너무 쉬워져요**: 기능(로직)이 변경돼도 서버만 업데이트하면 되니, 사용자 컴퓨터에 설치된 클라이언트 프로그램을 일일이 바꿀 필요가 없어요. 관리하는 입장에서는 정말 혁신적이었습니다.
    * **보안도 훨씬 튼튼**: 중요한 데이터나 핵심 로직은 서버에만 있으니, 클라이언트 컴퓨터가 해킹당해도 보안 위험이 크게 줄어들어요.
* **단점**: 그래도 화면 디자인이나 구조가 바뀌면 여전히 클라이언트 프로그램을 수정해야 한다는 아쉬움이 조금 남았습니다.

---

#### 3. 웹 기반 프로그램 (지금 우리가 쓰는 인터넷!)
클라이언트-서버 모델에서 한 단계 더 발전해서, 오늘날 우리가 매일 사용하는 바로 그 형태가 탄생했습니다. 바로 웹 브라우저를 클라이언트로 활용하는 방식이죠!

* **클라이언트**: 이제 우리는 어떤 프로그램을 따로 설치할 필요가 없어요! 그냥 컴퓨터에 기본으로 깔려 있는 **웹 브라우저(크롬, 엣지, 사파리 등)**를 켜고, 원하는 웹사이트 주소만 입력하면 돼요. 브라우저가 알아서 서버에 필요한 HTML 문서를 요청하고 받아와서 보여주는 거죠.

* **서버**: 클라이언트(브라우저)가 요청한 HTML 문서를 브라우저에 전송해서 화면을 출력하는 역할을 해요. 사용자가 화면에서 뭔가를 입력하고 '확인'을 누르면, 서버는 그 데이터를 받아서 처리하고, 계산된 결과를 다시 웹 브라우저로 전송하여 보여주는 식입니다.

* **동작 방식**:
    * 여러분이 주소창에 `www.naver.com` 같은 URL을 입력합니다.
    * 웹 브라우저는 네이버 서버에 'HTML 문서 주세요!' 하고 요청을 보내죠.
    * 네이버 서버는 요청받은 HTML 문서를 브라우저에 보내주고, 브라우저는 그걸 받아서 멋진 네이버 화면을 우리에게 보여주는 거예요.
    * 만약 검색창에 뭘 입력하고 검색 버튼을 누르면, 그 데이터가 다시 서버로 전송되어 처리되고, 검색 결과가 담긴 새로운 HTML이 브라우저로 돌아와서 화면이 바뀌는 식이죠.

    ![웹 기반 프로그램 이미지](/assets/images/jsp/web-based-program.webp)

* **장점**:
    * **최고의 유지보수성**: 사용자가 사용하는 프로그램의 기능이나 화면이 바뀌더라도, 대부분의 처리가 서버에서 이루어지기 때문에 클라이언트(웹 브라우저)는 업데이트할 필요가 없습니다.
    * **높은 접근성**: 웹 브라우저만 있으면 어디서든 서비스에 접근할 수 있습니다.
    * **우수한 보안**: 중요한 데이터와 로직은 여전히 서버에서 안전하게 관리됩니다.

---

### 💡 HTTP: 웹에서 서로 말하는 법 (통신 규칙)
웹 기반 프로그램의 핵심 중 하나가 바로 **HTTP(HyperText Transfer Protocol)**예요. 이 길고 복잡해 보이는 이름은 사실 웹에서 정보를 주고받을 때 필요한 **가장 기본적인 '통신 규칙'**을 의미합니다. 웹 서핑을 할 때 HTML 문서나 이미지 같은 리소스들을 가져오려면 이 HTTP 규칙을 따라야 해요.

![HTTP 통신 이미지](/assets/images/jsp/http.webp)

#### HTTP의 특징:
* **엄청 간단해**: HTTP 메시지 구조가 사람도 읽을 수 있을 만큼 단순하게 설계되어 있어요. 덕분에 웹 개발이 더욱 빠르게 발전할 수 있었죠.
* **확장도 자유로워**: 웹은 계속 진화하잖아요? HTTP도 언제든지 새로운 기능을 추가하고 발전시킬 수 있도록 유연하게 만들어졌습니다.
* **상태는 없지만 세션은 있다**:
    * **상태 없음 (Stateless)**: HTTP의 가장 중요한 특징 중 하나예요. 기본적으로 HTTP는 **이전에 주고받은 요청/응답에 대한 '상태'를 전혀 기억하지 않아요.** 즉, 클라이언트가 서버에 요청을 두 번 보냈다고 해도, 서버는 이 두 요청이 같은 클라이언트에서 온 건지, 이전에 무슨 일이 있었는지 전혀 모릅니다. 각 요청은 완전히 독립적인 '새로운' 요청으로 간주됩니다.
    * **세션 (Session)**: 하지만 실제 웹 서비스에서는 사용자의 로그인 상태나 장바구니 정보처럼 **'상태'를 유지**해야 할 필요가 있습니다. HTTP가 '무상태'라 기억을 못 하니, 이를 보완하기 위해 **쿠키(Cookie)**나 **세션(Session)** 같은 기술이 도입되었어요. 얘네들이 바로 HTTP의 망각증을 치료해주는 비서 같은 역할을 하는 거죠.

---

### 💡 클라이언트와 서버: 웹 서비스의 양대 축

웹 기반 프로그램에서 클라이언트와 서버는 서로 상호작용하며 서비스를 제공합니다.

#### **클라이언트 (≈ 브라우저)**
* 클라이언트(주로 웹 브라우저)는 항상 **'요청(Request)'**을 보내는 주체입니다.
* 웹 페이지를 표시하기 위해, 브라우저는 먼저 페이지의 **HTML 문서**를 가져오기 위한 요청을 서버에 보냅니다.
* HTML 문서를 받은 브라우저는 그걸 해석해서 그림, 글자, 동영상 같은 걸 화면에 예쁘게 배치하고 보여주죠. 이때 필요한 이미지, CSS(스타일 정보), JavaScript(동적인 기능) 같은 하위 리소스들도 서버에 추가로 '요청'해서 가져옵니다. 이 모든 걸 합쳐서 하나의 완성된 웹 페이지를 우리에게 보여주는 거예요.

#### **서버**
* 서버는 클라이언트(브라우저)로부터의 요청에 대한 **'응답(Response)'**으로 메시지를 전송하는 개체입니다.
* 클라이언트가 '이 데이터 좀 처리해주세요' 하면 서버는 그걸 받아서 필요한 작업을 한 다음, 처리된 결과물을 다시 클라이언트에게 돌려주는 거죠.

#### **HTTP 메시지 구성 (요청/응답 공통)**
클라이언트와 서버가 주고받는 HTTP 메시지는 크게 두 부분으로 나뉘어요. 편지에 비유하자면 이렇습니다.

* **헤더 (Headers)**: 편지 봉투에 적힌 정보 (보내는 사람, 받는 사람 주소, 편지 종류, 내용물 특징 등). 실제 데이터 내용은 아니지만, 통신에 필요한 **추가 정보**를 담고 있어요. (예: 메시지의 종류, 인코딩 방식, 쿠키 정보 등)
* **바디 (Body)**: 편지 내용물 그 자체! 실제로 주고받을 **핵심 데이터**가 이 안에 들어있습니다.

---

#### 📩 요청 (Request) 메시지: 클라이언트가 서버에게 보내는 편지
클라이언트가 서버에 보낼 때는 이런 정보들을 담아서 보냅니다.

* **HTTP 메서드**: **`GET`** (정보를 요청할 때), **`POST`** (정보를 제출할 때)와 같이 요청의 '목적'을 나타내는 방식이에요.
* **PATH**: 가져오려는 리소스의 경로 (예: `/users`, `/products/123`).
* **Headers**: 서버에 대한 추가 정보를 전달하는 헤더.
* **바디**: `POST` 방식으로 서버에 사용자 입력값처럼 추가적인 데이터를 보낼 때, 이 바디 부분에 실제 데이터가 담겨요. 헤더와 바디 사이에는 항상 빈 줄(`\r\n`)이 하나 들어갑니다.

![요청 메시지 이미지](/assets/images/jsp/asking.webp)

---

#### 📬 응답 (Response) 메시지: 서버가 클라이언트에게 보내는 답장
서버가 클라이언트 요청을 처리하고 보내는 답장에는 이런 정보들이 담겨 있어요.

* **Status Code (상태 코드)**: 세 자리 숫자로 이루어진 코드인데, '클라이언트 요청이 성공했는지', '무슨 문제가 있었는지'를 알려주는 **결과 보고서** 같은 거예요.
    * **`2xx` (성공)**: 요청이 성공적으로 처리되었습니다.
        * **`200 OK`**: 가장 흔한 성공 코드. '완벽하게 성공!'
    * **`3xx` (리다이렉션)**: 요청을 완료하기 위해 추가적인 조치가 필요합니다. (예: 다른 URL로 이동)
    * **`4xx` (클라이언트 오류)**: 클라이언트의 요청에 문제가 있습니다.
        * **`404 Not Found`**: 요청한 리소스(경로)를 서버에서 찾을 수 없습니다. (경로상의 문제)
        * **`405 Method Not Allowed`**: 요청에 사용된 HTTP 메서드를 리소스가 허용하지 않습니다. (요청 방식의 문제)
    * **`5xx` (서버 오류)**: 서버가 요청을 수행하지 못했습니다.
        * **`500 Internal Server Error`**: 서버 내부에서 오류가 발생했습니다. (일반적으로 코드상의 문제)

![응답 메시지 이미지](/assets/images/jsp/response.webp)

**렌더링**: HTML, CSS, 자바스크립트 등 개발자가 작성한 문서가 웹 브라우저에서 최종적으로 사용자에게 보여지는 형태로 변환되어 출력되는 과정을 의미합니다. (예: 티스토리 블로그 홈페이지에 대한 요청과 응답을 통해 브라우저가 화면을 렌더링)

![티스토리 블로그 렌더링 이미지](/assets/images/jsp/Tstory.webp)

---

### 🏡 Web Server vs WAS: 누가 정적이고, 누가 동적일까?
웹 서비스를 제공하는 서버는 크게 두 가지 종류로 나눌 수 있어요. 이 둘의 역할이 달라서 같이 사용하는 경우가 많습니다.

#### **Web Server**
* **Web**: 인터넷 기반 서비스 (URL(주소), HTTP(통신 규칙), HTML(내용)으로 구성)
* **Server**: 클라이언트에게 네트워크를 통해 정보나 시스템을 제공하는 컴퓨터 시스템
* **Web Server**: 인터넷을 기반으로 클라이언트에게 웹 서비스를 제공하는 컴퓨터 또는 해당 소프트웨어를 말해요.
* **주요 역할**: 요청이 있을 때 **정적인 웹 페이지** (HTML, CSS, JavaScript 파일, 이미지, 동영상 파일 등)를 클라이언트에게 제공하는 소프트웨어입니다.
* **동작 방식**: 웹 브라우저에 URL을 입력하면 브라우저는 웹 서버에 요청을 보내고, 웹 서버는 요청된 파일을 찾아 브라우저에게 그대로 보냅니다.
* **예시**: Apache HTTP Server, Nginx

![웹 서버 이미지](/assets/images/jsp/web-based-program.webp)

---

#### **WAS (Web Application Server)**
* **Web Application**: 웹에서 실행하는 응용 프로그램 (데이터베이스 조회, 로직 처리 등 동적인 기능 수행)
* **WAS**: 웹 애플리케이션 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크입니다.
* **주요 역할**: 웹 애플리케이션을 실행시켜 필요한 기능을 수행하고 그 결과를 웹 서버에게 전달하거나, 직접 클라이언트에게 동적인 콘텐츠를 제공합니다. **PHP, JSP, ASP.NET**과 같이 동적으로 페이지를 생성해야 할 때 사용됩니다.
* **동작 방식**: 클라이언트의 요청을 받으면, 웹 애플리케이션을 실행하여 데이터를 처리하고, 데이터베이스에 접근하며, 비즈니스 로직을 수행하여 동적인 HTML 페이지를 생성한 후 이를 클라이언트(또는 웹 서버)에게 보냅니다.
* **Web Server와 WAS의 차이**: 가장 큰 차이는 **상황에 따라 변하는 정보를 제공할 수 있는지 여부**입니다.
    * **웹 서버**: 정적 콘텐츠 (항상 동일한 내용) 제공.
    * **WAS**: 동적 콘텐츠 (요청에 따라 내용이 달라지는) 제공.
* **예시**: Apache Tomcat (우리가 JSP를 공부할 때 사용할!), JBoss, WebLogic, WebSphere
실제 서비스에서는 보통 **'웹 서버 + WAS'**를 함께 사용해요. 웹 서버는 정적인 파일들을 빠르게 처리하고, WAS는 복잡한 동적 요청들을 담당하여 효율성을 높이는 전략이죠.

![WAS 이미지](/assets/images/jsp/WAS.webp)

---

### 📦 Web Container (Servlet Container) - 서블릿의 집사!
**웹 컨테이너(Web Container)**는 WAS 안에 있는 아주 중요한 구성 요소예요. 마치 WAS가 큰 호텔이라면, 웹 컨테이너는 서블릿(Servlet)이라는 손님들을 관리해주는 '집사' 또는 '매니저' 역할을 한다고 생각하면 돼요.

* **서블릿 생명주기 관리**: 자바 서블릿은 일반적인 자바 프로그램처럼 `main` 메서드를 가지고 있지 않으므로, 웹 컨테이너가 서블릿의 **생성부터 소멸까지의 과정(생명주기)**을 담당합니다.
* **요청/응답 처리의 다리 역할**: 사용자의 HTTP 요청이 들어오면, 웹 컨테이너는 이 요청을 분석하여 적절한 서블릿에 전달하고, 서블릿이 처리한 응답을 다시 클라이언트에게 전달하는 역할을 수행합니다.
* **URL 매핑 및 권한 관리**: 특정 URL 요청이 왔을 때 어떤 서블릿을 실행할지 매핑하며, 필요한 경우 접근 권한을 보장하는 역할도 합니다.
* **데이터베이스 접근 지원**: 서블릿이 데이터베이스에 접근하여 응답을 생성하는 과정 또한 웹 컨테이너의 관리 하에 이루어집니다.
* **예시**: Apache Tomcat (톰캣은 대표적인 WAS이자 웹 컨테이너입니다.)

![웹 컨테이너 이미지](/assets/images/jsp/Web-Container.webp)

---

### 👩‍💻 Servlet (서블릿) - 웹을 위한 자바 클래스!
자, 드디어 서블릿이 다시 등장했네요! **서블릿(Servlet)**은 HTML 같은 정적인 콘텐츠가 아니라, 사용자의 요청에 따라 동적으로 웹 페이지를 생성하고 데이터를 처리하기 위해 자바로 만든 클래스를 말해요.

* **역할**: 클라이언트의 요청을 받아 비즈니스 로직을 처리하고, 동적인 웹 페이지를 생성하여 클라이언트에게 응답하는 역할을 합니다.
* **생명주기(Lifecycle)**: 모든 서블릿은 웹 컨테이너에 의해 특별한 '생명주기'를 가집니다.
    1.  **`init()`**: 서블릿 객체가 웹 컨테이너에 의해 처음으로 생성될 때(또는 웹 컨테이너 시작 시) **단 한 번** 호출되어 초기화 작업을 수행합니다.
    2.  **`service()`**: 클라이언트로부터 요청이 들어올 때마다 **반복적으로 호출**되어 실제 비즈니스 로직을 처리하고 응답을 생성합니다. (내부적으로 `doGet()`, `doPost()` 등을 호출)
    3.  **`destroy()`**: 서블릿이 소멸될 때(예: 웹 컨테이너 종료 시) **단 한 번** 호출되어 자원을 해제하는 작업을 수행합니다.

### 🔚 마무리

지금까지 프로그램의 발전 과정부터 웹 통신의 기본이 되는 HTTP, 클라이언트/서버 개념, 그리고 웹 서버와 WAS의 차이, WAS의 핵심 구성요소인 웹 컨테이너와 서블릿에 대해 자세히 알아보았습니다. 이 용어들은 자바 기반의 웹 애플리케이션 개발, 특히 JSP/Servlet 기반의 개발을 이해하는 데 필수적인 기초 지식입니다.

이 개념들을 잘 이해하고 나면, 웹 서비스가 어떻게 동작하고 클라이언트와 서버가 어떻게 소통하는지 큰 그림을 그릴 수 있을 것입니다. 앞으로 배울 JSP와 같은 기술들이 이러한 기반 위에서 어떻게 작동하는지 이해하는 데 큰 도움이 될 거예요.

---
