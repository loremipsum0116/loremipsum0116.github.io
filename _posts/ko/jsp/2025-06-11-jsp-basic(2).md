---
title: "JSP - 용어 정리(1)"
date: 2025-06-11 16:48:25 +09:00
categories: [jsp]
lang: ko
locale: ko
words_per_minute: 30
---

---
## 📘 JSP 심화 분석 0부: 웹 개발의 기초 개념 정립
개발을 처음 시작할 때, 전문 용어의 이해는 중요한 과제 중 하나예요. 특히 웹 기반 애플리케이션을 개발할 때는 알아야 할 개념들이 정말 많습니다. 그래서 오늘은 소프트웨어의 발전 과정부터 **HTTP**, **클라이언트-서버 구조**, **웹 서버와 WAS의 차이점**, **웹 컨테이너**, 그리고 **서블릿**에 이르는 핵심 용어들을 상세히 설명해 드릴게요.

---

### 💡 프로그램 발전사: 개인 컴퓨팅 환경에서 글로벌 웹 서비스로의 전환
소프트웨어는 사용자 편의성 및 보안 강화를 목표로 지속적으로 진화해 왔어요. 이러한 발전의 중심에는 '데이터 처리 및 사용자 전달 방식'에 대한 심도 깊은 고찰이 있었다고 볼 수 있습니다.

#### 1. 클라이언트 PC 기반 프로그램 (초기 모델)
초기 소프트웨어는 사용자 개인 컴퓨터(클라이언트 PC)에 직접 설치되어 실행되는 형태였습니다. 예를 들어, Java로 개발된 '계산기' 애플리케이션을 개인 PC에 설치하여 사용하는 방식이 이에 해당합니다.

* **클라이언트**: 사용자 PC에서 직접 모든 기능(데이터 입력, 계산, 결과 출력)을 수행하는 방식이에요.

* **문제점**:
    * **유지보수의 비효율성**: 기능 변경이나 버그 발생 시, 전 세계 사용자 PC에 설치된 프로그램을 일일이 업데이트하거나 재설치해야 하는 심각한 비효율성이 존재했습니다. 상상만 해도 번거롭죠.
    * **보안 취약성**: 만약 프로그램 내에 민감한 정보(예: 데이터베이스 접속 정보)가 포함되어 있다면, 클라이언트 PC 해킹 시 해당 정보가 그대로 노출될 수 있어 보안에 매우 취약했습니다.
이러한 한계점들을 극복하기 위해 **클라이언트-서버 기반 프로그램** 모델이 도입되었습니다.

---

#### 2. 클라이언트-서버 기반 프로그램 (역할 분담 모델)
클라이언트 PC 기반 프로그램의 단점을 해소하고자, 프로그램의 핵심 기능 및 데이터 처리를 전담하는 '서버' 개념이 도입되었습니다. 이는 업무 분담을 통한 효율성 증대를 목표로 합니다.

* **클라이언트**: 사용자 PC는 이제 단순화된 역할을 수행합니다. 데이터를 서버로 '전송'하고, 서버가 처리한 결과를 '수신'하여 화면에 표시하는 기능, 즉 '화면' 출력만을 담당하게 되는 거예요.

* **서버**: 반대로 서버는 클라이언트로부터 데이터를 수신하여 실질적인 계산, 복잡한 비즈니스 로직 처리 등 모든 핵심 기능을 수행하며, 그 결과를 클라이언트에 다시 전송하는 역할을 합니다. '핵심 기능'을 전담하는 모델이라고 생각하면 돼요.

* **동작 방식**:
    * 클라이언트에서 처리할 데이터가 발생하면, **네트워크(인터넷)**를 통해 서버에 전송합니다.
    * 서버는 해당 데이터를 처리한 후, 처리된 결과를 다시 네트워크를 통해 클라이언트에 반환하며, 클라이언트는 이를 화면에 시각적으로 표현하는 방식이에요.
* **장점**:
    * **유지보수의 효율성 증대**: 기능(로직) 변경 시 서버만 업데이트하면 되므로, 클라이언트 프로그램의 개별적인 수정이 불필요했습니다. 이건 관리 측면에서 정말 큰 개선이었죠.
    * **보안 강화**: 중요한 데이터 및 핵심 로직이 서버에만 존재하므로, 클라이언트 PC의 해킹 시 보안 위험이 현저히 감소했습니다.
* **단점**: 화면 디자인 또는 구조 변경 시 여전히 클라이언트 프로그램을 수정해야 하는 제약이 존재했습니다.

---

#### 3. 웹 기반 프로그램 (현재의 인터넷 환경)
클라이언트-서버 모델에서 더욱 발전하여, 현재 우리가 일상적으로 사용하는 웹 브라우저를 클라이언트로 활용하는 형태가 정립되었습니다.

* **클라이언트**: 별도의 프로그램 설치가 필요 없습니다. 사용자는 기본적인 **웹 브라우저(Chrome, Edge, Safari 등)**를 실행하여 원하는 웹사이트의 URL을 입력하기만 하면 됩니다. 브라우저는 자동으로 서버에 필요한 HTML 문서를 요청하고 수신하여 화면에 표시해 줘요.

* **서버**: 클라이언트(브라우저)가 요청한 HTML 문서를 브라우저에 전송하여 화면 출력을 가능하게 합니다. 사용자가 화면에서 데이터를 입력하고 '확인' 버튼을 클릭하면, 서버는 해당 데이터를 수신하여 처리하고, 처리된 결과를 웹 브라우저로 재전송하여 화면 변경을 유도하는 방식이에요.

* **동작 방식**:
    * 사용자가 주소창에 `www.naver.com`과 같은 URL을 입력합니다.
    * 웹 브라우저는 네이버 서버에 HTML 문서 요청을 전송합니다.
    * 네이버 서버는 요청된 HTML 문서를 브라우저에 전송하고, 브라우저는 이를 파싱하여 네이버 웹페이지를 사용자에게 표시해 줍니다.
    * 만약 검색창에 뭘 입력하고 검색 버튼을 누르면, 그 데이터가 다시 서버로 전송되어 처리되고, 검색 결과가 포함된 새로운 HTML이 브라우저로 반환되어 화면이 갱신되는 거예요.

    ![웹 기반 프로그램 이미지](/assets/images/jsp/web-based-program.webp)

* **장점**:
    * **최적의 유지보수성**: 사용자 프로그램의 기능 또는 화면이 바뀌더라도, 대부분의 처리가 서버에서 이루어지기 때문에 클라이언트(웹 브라우저)는 업데이트할 필요가 없습니다.
    * **높은 접근성**: 웹 브라우저만 있다면 언제 어디서든 서비스에 접근 가능해요.
    * **우수한 보안**: 중요한 데이터와 로직은 서버에서 안전하게 관리됩니다.

---

### 💡 HTTP: 웹 통신의 표준 프로토콜
웹 기반 프로그램의 핵심 요소 중 하나는 **HTTP(HyperText Transfer Protocol)**입니다. HTTP는 웹 환경에서 정보 교환을 위한 **가장 기본적인 '통신 규칙'**을 의미해요. 웹 리소스(HTML 문서, 이미지 등)를 송수신하기 위해서는 HTTP 규약을 준수해야 합니다.

![HTTP 통신 이미지](/assets/images/jsp/http.webp)

#### HTTP의 특징:
* **간결한 구조**: HTTP 메시지 구조는 가독성이 높도록 설계되어 웹 개발의 빠른 발전에 기여했습니다.
* **확장성**: 웹 환경의 지속적인 발전에 맞춰 새로운 기능 추가 및 프로토콜 개선이 용이하도록 유연하게 설계되었습니다.
* **무상태성 및 세션 관리**:
    * **무상태성 (Stateless)**: HTTP의 가장 중요한 특징 중 하나입니다. 기본적으로 HTTP는 **이전에 주고받은 요청/응답에 대한 '상태'를 전혀 기억하지 못해요.** 즉, 클라이언트가 서버에 요청을 두 번 보냈다고 해도, 서버는 이 두 요청이 같은 클라이언트에서 온 건지, 이전에 무슨 일이 있었는지 전혀 모릅니다. 각 요청은 완전히 독립적인 '새로운' 요청으로 간주됩니다.
    * **세션 (Session)**: 하지만 실제 웹 서비스에서는 사용자의 로그인 상태나 장바구니 정보처럼 **'상태'를 유지**해야 할 필요가 있습니다. HTTP가 '무상태'라 기억을 못 하니, 이를 보완하기 위해 **쿠키(Cookie)**나 **세션(Session)** 같은 기술이 도입되었습니다. 얘네들이 바로 HTTP의 망각증을 치료해주는 비서 같은 역할을 하는 거예요.

---

### 💡 클라이언트와 서버: 웹 서비스의 핵심 구성요소

웹 기반 프로그램에서 클라이언트와 서버는 서로 상호작용하며 서비스를 제공합니다.

#### **클라이언트 (≈ 브라우저)**
* 클라이언트(주로 웹 브라우저)는 항상 **'요청(Request)'**을 보내는 주체입니다.
* 웹 페이지를 표시하기 위해, 브라우저는 먼저 페이지의 **HTML 문서**를 가져오기 위한 요청을 서버에 보냅니다.
* HTML 문서를 받은 브라우저는 그걸 해석해서 그림, 글자, 동영상 같은 걸 화면에 예쁘게 배치하고 보여주죠. 이때 필요한 이미지, CSS(스타일 정보), JavaScript(동적인 기능) 같은 하위 리소스들도 서버에 추가로 '요청'해서 가져옵니다. 이 모든 걸 합쳐서 하나의 완성된 웹 페이지를 우리에게 보여주는 거예요.

#### **서버**
* 서버는 클라이언트(브라우저)로부터의 요청에 대한 **'응답(Response)'**으로 메시지를 전송하는 개체입니다.
* 클라이언트가 '이 데이터 좀 처리해주세요' 하면 서버는 그걸 받아서 필요한 작업을 한 다음, 처리된 결과물을 다시 클라이언트에게 돌려주는 거죠.

#### **HTTP 메시지 구성 (요청/응답 공통)**
클라이언트와 서버가 주고받는 HTTP 메시지는 크게 두 부분으로 나뉘어요.

* **헤더 (Headers)**: 통신에 필요한 **추가 정보**를 담고 있어요. (예: 메시지의 종류, 인코딩 방식, 쿠키 정보 등)
* **바디 (Body)**: 실제로 주고받을 **핵심 데이터**가 이 안에 들어있습니다.

---

#### 📩 요청 (Request) 메시지: 클라이언트의 서버 요청

클라이언트가 서버에 보낼 때는 이런 정보들을 담아서 보냅니다.

* **HTTP 메서드**: **`GET`** (정보를 요청할 때), **`POST`** (정보를 제출할 때)와 같이 요청의 '목적'을 나타내는 방식이에요.
* **PATH**: 가져오려는 리소스의 경로 (예: `/users`, `/products/123`).
* **Headers**: 서버에 대한 추가 정보를 전달하는 헤더.
* **바디**: `POST` 방식으로 서버에 사용자 입력값처럼 추가적인 데이터를 보낼 때, 이 바디 부분에 실제 데이터가 담겨요. 헤더와 바디 사이에는 항상 빈 줄(`\r\n`)이 하나 들어갑니다.

![요청 메시지 이미지](/assets/images/jsp/asking.webp)

---

#### 📬 응답 (Response) 메시지: 서버의 클라이언트 응답

서버가 클라이언트 요청을 처리하고 보내는 답장에는 이런 정보들이 담겨 있어요.

* **Status Code (상태 코드)**: 세 자리 숫자로 이루어진 코드인데, '클라이언트 요청이 성공했는지', '무슨 문제가 있었는지'를 알려주는 **결과 보고서** 같은 거예요.
    * **`2xx` (성공)**: 요청이 성공적으로 처리되었습니다.
        * **`200 OK`**: 가장 흔한 성공 코드. '완벽하게 성공!'이에요.
    * **`3xx` (리다이렉션)**: 요청을 완료하기 위해 추가적인 조치가 필요합니다. (예: 다른 URL로 이동)
    * **`4xx` (클라이언트 오류)**: 클라이언트의 요청에 문제가 있습니다.
        * **`404 Not Found`**: 요청한 리소스(경로)를 서버에서 찾을 수 없습니다. (경로상의 문제)
        * **`405 Method Not Allowed`**: 요청에 사용된 HTTP 메서드를 리소스가 허용하지 않습니다. (요청 방식의 문제)
    * **`5xx` (서버 오류)**: 서버가 요청을 수행하지 못했습니다.
        * **`500 Internal Server Error`**: 서버 내부에서 오류가 발생했습니다. (일반적으로 코드상의 문제)

![응답 메시지 이미지](/assets/images/jsp/response.webp)

**렌더링**: HTML, CSS, 자바스크립트 등 개발자가 작성한 문서가 웹 브라우저에서 최종적으로 사용자에게 보여지는 형태로 변환되어 출력되는 과정을 의미합니다. (예: 티스토리 블로그 홈페이지에 대한 요청과 응답을 통해 브라우저가 화면을 렌더링하는 방식이에요.)

![티스토리 블로그 렌더링 이미지](/assets/images/jsp/Tstory.webp)

---

### 🏡 Web Server vs WAS: 누가 정적이고, 누가 동적일까?
웹 서비스를 제공하는 서버는 크게 두 가지 종류로 나눌 수 있어요. 이 둘의 역할이 달라서 같이 사용하는 경우가 많습니다.

#### **Web Server**
* **Web**: 인터넷 기반 서비스 (URL(주소), HTTP(통신 규칙), HTML(내용)으로 구성)
* **Server**: 클라이언트에게 네트워크를 통해 정보나 시스템을 제공하는 컴퓨터 시스템
* **Web Server**: 인터넷을 기반으로 클라이언트에게 웹 서비스를 제공하는 컴퓨터 또는 해당 소프트웨어를 말해요.
* **주요 역할**: 요청이 있을 때 **정적인 웹 페이지** (HTML, CSS, JavaScript 파일, 이미지, 동영상 파일 등)를 클라이언트에게 제공하는 소프트웨어입니다.
* **동작 방식**: 웹 브라우저에 URL을 입력하면 브라우저는 웹 서버에 요청을 보내고, 웹 서버는 요청된 파일을 찾아 브라우저에게 그대로 보내는 방식이에요.
* **예시**: Apache HTTP Server, Nginx

![웹 서버 이미지](/assets/images/jsp/web-based-program.webp)

---

#### **WAS (Web Application Server)**
* **Web Application**: 웹에서 실행하는 응용 프로그램 (데이터베이스 조회, 로직 처리 등 동적인 기능 수행)
* **WAS**: 웹 애플리케이션 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크입니다.
* **주요 역할**: 웹 애플리케이션을 실행시켜 필요한 기능을 수행하고 그 결과를 웹 서버에게 전달하거나, 직접 클라이언트에게 동적인 콘텐츠를 제공합니다. **PHP, JSP, ASP.NET**과 같이 동적으로 페이지를 생성해야 할 때 사용됩니다.
* **동작 방식**: 클라이언트의 요청을 받으면, 웹 애플리케이션을 실행하여 데이터를 처리하고, 데이터베이스에 접근하며, 비즈니스 로직을 수행하여 동적인 HTML 페이지를 생성한 후 이를 클라이언트(또는 웹 서버)에게 보냅니다.
* **Web Server와 WAS의 차이**: 가장 큰 차이는 **상황에 따라 변하는 정보를 제공할 수 있는지 여부**입니다.
    * **웹 서버**: 정적 콘텐츠 (항상 동일한 내용)를 제공해요.
    * **WAS**: 동적 콘텐츠 (요청에 따라 내용이 달라지는)를 제공합니다.
* **예시**: Apache Tomcat (우리가 JSP를 공부할 때 사용할!), JBoss, WebLogic, WebSphere
실제 서비스에서는 보통 **'웹 서버 + WAS'**를 함께 사용해요. 웹 서버는 정적인 파일들을 빠르게 처리하고, WAS는 복잡한 동적 요청들을 담당하여 효율성을 높이는 전략이죠.

![WAS 이미지](/assets/images/jsp/WAS.webp)

---

### 📦 Web Container (Servlet Container) - 서블릿의 집사!
**웹 컨테이너(Web Container)**는 WAS 안에 있는 아주 중요한 구성 요소예요. 마치 WAS가 큰 호텔이라면, 웹 컨테이너는 서블릿(Servlet)이라는 손님들을 관리해주는 '집사' 또는 '매니저' 역할을 한다고 생각하면 돼요.

* **서블릿 생명주기 관리**: 자바 서블릿은 일반적인 자바 프로그램처럼 `main` 메서드를 가지고 있지 않으므로, 웹 컨테이너가 서블릿의 **생성부터 소멸까지의 과정(생명주기)**을 담당합니다.
* **요청/응답 처리의 다리 역할**: 사용자의 HTTP 요청이 들어오면, 웹 컨테이너는 이 요청을 분석하여 적절한 서블릿에 전달하고, 서블릿이 처리한 응답을 다시 클라이언트에게 전달하는 역할을 수행합니다.
* **URL 매핑 및 권한 관리**: 특정 URL 요청이 왔을 때 어떤 서블릿을 실행할지 매핑하며, 필요한 경우 접근 권한을 보장하는 역할도 합니다.
* **데이터베이스 접근 지원**: 서블릿이 데이터베이스에 접근하여 응답을 생성하는 과정 또한 웹 컨테이너의 관리 하에 이루어집니다.
* **예시**: Apache Tomcat (톰캣은 대표적인 WAS이자 웹 컨테이너입니다.)

![웹 컨테이너 이미지](/assets/images/jsp/Web-Container.webp)

---

### 👩‍💻 Servlet (서블릿) - 웹을 위한 자바 클래스!
자, 드디어 서블릿이 다시 등장했네요! **서블릿(Servlet)**은 HTML 같은 정적인 콘텐츠가 아니라, 사용자의 요청에 따라 동적으로 웹 페이지를 생성하고 데이터를 처리하기 위해 자바로 만든 클래스를 말해요.

* **역할**: 클라이언트의 요청을 받아 비즈니스 로직을 처리하고, 동적인 웹 페이지를 생성하여 클라이언트에게 응답하는 역할을 합니다.
* **생명주기(Lifecycle)**: 모든 서블릿은 웹 컨테이너에 의해 특별한 '생명주기'를 가집니다.
    1.  **`init()`**: 서블릿 객체가 웹 컨테이너에 의해 처음으로 생성될 때(또는 웹 컨테이너 시작 시) **단 한 번** 호출되어 초기화 작업을 수행합니다.
    2.  **`service()`**: 클라이언트로부터 요청이 들어올 때마다 **반복적으로 호출**되어 실제 비즈니스 로직을 처리하고 응답을 생성합니다. (내부적으로 `doGet()`, `doPost()` 등을 호출)
    3.  **`destroy()`**: 서블릿이 소멸될 때(예: 웹 컨테이너 종료 시) **단 한 번** 호출되어 자원을 해제하는 작업을 수행합니다.

### 🔚 마치며

지금까지 프로그램의 발전 과정부터 웹 통신의 기본이 되는 HTTP, 클라이언트/서버 개념, 그리고 웹 서버와 WAS의 차이, WAS의 핵심 구성요소인 웹 컨테이너와 서블릿에 대해 자세히 알아보았습니다. 이 용어들은 자바 기반의 웹 애플리케이션 개발, 특히 JSP/Servlet 기반의 개발을 이해하는 데 필수적인 기초 지식들이에요.

이 개념들을 잘 이해하고 나면, 웹 서비스가 어떻게 동작하고 클라이언트와 서버가 어떻게 소통하는지 큰 그림을 그릴 수 있을 거예요. 앞으로 배울 JSP와 같은 기술들이 이러한 기반 위에서 어떻게 작동하는지 이해하는 데 큰 도움이 될 겁니다.
---
```