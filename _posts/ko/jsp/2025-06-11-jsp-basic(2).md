---
title: "JSP - 용어 정리(1)"
date: date: 2025-06-11 16:28:06 +09:00
categories: [jsp]
lang: ko
locale: ko
words_per_minute: 30
---

---
## 📘 1단계: JSP - 용어 정리 (프로그램 발전 과정 및 웹의 이해)

프로그래밍과 데이터베이스의 세계에 발을 들이면서, 다양한 용어와 개념들을 접하게 됩니다. 특히 웹 기반 애플리케이션의 동작 방식을 이해하는 것은 현대 소프트웨어 개발의 핵심입니다. 이번 글에서는 프로그램의 발전 과정을 짚어보며, 웹 환경에서 데이터를 주고받는 데 필수적인 용어들인 **HTTP**, **클라이언트/서버**, **웹 서버 vs WAS**, 그리고 **웹 컨테이너** 및 **서블릿**에 대해 상세하게 설명해 드리겠습니다.

---

### 💡 프로그램 발전 과정: 클라이언트 PC 기반에서 웹 기반으로

소프트웨어는 시대의 요구에 따라 끊임없이 발전해왔습니다. 그 중심에는 데이터를 처리하고 사용자에게 서비스를 제공하는 방식의 진화가 있습니다.

#### 1. 클라이언트 PC 기반 프로그램

가장 초기 형태의 프로그램은 사용자의 PC에 직접 설치하여 실행되는 방식이었습니다. 예를 들어, 자바로 구현된 "시간 계산기"를 사용자의 PC에 설치하여 사용하는 경우입니다.

* **클라이언트**: 사용자의 PC에서 직접 실행되며, 데이터 입력, 계산, 화면 출력 등 모든 기능을 수행합니다.
* **문제점**:
    * **업데이트의 번거로움**: 프로그램 기능이 추가되거나 버그가 수정되면, 모든 사용자 PC에 프로그램을 업데이트하거나 새로 설치해야 했습니다.
    * **보안 취약**: 데이터베이스 접속 정보나 기타 중요한 정보가 클라이언트 프로그램 내에 포함되어 있다면, 악의적인 사용자에 의해 쉽게 노출될 수 있어 보안에 매우 취약했습니다.

이러한 클라이언트 PC 기반 프로그램의 한계를 극복하기 위해 등장한 것이 바로 **클라이언트-서버 기반 프로그램**입니다.

---

#### 2. 클라이언트-서버 기반 프로그램

클라이언트-서버 모델은 프로그램의 기능(로직)과 데이터 처리를 전담하는 서버를 도입함으로써 기존 방식의 문제점을 개선했습니다.

* **클라이언트**: 데이터를 서버로 전달하고, 서버로부터 처리된 값을 받아 화면에 출력하는 역할만 합니다. 즉, 화면과 관련된 코드만 클라이언트에게 있습니다.
* **서버**: 클라이언트로부터 전달받은 데이터를 받아 실질적인 계산이나 비즈니스 로직을 수행하고, 그 결과를 클라이언트에 반환합니다. 중요한 기능(로직)은 모두 서버에서 처리됩니다.
* **동작 방식**:
    * 클라이언트는 처리할 데이터가 있으면 **네트워크**를 통해 서버에 전달합니다.
    * 서버는 이 데이터를 처리하고, 처리된 결과를 다시 네트워크를 통해 클라이언트에 전달하여 화면에 출력합니다.
* **장점**:
    * **쉬운 유지보수**: 기능(로직)이 변경되어도 모두 서버에서 처리하므로, 클라이언트 프로그램을 수정하거나 재배포할 필요가 없습니다. 서버만 업데이트하면 됩니다.
    * **향상된 보안**: 중요한 데이터와 기능 로직이 클라이언트 PC가 아닌 서버에 집중되므로, 데이터 노출 위험이 줄어들어 보안 측면에서 더욱 우수합니다.
* **단점**: 화면 디자인이나 구조가 변경된다면 여전히 클라이언트의 코드를 수정해야 합니다.

---

#### 3. 웹 기반 프로그램

오늘날 우리가 가장 흔하게 사용하는 형태의 프로그램입니다. 클라이언트-서버 모델에서 더욱 발전하여, 웹 브라우저를 클라이언트로 활용하는 방식입니다.

* **클라이언트**: 사용자는 별도의 클라이언트 프로그램을 설치할 필요 없이, 자신의 컴퓨터에 설치된 **웹 브라우저**를 통해 화면에 해당하는 HTML 문서를 서버에 요청합니다.
* **서버**: 클라이언트로부터 요청받은 HTML 문서를 브라우저에 전송하여 화면을 출력합니다. 사용자가 화면에서 데이터를 입력하고 처리를 요청하면, 서버는 그 데이터를 전송받아 처리한 후 계산 결과를 다시 웹 브라우저로 전송하여 보여줍니다.
* **동작 방식**:
    * 사용자가 웹 브라우저에 `www.sh.log`와 같은 URL을 입력합니다.
    * 웹 브라우저는 해당 주소의 서버에 HTML 문서를 요청합니다.
    * 서버는 요청받은 HTML 문서를 브라우저에 전송하고, 브라우저는 이를 해석하여 화면을 그립니다.
    * 사용자가 화면에서 데이터를 입력하면, 이 데이터는 다시 서버로 전송되어 처리되고, 그 결과가 웹 브라우저로 반환되어 표시됩니다.
* **장점**:
    * **최고의 유지보수성**: 사용자가 사용하는 프로그램의 기능이나 화면이 바뀌더라도, 대부분의 처리가 서버에서 이루어지기 때문에 클라이언트(웹 브라우저)는 업데이트할 필요가 없습니다.
    * **높은 접근성**: 웹 브라우저만 있으면 어디서든 서비스에 접근할 수 있습니다.
    * **우수한 보안**: 중요한 데이터와 로직은 여전히 서버에서 관리됩니다.

---

### 💡 HTTP: 웹 통신의 핵심 규칙

**HTTP (HyperText Transfer Protocol)**는 웹에서 이루어지는 모든 데이터 교환의 기초가 되는 통신 규칙입니다. 인터넷을 통해 정보를 주고받을 때 필요한 통신 규약으로, HTML 문서와 같은 웹 리소스들을 가져올 수 있도록 해주는 프로토콜입니다.

#### 특징:

* **간단하다**: 사람이 읽을 수 있으며, 구조가 간단하게 고안되어 이해하기 쉽습니다.
* **확장 가능하다**: 언제든지 새로운 기능을 추가하고 확장할 수 있습니다.
* **상태는 없지만 세션은 있다**:
    * **상태 없음 (Stateless)**: HTTP는 기본적으로 **상태를 저장하지 않습니다.** 이는 동일한 연결 상에서 연속하여 전달된 두 개의 요청 사이에 어떤 연결 고리도 없다는 의미입니다. 각 요청은 독립적으로 처리됩니다.
    * **세션 (Session)**: 하지만 실제 웹 서비스에서는 사용자의 로그인 상태나 장바구니 정보처럼 **'상태'를 유지**해야 할 필요가 있습니다. 이를 위해 **쿠키(Cookie)**나 **세션(Session)**과 같은 기술이 도입되어 HTTP의 stateless 특성을 보완합니다.

---

### 💡 클라이언트와 서버: 웹 서비스의 양대 축

웹 기반 프로그램에서 클라이언트와 서버는 서로 상호작용하며 서비스를 제공합니다.

#### **클라이언트 (≈ 브라우저)**

* **클라이언트(주로 웹 브라우저)**는 항상 **요청(Request)**을 보내는 주체입니다.
* 웹 페이지를 표시하기 위해, 브라우저는 먼저 페이지의 **HTML 문서**를 가져오기 위한 요청을 서버에 전송합니다.
* HTML 문서를 받은 브라우저는 이를 구문 분석하고 실행해야 할 **스크립트(JavaScript)**, 페이지를 잘 표시하기 위한 **레이아웃 정보(CSS)**, 그리고 페이지 내 포함된 하위 리소스(**이미지, 비디오** 등)에 대응하는 추가적인 요청들을 서버에 가져옵니다.
* 그 뒤에 브라우저는 이 모든 리소스들을 혼합하여 완전한 문서인 **웹 페이지를 화면에 표시**합니다.

#### **서버**

* 서버는 클라이언트(브라우저)로부터의 요청에 대한 **응답(Response)**으로 메시지를 전송하는 개체입니다.
* 서버는 클라이언트의 요청을 받아 데이터를 처리하고, 필요한 정보를 생성하여 다시 클라이언트에게 보냅니다.

#### **HTTP 메시지 구성 (요청/응답 공통)**

HTTP 메시지는 크게 **헤더(Headers)**와 **바디(Body)**로 구성됩니다. 편지에 비유하자면, 헤더는 편지 봉투에 적힌 정보(보내는 사람, 받는 사람, 내용물의 종류 등)와 같고, 바디는 편지 내용 그 자체입니다.

* **헤더 (Headers)**: 서버 또는 클라이언트에 대한 **추가 정보**를 전달합니다. (예: 메시지의 종류, 인코딩 방식, 쿠키 정보 등)
* **바디 (Body)**: 실제로 주고받을 **데이터 내용**을 포함합니다.

---

#### **요청 (Request) 메시지**

클라이언트가 서버에게 보내는 메시지입니다.

* **HTTP 메서드**: **`GET`** (정보를 요청할 때), **`POST`** (정보를 제출할 때)와 같은 요청 방식입니다.
* **PATH**: 가져오려는 리소스의 경로 (예: `/users`, `/products/123`).
* **Headers**: 서버에 대한 추가 정보를 전달하는 헤더.
* **바디**: `POST` 방식으로 서버에 추가적인 정보를 전달할 때 본문에 포함하여 요청합니다. 헤더와 본문을 구분하기 위해 한 줄 공백(`\r\n`) 후 본문 내용이 옵니다.

#### **응답 (Response) 메시지**

서버가 클라이언트에게 보내는 메시지입니다.

* **Status Code (상태 코드)**: 서버가 요청을 성공적으로 처리했는지, 아니면 오류가 발생했는지를 나타내는 세 자리 숫자 코드입니다.
    * **`2xx` (성공)**: 요청이 성공적으로 처리되었습니다.
        * **`200 OK`**: 요청이 성공했습니다.
    * **`3xx` (리다이렉션)**: 요청을 완료하기 위해 추가적인 조치가 필요합니다. (예: 다른 URL로 이동)
    * **`4xx` (클라이언트 오류)**: 클라이언트의 요청에 문제가 있습니다.
        * **`404 Not Found`**: 요청한 리소스(경로)를 서버에서 찾을 수 없습니다. (경로상의 문제)
        * **`405 Method Not Allowed`**: 요청에 사용된 HTTP 메서드를 리소스가 허용하지 않습니다. (요청 방식의 문제)
    * **`5xx` (서버 오류)**: 서버가 요청을 수행하지 못했습니다.
        * **`500 Internal Server Error`**: 서버 내부에서 오류가 발생했습니다. (일반적으로 코드상의 문제)

**렌더링**: HTML, CSS, 자바스크립트 등 개발자가 작성한 문서가 웹 브라우저에서 최종적으로 사용자에게 보여지는 형태로 변환되어 출력되는 과정을 의미합니다. (예: 티스토리 블로그 홈페이지에 대한 요청과 응답을 통해 브라우저가 화면을 렌더링)

---

### 💡 Web Server vs WAS: 웹 서비스의 두 가지 얼굴

웹 기반 서비스에서 서버는 크게 **웹 서버(Web Server)**와 **웹 애플리케이션 서버(WAS, Web Application Server)**로 구분됩니다.

#### **Web Server**

* **Web**: 인터넷 기반 서비스 (URL(주소), HTTP(통신 규칙), HTML(내용)으로 구성)
* **Server**: 클라이언트에게 네트워크를 통해 정보나 시스템을 제공하는 컴퓨터 시스템
* **Web Server**: 인터넷을 기반으로 클라이언트에게 웹 서비스를 제공하는 컴퓨터 또는 해당 소프트웨어입니다.
* **주요 역할**: 요청이 있을 때 **정적인 웹 페이지** (HTML, CSS, JavaScript 파일, 이미지, 동영상 파일 등)를 클라이언트에게 제공하는 소프트웨어입니다.
* **동작 방식**: 웹 브라우저에 URL을 입력하면 브라우저는 웹 서버에 요청을 보내고, 웹 서버는 요청된 파일을 찾아 브라우저에게 그대로 보냅니다.
* **예시**: Apache HTTP Server, Nginx

---

#### **WAS (Web Application Server)**

* **Web Application**: 웹에서 실행하는 응용 프로그램 (데이터베이스 조회, 로직 처리 등 동적인 기능 수행)
* **WAS**: 웹 애플리케이션 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크입니다.
* **주요 역할**: 웹 애플리케이션을 실행시켜 필요한 기능을 수행하고 그 결과를 웹 서버에게 전달하거나, 직접 클라이언트에게 동적인 콘텐츠를 제공합니다. **PHP, JSP, ASP.NET**과 같이 동적으로 페이지를 생성해야 할 때 사용됩니다.
* **동작 방식**: 클라이언트의 요청을 받으면, 웹 애플리케이션을 실행하여 데이터를 처리하고, 데이터베이스에 접근하며, 비즈니스 로직을 수행하여 동적인 HTML 페이지를 생성한 후 이를 클라이언트(또는 웹 서버)에게 보냅니다.
* **Web Server와 WAS의 차이**: 가장 큰 차이는 **상황에 따라 변하는 정보를 제공할 수 있는지 여부**입니다.
    * **웹 서버**: 정적 콘텐츠 (항상 동일한 내용) 제공.
    * **WAS**: 동적 콘텐츠 (요청에 따라 내용이 달라지는) 제공.
* **예시**: Apache Tomcat, JBoss, WebLogic, WebSphere

---

### 💡 Web Container (Servlet Container)

**웹 컨테이너(Web Container)**는 WAS의 핵심 구성 요소 중 하나로, **서블릿(Servlet)의 생명주기를 관리**하는 소프트웨어 환경입니다. 자바 웹 애플리케이션이 WAS 위에서 동작할 수 있도록 지원하는 역할을 합니다.

* **서블릿 생명주기 관리**: 자바 서블릿은 일반적인 자바 프로그램처럼 `main` 메소드를 가지고 있지 않으므로, 웹 컨테이너가 서블릿의 **생성부터 소멸까지의 과정(생명주기)**을 담당합니다.
* **요청/응답 처리**: 사용자의 HTTP 요청을 받으면, 웹 컨테이너는 이 요청을 파싱하여 적절한 서블릿에 전달하고, 서블릿이 처리한 응답을 다시 클라이언트에게 전달하는 역할을 수행합니다.
* **URL 매핑 및 권한 보장**: 특정 URL 요청이 왔을 때 어떤 서블릿을 실행할지 매핑하며, 필요한 경우 접근 권한을 보장하는 역할도 합니다.
* **데이터베이스 접근 관리**: 서블릿이 데이터베이스에 접근하여 응답을 생성하는 과정 또한 웹 컨테이너의 관리 하에 이루어집니다.
* **예시**: Apache Tomcat (톰캣은 대표적인 WAS이자 웹 컨테이너입니다.)

---

### 💡 Servlet

**서블릿(Servlet)**은 자바를 사용하여 웹 애플리케이션을 만들 때 필요한 기술(클래스)입니다. HTML 페이지와 같은 정적인 콘텐츠가 아닌, 사용자의 요청에 따라 동적으로 페이지를 생성하고 데이터를 처리하는 기능을 제공합니다.

* **역할**: 클라이언트의 요청을 받아 비즈니스 로직을 처리하고, 동적인 웹 페이지를 생성하여 클라이언트에게 응답하는 역할을 합니다.
* **생명주기(Lifecycle)**: 서블릿은 웹 컨테이너에 의해 다음과 같은 생명주기를 가집니다.
    1.  **`init()`**: 서블릿 객체가 처음 생성될 때(또는 웹 컨테이너 시작 시) 단 한 번 호출되어 초기화 작업을 수행합니다.
    2.  **`service()`**: 클라이언트로부터 요청이 들어올 때마다 반복적으로 호출되어 실제 비즈니스 로직을 처리하고 응답을 생성합니다. (내부적으로 `doGet()`, `doPost()` 등을 호출)
    3.  **`destroy()`**: 서블릿이 소멸될 때(예: 웹 컨테이너 종료 시) 단 한 번 호출되어 자원을 해제하는 작업을 수행합니다.

---

### 🔚 마무리

지금까지 프로그램의 발전 과정부터 웹 통신의 기본이 되는 HTTP, 클라이언트/서버 개념, 그리고 웹 서버와 WAS의 차이, WAS의 핵심 구성요소인 웹 컨테이너와 서블릿에 대해 자세히 알아보았습니다. 이 용어들은 자바 기반의 웹 애플리케이션 개발, 특히 JSP/Servlet 기반의 개발을 이해하는 데 필수적인 기초 지식입니다.

이 개념들을 잘 이해하고 나면, 웹 서비스가 어떻게 동작하고 클라이언트와 서버가 어떻게 소통하는지 큰 그림을 그릴 수 있게 될 것입니다. 앞으로 배울 JSP와 같은 기술들이 이러한 기반 위에서 어떻게 작동하는지 이해하는 데 큰 도움이 될 거예요.
---