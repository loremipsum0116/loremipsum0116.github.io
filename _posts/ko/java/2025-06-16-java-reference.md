---
title: "자바 참조타입"
date: 2025-06-16 16:30:46 +09:00
categories: [java]
lang: ko
locale: ko
words_per_minute: 30
---

-----

## 자바 참조 타입의 메모리 사용: 변수가 데이터를 품는 방식 이해하기

자바의 데이터 타입은 \*\*기본 타입(Primitive Type)\*\*과 \*\*참조 타입(Reference Type)\*\*으로 나뉩니다. 이 두 타입은 단순히 데이터를 다루는 방식만 다른 게 아니라, **메모리에 저장되고 관리되는 방식에서도 근본적인 차이**를 보입니다. 특히, 이 차이는 두 변수가 **동일한지 비교할 때 사용하는 `==` 연산자의 동작 방식**에서 명확하게 드러납니다.

| 구분 | 기본 타입 (Primitive Type) | 참조 타입 (Reference Type) |
|---|---|---|
| **저장 값** | 변수 자체에 **실제 데이터 값**을 직접 저장합니다. | 변수에는 실제 데이터가 저장된 \*\*메모리 '주소'(번지)\*\*를 저장하고, 실제 데이터(객체)는 별도의 메모리 공간에 저장됩니다. |
| **메모리 영역** | 주로 **스택(Stack) 영역**에 저장됩니다. | 변수는 **스택(Stack) 영역**에, 실제 데이터(객체/배열)는 **힙(Heap) 영역**에 저장됩니다. |
| **`==` 연산자** | **두 변수에 저장된 실제 값**이 같은지를 비교합니다. | \*\*두 변수에 저장된 '메모리 주소'\*\*가 같은지를 비교합니다. 즉, 두 변수가 **동일한 객체를 참조**하는지 여부를 판단합니다. 실제 객체 내부의 값이 같은지는 `equals()` 메소드로 비교해야 합니다. |
| **데이터 크기** | 데이터 타입별로 정해진 고정된 크기(예: `int`는 4바이트, `double`은 8바이트)를 가집니다. | 객체의 내용에 따라 가변적인 크기를 가집니다. 변수 자체는 주소값을 저장하므로 고정된 크기(4 또는 8바이트)를 가집니다. |
| **`new` 키워드** | 객체 생성이 아니므로 `new` 키워드를 사용하지 않습니다. | 객체를 생성할 때 주로 `new` 키워드를 사용합니다. |
| **`null` 값** | `null` 값을 가질 수 없습니다. (초기화하지 않으면 기본값 가짐) | 객체를 참조하지 않는다는 의미로 `null` 값을 가질 수 있습니다. |
| **예시** | `int`, `double`, `boolean`, `char`, `byte`, `short`, `long`, `float` | `String`, 배열 (`int[]`, `String[]`), 클래스, 인터페이스, `enum` |

이번 글에서는 이 '참조'라는 개념이 자바 내부의 메모리 공간에서 어떻게 동작하는지, 그리고 왜 이러한 구분이 중요한지 자세히 알아보겠습니다.

자바 프로그램이 실행될 때, 운영체제로부터 할당받는 메모리 영역은 크게 **메소드 영역(Method Area), 힙 영역(Heap Area), 스택 영역(Stack Area)** 세 가지로 나뉩니다. 이 세 영역이 서로 유기적으로 작동하며 자바 변수와 데이터의 생명 주기를 관리합니다. 마치 도서관에서 책(데이터)이 보관되는 서가(힙), 책을 빌리고 반납하는 절차(스택), 도서관의 운영 규칙(메소드 영역)이 나뉘어 있는 것과 비슷합니다.

-----

## 자바 메모리 영역 구조와 역할

### 1\. 📚 메소드 영역 (Method Area)

**메소드 영역**은 프로그램이 시작될 때 가장 먼저 로드되는 영역입니다. 이 공간에는 모든 클래스의 **코드(`Bytecode`)**, **메소드(Method) 정보**, **필드(Field) 정보**, **상수(Constant)** 등의 정적인 정보들이 저장됩니다. 프로그램이 종료될 때까지 메모리에 남아있으며, 모든 스레드가 공유하는 영역입니다.

  * **저장되는 것**: 클래스 파일(.class) 내용, static 변수, 상수 풀(Constant Pool) 등
  * **특징**: 프로그램 시작 시 로드되며, 프로그램 종료 시 해제됩니다. 모든 스레드가 공유합니다.

### 2\. 📦 힙 영역 (Heap Area)

**힙 영역**은 자바에서 객체(인스턴스)가 생성되는 유일한 공간입니다. `new` 키워드를 사용하여 객체를 생성하면, 이 객체의 실제 데이터는 모두 힙 영역에 저장됩니다. 힙 영역은 프로그램 실행 중에 동적으로 할당되고 해제됩니다. 이 영역은 모든 스레드가 공유하며, 더 이상 참조되지 않는 객체들은 자바의 \*\*가비지 컬렉터(Garbage Collector)\*\*에 의해 자동으로 메모리에서 제거됩니다.

  * **저장되는 것**: `new` 연산자로 생성된 \*\*객체(Object)\*\*와 \*\*배열(Array)\*\*의 실제 데이터
  * **특징**: 동적으로 할당/해제됩니다. 가비지 컬렉션의 대상이 됩니다. 모든 스레드가 공유합니다.

### 3\. 🏃 스택 영역 (Stack Area)

**스택 영역**은 메소드 호출과 관련된 정보와 \*\*지역 변수(Local Variable)\*\*가 저장되는 공간입니다. 메소드가 호출될 때마다 해당 메소드를 위한 스택 프레임(Stack Frame)이 스택에 쌓이고, 메소드 실행이 끝나면 스택 프레임은 자동으로 제거됩니다. 스택 영역은 각 스레드마다 독립적으로 생성됩니다.

  * **저장되는 것**: 메소드 호출 정보, 메소드 내의 **지역 변수(매개변수 포함)**, 메소드 실행을 위한 임시 데이터
  * **특징**: LIFO(Last-In, First-Out) 구조로 데이터가 쌓이고 해제됩니다. 메소드 호출이 끝나면 자동으로 해제됩니다. 스레드마다 독립적입니다.

-----

## 참조 타입 변수의 메모리 동작 방식

이제 각 메모리 영역을 이해했으니, 참조 타입 변수가 이 영역들을 어떻게 활용하는지 구체적인 예시를 통해 살펴보겠습니다.

```java
public class ReferenceTypeMemory {
    public static void main(String[] args) {
        int num = 10; // 기본 타입 변수
        String name = "Java"; // 참조 타입 변수 (String은 클래스이므로 참조 타입)
        int[] scores = {90, 80, 70}; // 참조 타입 변수 (배열도 객체)

        calculateSum(scores); // 메소드 호출
    }

    public static void calculateSum(int[] arr) {
        int sum = 0; // 지역 변수
        for (int score : arr) {
            sum += score;
        }
        System.out.println("점수 합계: " + sum);
    }
}
```

위 코드를 실행했을 때 메모리에서 어떤 일이 일어나는지 단계별로 살펴보겠습니다.

### 1\. 메소드 영역 (Method Area)

  * `ReferenceTypeMemory` 클래스의 **바이트코드**와 `main()` 메소드, `calculateSum()` 메소드의 **코드 정보**가 메소드 영역에 로드됩니다.
  * 클래스 내부의 \*\*상수 문자열 "Java"\*\*와 같이 코드에 직접 명시된 리터럴 상수들도 이 영역의 \*\*상수 풀(Constant Pool)\*\*에 저장될 수 있습니다.

### 2\. 스택 영역 (Stack Area)

`main` 메소드가 호출되면서 스택 영역에 `main()` 메소드를 위한 **스택 프레임**이 생성됩니다.

  * `int num = 10;`
      * \*\*기본 타입 변수 `num`\*\*은 실제 값 `10`을 스택 프레임 내부에 직접 저장합니다.
  * `String name = "Java";`
      * \*\*참조 타입 변수 `name`\*\*은 스택에 생성됩니다.
      * 하지만 `name` 변수는 실제 문자열 "Java"를 직접 저장하지 않고, 이 문자열 객체가 **힙 영역에 생성된 주소값**을 저장합니다. (문자열 리터럴은 특수한 경우 상수 풀에 존재할 수도 있지만, 일반적인 객체 생성의 관점에서 힙에 비유할 수 있습니다.)
  * `int[] scores = {90, 80, 70};`
      * **참조 타입 변수 `scores`** 또한 스택에 생성됩니다.
      * `scores` 변수는 실제 배열 데이터 `{90, 80, 70}`을 직접 저장하는 것이 아니라, 이 **배열 객체가 힙 영역에 할당된 메모리 주소**를 저장합니다.

### 3\. 힙 영역 (Heap Area)

`new` 키워드를 사용하거나 배열 리터럴을 통해 객체가 생성되면, 해당 객체의 실제 데이터는 힙 영역에 저장됩니다.

  * `String name = "Java";` 에 의해 생성된 **"Java" 문자열 객체**의 실제 데이터가 힙 영역에 저장됩니다. 스택의 `name` 변수는 이 힙 영역의 주소를 가리킵니다.
  * `int[] scores = {90, 80, 70};` 에 의해 생성된 **정수 배열 객체** `[90][80][70]`의 실제 데이터가 힙 영역에 저장됩니다. 스택의 `scores` 변수는 이 힙 영역의 주소를 가리킵니다.

### 4\. `calculateSum()` 메소드 호출 시 스택 및 힙 동작

`calculateSum(scores);`가 호출되면 스택 영역에 `calculateSum()` 메소드를 위한 새로운 **스택 프레임**이 생성됩니다.

  * `calculateSum` 메소드의 매개변수 `int[] arr`은 **지역 변수**이므로 스택 프레임 내에 생성됩니다.
  * 이때 `arr`은 `main` 메소드의 `scores` 변수가 가지고 있던 **힙 영역의 배열 객체 주소**를 **복사**하여 저장합니다. 즉, `arr`과 `scores`는 서로 다른 스택 공간에 있지만, **동일한 힙 영역의 배열 객체를 참조**하게 됩니다.
  * `int sum = 0;`
      * `calculateSum` 메소드 내의 \*\*기본 타입 지역 변수 `sum`\*\*은 스택 프레임 내부에 실제 값 `0`을 저장합니다.

`calculateSum()` 메소드 실행이 끝나면, `calculateSum()` 스택 프레임과 그 안에 있던 모든 지역 변수(`arr`, `sum`)는 스택에서 자동으로 사라집니다. 그러나 `arr`이 참조하고 있던 **힙 영역의 배열 객체**는 여전히 `main` 메소드의 `scores` 변수에 의해 참조되고 있으므로, **메모리에서 제거되지 않습니다.**

-----

## `==` 연산자의 차이: 기본 타입 vs 참조 타입

`==` 연산자는 두 피연산자의 값이 같은지를 비교할 때 사용됩니다. 하지만 기본 타입과 참조 타입에서 이 '값'이 의미하는 바가 다르기 때문에, `==` 연산자의 동작 방식에도 중요한 차이가 있습니다.

### 1\. 기본 타입에서의 `==` 연산

기본 타입 변수들은 변수 자체에 실제 값을 저장합니다. 따라서 `==` 연산자는 단순히 **두 변수가 가진 실제 값**이 같은지를 비교합니다.

```java
int a = 10;
int b = 10;
int c = 20;

System.out.println(a == b); // true (a와 b의 값 10이 같음)
System.out.println(a == c); // false (a의 값 10과 c의 값 20이 다름)
```

### 2\. 참조 타입에서의 `==` 연산

참조 타입 변수들은 실제 객체가 아닌 \*\*객체의 메모리 주소(번지)\*\*를 저장합니다. 따라서 참조 타입에서 `==` 연산자는 **두 변수가 참조하는 '메모리 주소'가 같은지**를 비교합니다. 즉, 두 변수가 **동일한 하나의 객체를 가리키고 있는지**를 판단하는 것입니다. 객체 내부의 실제 데이터(값)가 같은지는 중요하지 않습니다.

```java
String str1 = "Hello";         // 문자열 리터럴은 상수 풀에서 관리될 수 있어 특수함
String str2 = "Hello";         // str1과 동일한 "Hello" 문자열 객체를 참조할 가능성 높음
String str3 = new String("Hello"); // 'new'로 새로운 String 객체를 힙에 생성
String str4 = new String("World"); // 'new'로 또 다른 String 객체를 힙에 생성

System.out.println(str1 == str2); // true (대부분의 JVM에서 상수 풀의 동일한 "Hello" 객체 참조)
System.out.println(str1 == str3); // false (str1은 상수 풀의 "Hello", str3은 힙의 다른 "Hello" 객체 참조)
System.out.println(str3 == str4); // false (서로 다른 힙의 객체 참조)

// 배열 예시
int[] arr1 = {1, 2, 3};
int[] arr2 = {1, 2, 3}; // arr1과 같은 값을 가지지만, 'new'로 다른 객체 생성됨
int[] arr3 = arr1;      // arr3은 arr1이 참조하는 객체와 '동일한' 객체를 참조

System.out.println(arr1 == arr2); // false (arr1과 arr2는 값은 같지만 서로 다른 메모리 주소의 객체)
System.out.println(arr1 == arr3); // true (arr1과 arr3은 동일한 메모리 주소의 객체를 참조)
```

**중요**: 참조 타입 객체의 **실제 내용(값)이 같은지**를 비교하려면, 일반적으로 `equals()` 메소드를 사용해야 합니다. 예를 들어, `String` 클래스는 `equals()` 메소드를 오버라이딩하여 문자열의 내용을 비교하도록 구현되어 있습니다.

```java
String str3 = new String("Hello");
String str5 = new String("Hello");

System.out.println(str3 == str5);   // false (서로 다른 객체)
System.out.println(str3.equals(str5)); // true (객체 내용은 같음)
```

-----

## 📌 요약: 메모리 사용의 핵심

  * **메소드 영역**: 클래스 코드, 메소드, `static` 변수 등 **정적 정보** 저장.
  * **힙 영역**: `new`로 생성된 **모든 객체(인스턴스)와 배열의 실제 데이터** 저장. 가비지 컬렉터의 대상.
  * **스택 영역**: 메소드 호출 정보, **지역 변수** 저장. 메소드 종료 시 자동 해제.
  * **기본 타입 변수**: **실제 값**을 스택에 직접 저장.
  * **참조 타입 변수**: \*\*힙 영역에 있는 실제 객체의 '주소'\*\*를 스택에 저장. 이 주소를 통해 실제 객체에 접근(참조)합니다.
  * **`==` 연산자**:
      * **기본 타입**: **실제 값**이 같은지 비교.
      * **참조 타입**: \*\*참조하는 메모리 주소(동일한 객체)\*\*가 같은지 비교. 실제 내용 비교는 `equals()` 메소드 사용.

-----

## 💡 메모리 사용 퀴즈: 변수의 종류와 값

다음 코드가 실행될 때 각 변수의 '값'과 '저장되는 메모리 영역'을 생각해 보세요.

```java
public class MemoryQuiz {
    public static void main(String[] args) {
        int count = 5;
        String city = "Seoul";
        MemoryQuiz mq = new MemoryQuiz(); // MemoryQuiz 객체 생성
    }
}
```

<details>
<summary>정답 보기</summary>
<br>

1.  **`int count = 5;`**
      * **값**: `5` (실제 정수 값)
      * **저장 영역**: **스택 영역** (기본 타입 변수는 값을 직접 저장)
        <br><br>
2.  **`String city = &quot;Seoul&quot;;`**
      * **값**: `city` 변수 자체에는 문자열 "Seoul"이 저장된 **힙 영역의 주소값**이 저장됩니다.
      * **저장 영역**: `city` 변수는 **스택 영역**에, 실제 문자열 객체 "Seoul"은 **힙 영역** (또는 문자열 상수 풀)에 저장됩니다.
        <br><br>
3.  **`MemoryQuiz mq = new MemoryQuiz();`**
      * **값**: `mq` 변수 자체에는 새로 생성된 `MemoryQuiz` **객체의 힙 영역 주소값**이 저장됩니다.
      * **저장 영역**: `mq` 변수는 **스택 영역**에, 실제 `MemoryQuiz` 객체는 **힙 영역**에 저장됩니다.
        <br><br>
        </details>

-----

## 🔚 마치며: 메모리 관리는 자바의 핵심\!

자바에서 기본 타입과 참조 타입이 메모리에서 어떻게 다르게 동작하는지 이해하는 것은 매우 중요합니다. 특히 참조 타입이 힙 영역에 객체를 생성하고, 스택에 그 객체를 가리키는 주소를 저장한다는 개념은 자바의 객체 지향 프로그래밍과 **가비지 컬렉션** 메커니즘을 이해하는 데 필수적인 기초 지식입니다.

이러한 메모리 구조를 정확히 파악하면 프로그램의 성능을 최적화하거나, `NullPointerException`과 같은 흔한 오류를 예방하고 디버깅하는 데 큰 도움이 됩니다.
