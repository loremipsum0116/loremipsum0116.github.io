---
title: "자바 변수와 연산자"
date: 2025-06-10 10:42:00 +09:00
categories: [java]
lang: ko
locale: ko
words_per_minute: 30
---

-----

## 자바 변수와 연산자: 데이터를 다루는 개발자의 필수 도구

지난 글에서 자바 **변수**의 개념과 종류, 그리고 생명 주기에 대해 상세히 알아보았습니다. 변수가 데이터를 담는 '그릇'이라면, 이 데이터를 활용하여 유의미한 작업을 수행하려면 무엇이 필요할까요? 바로 \*\*연산자(Operator)\*\*입니다\!
<br><br>
연산자는 변수에 담긴 값을 가지고 다양한 **수식 계산, 논리적 판단, 값 할당** 등의 처리를 할 수 있도록 돕는 특별한 기호들입니다. 마치 요리사가 다양한 도구를 이용해 재료를 손질하고 요리하는 것처럼, 개발자는 연산자를 이용해 데이터를 가공하고 프로그램의 흐름을 제어합니다.
<br><br>
이번 글에서는 자바 연산자의 핵심인 **타입 변환(Type Casting)**, **단항 연산자(Unary Operators)**, 그리고 \*\*이항 연산자(Binary Operators)\*\*를 중심으로 변수와 연산자가 어떻게 유기적으로 작용하는지 깊이 있게 탐구해 보겠습니다. 잘 이해한다면 여러분의 코드는 훨씬 더 유연하고 강력해질 것입니다\!

-----

## 변수의 타입 변환: 유연한 데이터 활용을 위한 필수 기술

자바는 각 변수에 고정된 데이터 타입을 부여하는 **정적 타입(Statically Typed)** 언어입니다. 이는 프로그램의 안정성을 높이는 장점이 있지만, 때로는 서로 다른 타입의 데이터 간에 연산을 수행해야 할 필요가 생깁니다. 이때 사용되는 것이 바로 \*\*형 변환(Type Casting)\*\*입니다.

형 변환은 크게 두 가지 방식으로 나뉩니다.

### 1\. ✅ 자동 형 변환 (묵시적 변환: Implicit Type Casting)

데이터 손실의 위험 없이 안전하게 변환될 수 있는 경우, 자바가 **자동으로** 타입을 변환해 줍니다. 이는 주로 **작은 크기의 타입에서 큰 크기의 타입으로 변환**되거나, **정수형에서 실수형으로 변환**될 때 발생합니다. 마치 작은 컵의 물을 더 큰 컵에 옮겨 담는 것과 같아서, 물이 넘치거나 손실될 염려가 없습니다.

```java
public class AutoCastingExample {
    public static void main(String[] args) {
        // 작은 크기의 정수형 -> 큰 크기의 정수형
        byte b = 10;
        int i = b; // byte(1 byte) -> int(4 bytes) 자동 변환
        System.out.println("byte -> int: " + i); // 출력: 10

        // 정수형 -> 실수형
        int j = 20;
        double d = j; // int(4 bytes) -> double(8 bytes) 자동 변환
        System.out.println("int -> double: " + d); // 출력: 20.0

        // char -> int (유니코드 값으로 변환)
        char c = 'A'; // 'A'의 유니코드 값은 65입니다.
        int charToInt = c; // char(2 bytes) -> int(4 bytes) 자동 변환
        System.out.println("char -> int: " + charToInt); // 출력: 65
    }
}
```

**자동 형 변환이 가능한 순서 (왼쪽에서 오른쪽으로 안전하게 변환):**

`byte` → `short` → `int` → `long` → `float` → `double`
`char` → `int`

### 2\. ❗ 강제 형 변환 (명시적 변환: Explicit Type Casting)

반대로, **큰 크기의 타입에서 작은 크기의 타입으로 변환**하거나, **실수형에서 정수형으로 변환**하는 경우에는 **데이터 손실의 가능성**이 존재합니다. 예를 들어, 큰 컵의 물을 작은 컵에 옮겨 담으면 물이 넘쳐서 손실될 수 있죠. 자바는 이러한 잠재적 위험 때문에 개발자에게 **명시적으로(`(타입)`) 변환을 지시**하도록 요구합니다.

```java
public class ForceCastingExample {
    public static void main(String[] args) {
        // 큰 크기 -> 작은 크기 (데이터 손실 가능)
        int i = 130;
        byte b = (byte) i; // int(130) -> byte(-126) 강제 변환, 오버플로우 발생!
                           // byte의 최대값은 127이므로 130은 표현할 수 없어 순환됩니다.
        System.out.println("int(130) -> byte: " + b); // 출력: -126

        // 실수 -> 정수 (소수점 이하 버림)
        double d = 3.14159;
        int j = (int) d; // double(3.14159) -> int(3) 강제 변환, 소수점 이하 버림
        System.out.println("double(3.14159) -> int: " + j); // 출력: 3

        // 주의! 정확한 실수 연산을 위해 정수 나눗셈 시 형 변환 활용
        int num1 = 10;
        int num2 = 3;
        // int / int는 정수 나눗셈 결과(3)를 반환합니다.
        double result1 = num1 / num2; 
        System.out.println("정수/정수 -> double: " + result1); // 출력: 3.0 (예상과 다를 수 있음!)

        // 해결책: 둘 중 하나를 실수형으로 변환하여 실수 나눗셈을 유도
        double result2 = (double) num1 / num2; 
        System.out.println("(double)int/int -> double: " + result2); // 출력: 3.3333333333333335
        
        // 또는 float 리터럴 사용
        double result3 = num1 / (num2 * 1.0);
        System.out.println("int/(int * 1.0) -> double: " + result3); // 출력: 3.3333333333333335
    }
}
```

> ⚠️ **핵심 주의사항:**
>
>   * **실수형을 정수형으로 강제 변환하면 소수점 이하가 '잘립니다'(truncation). 반올림되지 않습니다\!**
>   * 큰 타입에서 작은 타입으로 변환할 때는 \*\*오버플로우(overflow)\*\*나 \*\*언더플로우(underflow)\*\*가 발생하여 예상치 못한 값이 나올 수 있으니 항상 주의해야 합니다.

-----

## 단항 연산자 (Unary Operators): 한 번에 한 개의 피연산자\!

단항 연산자는 이름 그대로 **하나의 피연산자**에 대해 동작하는 연산자입니다. 간단하지만 매우 자주 사용되며, 코드의 간결성을 높이는 데 기여합니다.

### 1\. ➕ 부호 연산자

숫자의 부호를 변경하거나 유지합니다.

  * `+`: 피연산자의 부호를 그대로 유지합니다. (명시적 양수 표현)
  * `-`: 피연산자의 부호를 반전시킵니다.

<!-- end list -->

```java
int a = 5;
int b = -10;

int c = +a; // c는 5 (a의 부호 유지)
int d = -a; // d는 -5 (a의 부호 반전)
int e = -b; // e는 10 (b의 부호 반전)

System.out.println("c: " + c); // 출력: 5
System.out.println("d: " + d); // 출력: -5
System.out.println("e: " + e); // 출력: 10
```

### 2\. ⬆️ 증감 연산자 (`++`, `--`)

변수의 값을 **1만큼 증가시키거나 감소**시키는 연산자입니다. 코드를 매우 간결하게 만들어주어 반복문 등에서 유용하게 사용됩니다. 하지만 **전위(Prefix) 연산**과 **후위(Postfix) 연산**의 차이를 정확히 이해하는 것이 중요합니다.

  * `++`: 피연산자의 값을 1 증가시킵니다.
  * `--`: 피연산자의 값을 1 감소시킵니다.

| 연산자 위치 | 동작 방식                                                     | 예시 (`int x = 5;`) | 결과 (`x` 값 변화 / 반환 값) |
|-------------|---------------------------------------------------------------|---------------------|-----------------------------|
| **전위** (`++x`, `--x`) | **먼저 값을 변경한 후**, 그 변경된 값을 연산 결과로 사용합니다. | `int y = ++x;`      | `x`는 6, `y`는 6            |
| **후위** (`x++`, `x--`) | **현재 값을 연산 결과로 사용한 후**, 다음 줄에서 값을 변경합니다. | `int y = x++;`      | `x`는 6, `y`는 5            |

**코드 예시를 통해 명확히 이해하기:**

```java
public class IncrementDecrementExample {
    public static void main(String[] args) {
        int a = 5;
        int b = 5;

        // 후위 연산: a의 현재 값(5)을 result1에 대입 -> a를 1 증가(6)
        int result1 = a++; 
        System.out.println("result1 (a++): " + result1); // 출력: 5
        System.out.println("a (after a++): " + a);       // 출력: 6

        System.out.println("--------------------");

        // 전위 연산: b를 1 증가(6) -> 증가된 b의 값(6)을 result2에 대입
        int result2 = ++b; 
        System.out.println("result2 (++b): " + result2); // 출력: 6
        System.out.println("b (after ++b): " + b);       // 출력: 6

        System.out.println("--------------------");

        int x = 10;
        int y = 10;
        System.out.println("x--: " + (x--)); // 출력: 10 (먼저 10 출력 후 x는 9로 감소)
        System.out.println("x after x--: " + x); // 출력: 9

        System.out.println("--y: " + (--y)); // 출력: 9 (먼저 y를 9로 감소 후 9 출력)
        System.out.println("y after --y: " + y); // 출력: 9
    }
}
```

**실행 결과:**

```
result1 (a++): 5
a (after a++): 6
--------------------
result2 (++b): 6
b (after ++b): 6
--------------------
x--: 10
x after x--: 9
--y: 9
y after --y: 9
```

증감 연산자의 전위/후위 차이는 실제 코딩에서 혼란을 줄 수 있으므로, 어떤 상황에서 어떤 연산자를 사용해야 할지 신중하게 결정해야 합니다. 복잡한 수식 내부에서 사용하기보다는, 단독으로 변수 값을 증감할 때 사용하는 것이 가독성에 좋습니다.

### 3\. ❗ 논리 부정 연산자 (`!`)

`boolean` 타입의 값을 `true`는 `false`로, `false`는 `true`로 반전시킵니다. 조건문에서 특정 조건이 '아닌' 경우를 표현할 때 유용합니다.

```java
boolean isMorning = true;
System.out.println("아침인가? " + isMorning);       // 출력: 아침인가? true
System.out.println("아침이 아닌가? " + !isMorning); // 출력: 아침이 아닌가? false

boolean isEmpty = false;
System.out.println("비어있지 않은가? " + !isEmpty); // 출력: 비어있지 않은가? true
```

-----

## 이항 연산자 (Binary Operators): 두 피연산자의 조합

이항 연산자는 **두 개의 피연산자**를 가지고 연산을 수행하는 연산자입니다. 가장 흔하게 볼 수 있는 연산 형태이며, 프로그램의 핵심 로직을 구성하는 데 필수적입니다.

### 1\. ➗ 산술 연산자

덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 연산 등 기본적인 수학 연산을 수행합니다.

| 연산자 | 기능 | 예시 (`a = 10`, `b = 3`) | 결과 | 비고 |
|---|---|---|---|---|
| `+` | 덧셈 | `a + b` | `13` | |
| `-` | 뺄셈 | `a - b` | `7` | |
| `*` | 곱셈 | `a * b` | `30` | |
| `/` | 나눗셈 | `a / b` | `3` | **정수 / 정수 = 정수 (소수점 버림)** |
| `%` | 나머지 | `a % b` | `1` | 나눗셈 후 남은 나머지 값 |

**정수 나눗셈의 함정:**

앞서 타입 변환에서 잠깐 다루었지만, 정수형 변수끼리의 나눗셈(`int / int`)은 그 결과 또한 정수형이 되며, 소수점 이하는 무조건 버려집니다. (반올림 X)

```java
int totalStudents = 27;
int classSize = 5;

int numberOfClasses = totalStudents / classSize; 
System.out.println("필요한 반의 수 (정수 나눗셈): " + numberOfClasses); // 출력: 5 (실제로는 5.4 이므로 6반이 필요)

// 정확한 나눗셈을 원한다면
double preciseResult = (double) totalStudents / classSize;
System.out.println("정확한 반의 수 (실수 나눗셈): " + preciseResult); // 출력: 5.4

// 혹은 한쪽에 1.0을 곱해주어 실수 연산을 유도
double anotherPreciseResult = totalStudents / (classSize * 1.0);
System.out.println("다른 정확한 반의 수: " + anotherPreciseResult); // 출력: 5.4
```

### 2\. 🔗 문자열 연결 연산자 (`+`)

`+` 연산자는 숫자에 사용되면 덧셈을 수행하지만, 피연산자 중 하나라도 `String` 타입이면 **문자열 연결(Concatenation)** 기능으로 동작합니다. 이는 자바의 유연성을 보여주는 특징 중 하나입니다.

```java
String firstName = "홍";
String lastName = "길동";
String fullName = firstName + lastName; // 문자열 + 문자열
System.out.println("이름: " + fullName); // 출력: 이름: 홍길동

int year = 2024;
String message = "현재 연도: " + year; // 문자열 + 정수
System.out.println(message); // 출력: 현재 연도: 2024

double price = 1500.50;
String itemInfo = "상품 가격: " + price + "원"; // 문자열 + 실수 + 문자열
System.out.println(itemInfo); // 출력: 상품 가격: 1500.50원

// 연산 순서에 주의!
System.out.println("총합: " + 10 + 20); // 출력: 총합: 1020 (문자열 연결)
System.out.println("총합: " + (10 + 20)); // 출력: 총합: 30 (괄호 안이 먼저 계산)
```

`System.out.println`에서 흔히 볼 수 있는 패턴으로, 다양한 타입의 변수를 문자열과 함께 출력할 때 매우 편리하게 사용됩니다. 단, **연산 순서**에 따라 결과가 달라질 수 있으므로 괄호를 적절히 사용하여 원하는 연산이 먼저 수행되도록 해야 합니다.

-----

## 📌 요약 정리: 연산자 사용의 핵심

  * **타입 변환**:
      * **자동 형 변환**: 작은 타입 → 큰 타입 (데이터 손실 없음)
      * **강제 형 변환**: 큰 타입 → 작은 타입 (데이터 손실 가능, `(타입)` 명시 필수\!)
      * **정수 나눗셈** 시 소수점 버림에 주의하고, 필요 시 실수형으로 명시적 변환\!
  * **단항 연산자**:
      * **부호 연산자** (`+`, `-`): 숫자의 부호 조절
      * **증감 연산자** (`++`, `--`): 값을 1 증가/감소. **전위/후위 차이**를 반드시 이해\!
      * **논리 부정 연산자** (`!`): `boolean` 값을 반전
  * **이항 연산자**:
      * **산술 연산자** (`+`, `-`, `*`, `/`, `%`): 기본적인 수학 연산
      * **문자열 연결 연산자** (`+`): 피연산자 중 하나라도 `String`이면 문자열을 연결
  * **연산자 우선순위**와 **괄호 사용**을 항상 고려하여 코드를 작성하는 습관을 들이세요\!

-----

## 💡 연산자 퀴즈: 예상치 못한 문자열 연결\!

```java
public class Quiz {
    public static void main(String[] args) {
        int a = 3;
        int b = 4;
        System.out.println("합계는: " + a + b);
    }
}
```

위 Java 코드의 출력 결과는 무엇일까요? 이전에 배운 문자열 연결 연산자의 규칙을 떠올려 보세요\!

<details>
    <summary>정답 보기</summary>
<br>
정답은 `"합계는: 34"` 입니다.
<br><br>
설명:
<br>
자바의 `+` 연산자는 다음과 같은 우선순위를 따릅니다.
<br>
1.  `"합계는: "` (문자열)과 `a` (정수)가 만나면, `+` 연산자는 **문자열 연결 연산자**로 동작합니다.
      * `"합계는: " + a` $\\rightarrow$ `"합계는: 3"`<br><br>
2.  이어서 `"합계는: 3"` (문자열)과 `b` (정수)가 다시 만나면, 또다시 **문자열 연결 연산자**로 동작합니다.
      * `"합계는: 3" + b` $\\rightarrow$ `"합계는: 34"`
<br>
따라서, 산술 덧셈이 아닌 문자열 결합이 일어난 것이므로 출력 결과는 34가 됩니다. 만약 덧셈을 원했다면, `"합계는: " + (a + b)` 와 같이 괄호를 사용하여 산술 연산의 우선순위를 높여주어야 합니다.

</details>

-----

## 마치며: 변수와 연산자, 개발의 첫걸음이자 핵심\!

이번 글에서는 자바에서 데이터를 다루고 가공하는 데 필수적인 **타입 변환**과 **연산자**에 대해 상세히 살펴보았습니다. 변수가 데이터를 담는 그릇이라면, 연산자는 이 그릇 안의 데이터를 목적에 맞게 '요리'하는 도구라고 할 수 있습니다.

특히 **증감 연산자의 전위/후위 차이**나, **문자열 연결 시의 `+` 연산자 동작 방식**은 초기에는 혼란을 줄 수 있지만, 정확한 원리를 이해하고 코드를 작성하는 습관을 들이는 것이 중요합니다. 이러한 기본기가 탄탄해야 복잡한 로직도 명확하고 오류 없이 구현할 수 있습니다.

변수와 연산자의 개념은 자바를 포함한 대부분의 프로그래밍 언어에서 공통적으로 사용되는 매우 중요한 기초입니다. 이 두 가지를 자유자재로 다룰 수 있게 된다면, 여러분의 코딩 능력은 한 단계 더 성장할 것입니다.

다음 글에서는 더 다양한 연산자들, 예를 들어 **비교 연산자, 논리 연산자, 대입 연산자** 등을 다루며 프로그램의 흐름을 제어하는 방법에 대해 알아보겠습니다.

---



