<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://loremipsum0116.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://loremipsum0116.github.io/" rel="alternate" type="text/html" /><updated>2025-06-25T06:13:19+00:00</updated><id>https://loremipsum0116.github.io/feed.xml</id><title type="html">Lorem Tech Blog</title><subtitle>Backend-related tech blog.</subtitle><author><name>Lorem</name><email>loremipsum0115@gmail.com</email></author><entry xml:lang="ko"><title type="html">자바 쓰레드: 프로그램, 프로세스 그리고 동시성</title><link href="https://loremipsum0116.github.io/ko/java-threads/" rel="alternate" type="text/html" title="자바 쓰레드: 프로그램, 프로세스 그리고 동시성" /><published>2025-06-25T06:00:21+00:00</published><updated>2025-06-25T06:00:21+00:00</updated><id>https://loremipsum0116.github.io/ko/java-threads</id><content type="html" xml:base="https://loremipsum0116.github.io/ko/java-threads/"><![CDATA[<h2 id="자바-쓰레드-프로그램-프로세스-그리고-동시성">자바 쓰레드: 프로그램, 프로세스 그리고 동시성</h2>

<p>현대 소프트웨어는 대부분 여러 작업을 동시에 처리할 수 있는 능력을 요구합니다. 웹 브라우저에서 여러 탭을 열고 동시에 사용할 수 있거나, 워드 프로세서에서 문서를 편집하면서 동시에 맞춤법 검사를 수행하는 것 등이 그 예시입니다. 이러한 동시성(Concurrency) 또는 병렬성(Parallelism)을 구현하는 데 핵심적인 역할을 하는 것이 바로 <strong>쓰레드(Thread)</strong> 입니다.</p>

<p>이번 글에서는 프로그램이 실행되기까지의 과정을 <strong>프로그램</strong>, <strong>프로세스</strong>, 그리고 <strong>쓰레드</strong>의 개념을 통해 이해하고, 자바 환경에서의 쓰레드 동작 방식과 <strong>멀티 쓰레드</strong>의 필요성에 대해 자세히 알아보겠습니다. 또한, 여러 쓰레드가 공유 자원에 접근할 때 발생할 수 있는 문제점을 해결하기 위한 <strong>쓰레드 동기화</strong> 기법까지 심도 있게 다룰 것입니다.</p>

<hr />

<h2 id="프로그램-프로세스-쓰레드의-개념">프로그램, 프로세스, 쓰레드의 개념</h2>

<p>소프트웨어는 단순히 코드가 아니라, 컴퓨터 하드웨어와 상호작용하며 동작하는 복잡한 체계입니다. 이 관계를 이해하려면 ‘프로그램’, ‘프로세스’, ‘쓰레드’ 세 가지 핵심 개념을 알아야 합니다.</p>

<h3 id="-프로그램과-프로세스의-개념">✅ 프로그램과 프로세스의 개념</h3>

<p>컴퓨터의 주요 하드웨어인 **CPU(중앙처리장치)**와 <strong>하드디스크</strong>는 역할과 속도 면에서 큰 차이를 보입니다.</p>

<ul>
  <li><strong>CPU</strong>: 연산을 수행하며 실제 프로그램을 실행하는 장치로, 가장 빠른 속도로 동작합니다.</li>
  <li><strong>하드디스크</strong>: 데이터의 저장 역할을 수행하며, CPU에 비해 상대적으로 낮은 속도로 동작합니다.</li>
</ul>

<p>CPU와 하드디스크는 엄청난 속도 차이 때문에 직접적으로 효율적인 대화가 어렵습니다. 이 간극을 메우는 것이 바로 <strong>메모리</strong>의 역할입니다. 메모리는 CPU보다 느리지만, 거의 근접한 속도로 데이터를 주고받을 수 있습니다.</p>

<p>실제 하드디스크에 저장된 프로그램이 실행되기 위해서는 먼저 프로그램을 메모리로 로딩하는 과정을 거쳐야 합니다. 이 과정이 완료되면 프로그램은 <strong>프로세스</strong> 상태가 됩니다.</p>

<p><strong>정리:</strong></p>

<ul>
  <li><strong>프로그램</strong>: 하드디스크에 저장된 <strong>파일의 모임</strong> (예: <code class="language-plaintext highlighter-rouge">.exe</code> 파일, <code class="language-plaintext highlighter-rouge">.jar</code> 파일). 아직 실행되지 않은 상태의 코드와 데이터.</li>
  <li><strong>프로세스</strong>: 메모리상에 <strong>로딩되어 실행 대기 또는 실행 중인 프로그램</strong>의 인스턴스. 운영체제로부터 독립적인 메모리 공간과 자원(CPU 시간, 파일 등)을 할당받습니다.</li>
</ul>

<h3 id="-쓰레드의-개념">✅ 쓰레드의 개념</h3>

<p>진정으로 CPU를 사용하여 실제 연산을 수행하는 것은 <strong>프로세스 내부의 쓰레드</strong>입니다.</p>

<ul>
  <li>모든 프로세스는 최소한 1개의 쓰레드를 가집니다.</li>
  <li><strong>쓰레드</strong>: 프로세스 내에서 CPU를 사용하는 <strong>최소 실행 단위</strong>입니다. 하나의 프로세스는 여러 개의 쓰레드를 가질 수 있으며, 이 쓰레드들은 프로세스의 자원(메모리 등)을 공유합니다.</li>
</ul>

<hr />

<h2 id="자바-프로그램에서의-쓰레드">자바 프로그램에서의 쓰레드</h2>

<p>자바로 작성된 프로그램을 실행하면, 해당 <code class="language-plaintext highlighter-rouge">.class</code> 파일은 JVM(Java Virtual Machine)에 의해 메모리로 로딩되어 하나의 프로세스 상태가 됩니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.class</code> 파일을 실행하면 JVM은 자동으로 <strong>main 쓰레드</strong>를 생성합니다.</li>
  <li>우리가 <code class="language-plaintext highlighter-rouge">main()</code> 메소드에 작성한 모든 코드는 바로 이 <code class="language-plaintext highlighter-rouge">main</code> 쓰레드에서 동작합니다.</li>
</ul>

<h3 id="-멀티-쓰레드의-필요성">✅ 멀티 쓰레드의 필요성</h3>

<p>멀티 쓰레드는 <strong>2개 이상의 작업을 동시에 수행</strong>하기 위해 필요합니다.</p>

<p><strong>단일 쓰레드 처리:</strong></p>

<ul>
  <li>멀티 쓰레드를 사용하지 않을 때, 즉 단일 쓰레드로 2개의 작업을 처리할 경우, 각 작업은 <strong>순차적으로 처리</strong>됩니다.</li>
  <li>먼저 시작된 작업이 완전히 종료된 이후에야 두 번째 작업이 실행됩니다. 이는 작업 완료까지의 총 시간이 길어지고, 응답성이 떨어질 수 있습니다.</li>
</ul>

<p><strong>멀티 쓰레드의 동시성(Concurrency)과 병렬성(Parallelism):</strong></p>

<ul>
  <li><strong>동시성 (Concurrency)</strong>: 처리할 작업의 수가 CPU의 코어 수보다 많을 때 발생합니다. 이때 CPU는 각 작업 쓰레드의 요청 작업을 매우 짧은 간격으로 <strong>번갈아가면서(Context Switching)</strong> 실행합니다. 사용자 입장에서는 두 작업이 마치 동시에 실행되는 것처럼 보입니다. 정확히 이야기하면, 두 작업이 동시에 실행되는 것이 아니라 동시에 실행되는 것처럼 보이도록 하는 방식입니다.</li>
  <li><strong>병렬성 (Parallelism)</strong>: CPU의 코어 수가 작업 수보다 많을 때는 각각의 작업을 각각의 코어에 할당하여 <strong>실제로 동시에 실행</strong>할 수 있습니다. 이를 병렬성이라고 합니다.</li>
</ul>

<p><strong>예시:</strong></p>

<ul>
  <li>만약 작업 수가 6개이고, CPU 코어가 2개라면?
    <ul>
      <li>쓰레드의 <strong>동시성과 병렬성</strong>이 함께 작용합니다.</li>
      <li>작업은 2개의 코어에 나뉘어 할당되고(병렬성), 각각의 코어는 할당된 작업들을 번갈아 실행합니다(동시성).</li>
    </ul>
  </li>
</ul>

<p><strong>멀티 쓰레드의 궁극적인 목적은 병렬성과 동시성을 활용하여 여러 작업을 실제로 동시에 실행하거나, 동시에 실행하는 것처럼 보이게 하여 시스템의 효율성과 응답성을 높이는 것입니다.</strong></p>

<hr />

<h2 id="쓰레드의-동기화">쓰레드의 동기화</h2>

<p>여러 쓰레드가 동시에 동작할 때, 공통된 자원(데이터, 파일 등)에 접근하게 되면 예상치 못한 문제가 발생할 수 있습니다. 이를 해결하기 위해 **동기화(Synchronization)**가 필요합니다.</p>

<h3 id="-동기화의-개념">✅ 동기화의 개념</h3>

<p><strong>동기화</strong>: 여러 쓰레드가 동시에 <strong>공유 자원</strong>에 접근할 때 데이터의 일관성과 무결성을 보장하기 위해, 한 번에 하나의 쓰레드만 공유 자원(임계 영역)에 접근하도록 <strong>접근을 제어하는 것</strong>입니다.</p>

<ul>
  <li><strong>↔ 비동기</strong>: 하나의 작업 명령 이후 완료 여부와 상관없이 바로 다른 작업 명령을 수행하는 것을 의미합니다.</li>
</ul>

<h3 id="-동기화의-필요성">✅ 동기화의 필요성</h3>

<p>여러 쓰레드가 동시에 같은 데이터(공유 자원)에 접근하여 값을 변경할 경우, 쓰레드 스케줄링 순서에 따라 **예상치 못한 결과(데이터 불일치)**가 나올 수 있습니다.
이를 방지하기 위해 <strong>한 쓰레드가 공유 객체를 모두 사용해야만 다음 쓰레드가 해당 객체를 사용할 수 있도록 설정</strong>하는 것이 동기화의 목적입니다.</p>

<h3 id="-동기화-방법">✅ 동기화 방법</h3>

<p>자바에서 쓰레드를 동기화하는 대표적인 방법은 <code class="language-plaintext highlighter-rouge">synchronized</code> 키워드를 사용하는 것입니다.</p>

<ol>
  <li>
    <p><strong>메서드 동기화 (Synchronized Method)</strong>:</p>

    <ul>
      <li>메소드의 리턴 타입 앞에 <code class="language-plaintext highlighter-rouge">synchronized</code> 키워드를 붙이면 됩니다.</li>
      <li>해당 메소드가 호출되면, 메소드를 포함하는 객체의 잠금(lock)을 얻게 되므로, 이 메소드가 실행되는 동안 다른 쓰레드는 같은 객체의 <code class="language-plaintext highlighter-rouge">synchronized</code> 메소드에 접근할 수 없습니다.</li>
    </ul>

    <!-- end list -->

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SynchronizedExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="c1">// 메소드 전체를 동기화</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">count</span><span class="o">++;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">count</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SynchronizedExample</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SynchronizedExample</span><span class="o">();</span>

        <span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">obj</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="nc">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="s">"쓰레드-1"</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="s">"쓰레드-2"</span><span class="o">);</span>

        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>블록 동기화 (Synchronized Block)</strong>:</p>

    <ul>
      <li>메소드 전체가 아니라 메소드 내의 특정 코드 블록만 동기화가 필요한 경우에 사용합니다.</li>
      <li><code class="language-plaintext highlighter-rouge">synchronized(this)</code> 또는 <code class="language-plaintext highlighter-rouge">synchronized(someObject)</code> 형태로 사용하며, 괄호 안에는 잠금을 얻을 객체(모니터)를 지정합니다. <code class="language-plaintext highlighter-rouge">this</code>는 현재 객체를 의미합니다.</li>
    </ul>

    <!-- end list -->

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SynchronizedBlockExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span> <span class="c1">// 동기화에 사용할 객체</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 특정 블록만 동기화</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 'lock' 객체의 잠금을 얻음</span>
            <span class="n">count</span><span class="o">++;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">count</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 이 블록 밖의 코드는 동기화되지 않음</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SynchronizedBlockExample</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SynchronizedBlockExample</span><span class="o">();</span>

        <span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">obj</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="nc">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="s">"쓰레드-A"</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="s">"쓰레드-B"</span><span class="o">);</span>

        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><strong>쓰레드란?</strong>
결론적으로, 쓰레드는 애플리케이션이 실행하는 독립적이고 순차적인 명령어들의 집합입니다. 모든 프로세스는 동시에 실행될 수 있는 다수의 쓰레드를 가질 수 있으며, 이는 앱에서 여러 태스크를 병렬로 실행할 수 있게 하여 동시성을 다루는 프로그래밍 언어에서 필수적인 구성 요소입니다.</p>

<hr />

<h3 id="-요약-정리-자바-쓰레드">📌 요약 정리: 자바 쓰레드</h3>

<table>
  <thead>
    <tr>
      <th>요소</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>프로그램</strong></td>
      <td>하드디스크에 저장된 코드와 데이터의 집합. 실행되기 전의 상태.</td>
    </tr>
    <tr>
      <td><strong>프로세스</strong></td>
      <td>메모리에 로딩되어 실행 중인 프로그램의 인스턴스. 운영체제로부터 독립적인 자원 할당.</td>
    </tr>
    <tr>
      <td><strong>쓰레드</strong></td>
      <td>프로세스 내에서 CPU를 사용하는 <strong>최소 실행 단위</strong>. 프로세스의 자원을 공유하며, 모든 프로세스는 최소 1개의 쓰레드를 가짐.</td>
    </tr>
    <tr>
      <td><strong>main 쓰레드</strong></td>
      <td>자바 프로그램 실행 시 JVM에 의해 자동 생성되며, <code class="language-plaintext highlighter-rouge">main()</code> 메소드 코드를 실행.</td>
    </tr>
    <tr>
      <td><strong>멀티 쓰레드</strong></td>
      <td>2개 이상의 쓰레드를 동시에(또는 동시에처럼 보이게) 실행하여 작업 효율성과 응답성을 높이는 기법.</td>
    </tr>
    <tr>
      <td><strong>동시성 (Concurrency)</strong></td>
      <td>여러 작업이 짧은 시간 간격으로 번갈아 실행되며 동시에 실행되는 것처럼 보이는 것. (단일 코어에서 여러 작업)</td>
    </tr>
    <tr>
      <td><strong>병렬성 (Parallelism)</strong></td>
      <td>여러 작업이 실제로 동시에 실행되는 것. (멀티 코어에서 각 코어에 작업 할당)</td>
    </tr>
    <tr>
      <td><strong>쓰레드 동기화</strong></td>
      <td>여러 쓰레드가 공유 자원에 동시에 접근할 때 데이터 일관성/무결성 보장을 위해 접근을 제어하는 것.</td>
    </tr>
    <tr>
      <td><strong>동기화 방법</strong></td>
      <td><code class="language-plaintext highlighter-rouge">synchronized</code> 키워드를 사용한 <strong>메소드 동기화</strong> 또는 <strong>블록 동기화</strong>. &lt;br&gt; (메소드 전체 잠금 vs 특정 코드 블록만 잠금)</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-쓰레드-개념-퀴즈">💡 쓰레드 개념 퀴즈</h3>

<p>다음 상황을 읽고, 설명에 해당하는 개념이 무엇인지 맞춰보세요.</p>

<p>“사용자가 웹 브라우저에서 유튜브 영상을 시청하면서 동시에 다른 탭에서 뉴스 기사를 스크롤하고 있습니다. 이 두 가지 활동이 겉보기에는 동시에 이루어지는 것처럼 보이지만, 실제 CPU 코어는 하나뿐이어서 매우 빠르게 두 작업을 번갈아가며 처리하고 있습니다.”</p>

<p>이 설명은 쓰레드의 어떤 특성을 가장 잘 나타내는 것일까요?</p>

<details>
<summary>정답 보기</summary>
<br />
정답은: 동시성 (Concurrency)
<br />
설명:<br />
이 시나리오는 단일 CPU 코어가 여러 작업을 빠르게 전환하며 처리함으로써, 사용자에게는 마치 여러 작업이 동시에 진행되는 것처럼 보이는 현상을 설명하고 있습니다. 이는 멀티 쓰레딩의 핵심 이점 중 하나인 동시성을 잘 보여주는 예시입니다. 병렬성은 여러 코어가 실제로 동시에 작업을 처리하는 상황을 의미합니다.
</details>

<hr />

<h3 id="-마치며-동시성-프로그래밍의-이해">🔚 마치며: 동시성 프로그래밍의 이해</h3>

<p>이번 글에서는 자바 프로그래밍에서 매우 중요한 개념인 <strong>쓰레드</strong>에 대해 깊이 있게 다루었습니다. 프로그램이 프로세스가 되고, 그 안에 쓰레드가 실제 실행의 최소 단위가 되는 과정을 이해하는 것은 운영체제와 자바 애플리케이션의 동작 방식을 이해하는 데 필수적입니다. 또한, 멀티 쓰레드가 어떻게 동시성과 병렬성을 활용하여 시스템의 효율성을 높이는지, 그리고 공유 자원 접근 시 발생할 수 있는 문제를 해결하기 위한 <strong>동기화</strong>의 중요성과 방법에 대해서도 살펴보았습니다.</p>

<p>멀티 쓰레딩은 복잡성을 증가시킬 수 있지만, 잘 활용하면 애플리케이션의 성능과 사용자 경험을 크게 향상시킬 수 있습니다.</p>]]></content><author><name>Lorem</name><email>loremipsum0115@gmail.com</email></author><category term="java" /><summary type="html"><![CDATA[자바 쓰레드: 프로그램, 프로세스 그리고 동시성]]></summary></entry><entry xml:lang="ko"><title type="html">자바 핵심 클래스 및 객체 동등 비교</title><link href="https://loremipsum0116.github.io/ko/java-oop-detail/" rel="alternate" type="text/html" title="자바 핵심 클래스 및 객체 동등 비교" /><published>2025-06-25T05:47:51+00:00</published><updated>2025-06-25T05:47:51+00:00</updated><id>https://loremipsum0116.github.io/ko/java-oop-detail</id><content type="html" xml:base="https://loremipsum0116.github.io/ko/java-oop-detail/"><![CDATA[<hr />

<h2 id="자바-핵심-클래스-object와-유용한-유틸리티-클래스">자바 핵심 클래스: <code class="language-plaintext highlighter-rouge">Object</code>와 유용한 유틸리티 클래스</h2>

<p>지금까지 자바의 기본 문법과 배열과 같은 데이터 구조를 살펴보았습니다. 이제 모든 자바 클래스의 조상인 <strong><code class="language-plaintext highlighter-rouge">java.lang.Object</code></strong> 클래스의 중요한 역할과, 객체지향 프로그래밍에서 필수적인 <strong>객체 동등 비교</strong> 방법에 대해 심도 있게 알아보겠습니다. 또한, 기본 타입을 객체로 다루게 해주는 <strong>포장(Wrapper) 클래스</strong>, 수학 연산을 위한 <code class="language-plaintext highlighter-rouge">Math</code> 클래스, 그리고 날짜와 시간을 처리하는 클래스까지 자바 프로그래밍에 유용한 핵심 클래스들을 함께 다룰 것입니다.</p>

<p>객체지향의 근간을 이루는 객체 간의 관계와 동작 방식을 이해하는 것은 효과적인 자바 애플리케이션 개발의 핵심입니다.</p>

<hr />

<h2 id="javalangobject-모듈-모든-클래스의-조상"><code class="language-plaintext highlighter-rouge">java.lang.Object</code> 모듈: 모든 클래스의 조상</h2>

<p><code class="language-plaintext highlighter-rouge">java.lang.Object</code> 클래스는 자바의 모든 클래스가 명시적으로 상속받지 않아도 <strong>자동으로 상속받는 최상위 클래스</strong>입니다. 따라서 모든 객체는 <code class="language-plaintext highlighter-rouge">Object</code> 클래스에 정의된 메소드들을 사용할 수 있습니다. 이 중 가장 중요한 메소드들은 객체의 동등성을 비교하거나 객체를 문자열로 표현할 때 사용됩니다.</p>

<h3 id="-객체-동등-비교-hashcode와-equals">✅ 객체 동등 비교: <code class="language-plaintext highlighter-rouge">hashCode()</code>와 <code class="language-plaintext highlighter-rouge">equals()</code></h3>

<p>객체지향 프로그래밍에서 두 객체가 ‘같은지’를 판단하는 것은 매우 중요합니다. 자바에서 객체의 동등성 비교는 크게 두 가지 방법으로 이루어집니다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">==</code> 연산자</strong>: 두 변수가 <strong>동일한 객체(동일한 메모리 주소)</strong>를 참조하는지를 비교합니다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">equals()</code> 메소드</strong>: 두 객체의 <strong>내용(값)이 동일한지</strong>를 비교합니다. 기본적으로 <code class="language-plaintext highlighter-rouge">Object</code> 클래스의 <code class="language-plaintext highlighter-rouge">equals()</code>는 <code class="language-plaintext highlighter-rouge">==</code>와 동일하게 주소를 비교하지만, 대부분의 클래스에서는 이 메소드를 재정의하여 객체의 논리적 동등성을 판단합니다.</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">hashCode()</code>와 <code class="language-plaintext highlighter-rouge">equals()</code>의 관계:</strong></p>

<p>자바 컬렉션 프레임워크(특히 <code class="language-plaintext highlighter-rouge">HashSet</code>, <code class="language-plaintext highlighter-rouge">HashMap</code> 등)에서 객체를 저장하거나 검색할 때 <code class="language-plaintext highlighter-rouge">hashCode()</code>와 <code class="language-plaintext highlighter-rouge">equals()</code> 메소드를 함께 사용합니다. 중요한 규칙은 다음과 같습니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">hashCode()</code> 값이 같은 두 객체는 <code class="language-plaintext highlighter-rouge">equals()</code> 메소드가 <code class="language-plaintext highlighter-rouge">true</code>를 반환할 <strong>필요는 없습니다.</strong> (서로 다른 객체라도 해시 충돌로 인해 <code class="language-plaintext highlighter-rouge">hashCode()</code>가 같을 수 있습니다.)</li>
  <li><strong><code class="language-plaintext highlighter-rouge">equals()</code> 메소드가 <code class="language-plaintext highlighter-rouge">true</code>를 반환하는 두 객체는 반드시 <code class="language-plaintext highlighter-rouge">hashCode()</code> 값도 같아야 합니다.</strong> (만약 그렇지 않으면 <code class="language-plaintext highlighter-rouge">Set</code>에 동일한 객체가 두 번 저장되거나 <code class="language-plaintext highlighter-rouge">Map</code>에서 객체를 찾지 못하는 문제가 발생할 수 있습니다.)</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ObjectEqualityExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">str3</span> <span class="o">=</span> <span class="n">str1</span><span class="o">;</span> <span class="c1">// 같은 객체를 참조</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str1 == str2: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">str1</span> <span class="o">==</span> <span class="n">str2</span><span class="o">));</span> <span class="c1">// false (다른 객체)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str1.equals(str2): "</span> <span class="o">+</span> <span class="n">str1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">str2</span><span class="o">));</span> <span class="c1">// true (내용 동일)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str1.hashCode(): "</span> <span class="o">+</span> <span class="n">str1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str2.hashCode(): "</span> <span class="o">+</span> <span class="n">str2</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str1 == str3: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">str1</span> <span class="o">==</span> <span class="n">str3</span><span class="o">));</span> <span class="c1">// true (동일 객체)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str1.equals(str3): "</span> <span class="o">+</span> <span class="n">str1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">str3</span><span class="o">));</span> <span class="c1">// true (내용 동일)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>출력 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>str1 == str2: false
str1.equals(str2): true
str1.hashCode(): 99162322
str2.hashCode(): 99162322
str1 == str3: true
str1.equals(str3): true
</code></pre></div></div>

<hr />

<h3 id="-객체-정의-패턴-pojo-클래스-설계의-기초">✅ 객체 정의 패턴 (POJO): 클래스 설계의 기초</h3>

<p>자바에서 일반적인 객체를 정의할 때는 다음과 같은 패턴을 따르는 경우가 많습니다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">private</code> 인스턴스 변수</strong>: 객체의 **상태(데이터)**를 저장하는 변수들은 일반적으로 외부에서 직접 접근할 수 없도록 <code class="language-plaintext highlighter-rouge">private</code> 접근 제한자를 사용합니다. 이는 객체 지향의 <strong>캡슐화(Encapsulation)</strong> 원칙을 따르는 것입니다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">getter</code>, <code class="language-plaintext highlighter-rouge">setter</code> 메소드 정의</strong>: <code class="language-plaintext highlighter-rouge">private</code> 변수에 안전하게 접근하고 값을 변경할 수 있도록 <code class="language-plaintext highlighter-rouge">public</code> 메소드인 <code class="language-plaintext highlighter-rouge">getter</code> (값을 가져옴)와 <code class="language-plaintext highlighter-rouge">setter</code> (값을 설정함)를 정의합니다.</li>
  <li><strong>필드 생성자 (All-args Constructor)</strong>: 객체를 생성할 때 모든 필드의 값을 초기화할 수 있는 생성자입니다.</li>
  <li><strong>기본 생성자 (No-args Constructor)</strong>: 매개변수가 없는 생성자로, 객체를 기본 상태로 생성할 때 사용됩니다. 필드 생성자와 함께 오버로딩하여 제공될 수 있습니다.</li>
</ul>

<!-- end list -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
    <span class="c1">// private 인스턴스 변수 (필드)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">stock</span><span class="o">;</span> <span class="c1">// 재고 수량 (자주 변하는 값)</span>

    <span class="c1">// 기본 생성자</span>
    <span class="kd">public</span> <span class="nf">Product</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 기본 초기화 로직 (선택 사항)</span>
    <span class="o">}</span>

    <span class="c1">// 필드 생성자</span>
    <span class="kd">public</span> <span class="nf">Product</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">price</span><span class="o">,</span> <span class="kt">int</span> <span class="n">stock</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">price</span> <span class="o">=</span> <span class="n">price</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">stock</span> <span class="o">=</span> <span class="n">stock</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// getter 메소드</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getPrice</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">price</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getStock</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">stock</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// setter 메소드</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setPrice</span><span class="o">(</span><span class="kt">int</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">price</span> <span class="o">=</span> <span class="n">price</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setStock</span><span class="o">(</span><span class="kt">int</span> <span class="n">stock</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">stock</span> <span class="o">=</span> <span class="n">stock</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// toString() 메소드 재정의 (Object 클래스로부터 상속)</span>
    <span class="c1">// 객체의 상태를 문자열로 쉽게 확인할 수 있도록 합니다.</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Product{"</span> <span class="o">+</span>
               <span class="s">"name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span>
               <span class="s">", price="</span> <span class="o">+</span> <span class="n">price</span> <span class="o">+</span>
               <span class="s">", stock="</span> <span class="o">+</span> <span class="n">stock</span> <span class="o">+</span>
               <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// hashCode() 및 equals() 메소드 재정의 (Object 클래스로부터 상속)</span>
    <span class="c1">// 객체의 논리적 동등성을 판단할 때 사용됩니다.</span>
    <span class="c1">// 자주 변하는 값(예: stock)은 equals/hashCode 비교에서 제외하는 것이 일반적입니다.</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Product</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">price</span> <span class="o">==</span> <span class="n">product</span><span class="o">.</span><span class="na">price</span> <span class="o">&amp;&amp;</span> <span class="c1">// price는 비교에 포함</span>
               <span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">name</span><span class="o">);</span> <span class="c1">// name은 비교에 포함</span>
               <span class="c1">// stock은 자주 변하는 값이므로 equals 비교에서 제외하는 경우가 많음</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// name과 price를 기반으로 해시코드 생성</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="n">price</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="c1">// stock은 hashCode 계산에서 제외하는 경우가 많음</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="string-클래스-주요-메소드"><code class="language-plaintext highlighter-rouge">String</code> 클래스 주요 메소드</h2>

<p>자바의 문자열(<code class="language-plaintext highlighter-rouge">String</code>)은 불변(immutable) 객체이며, 문자열 조작과 분석을 위한 다양한 유용한 메소드를 제공합니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">char charAt(int index)</code>: 문자열에서 특정 <strong>인덱스</strong>의 위치에 있는 문자를 리턴합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">char[] toCharArray()</code>: 문자열을 **문자 배열(char[])**로 변환합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">String(char[] value)</code>: <code class="language-plaintext highlighter-rouge">char</code> 배열을 다시 문자열로 생성합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">int indexOf(String searchStr)</code>: 문자열이 포함되어 있다면 해당 문자열의 <strong>시작 인덱스</strong>를 리턴하고, 포함되어 있지 않으면 <code class="language-plaintext highlighter-rouge">-1</code>을 리턴합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">boolean contains(CharSequence s)</code>: 문자열이 포함되어 있으면 <code class="language-plaintext highlighter-rouge">true</code>, 포함되어 있지 않으면 <code class="language-plaintext highlighter-rouge">false</code>를 리턴합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">String substring(int beginIndex)</code>: <code class="language-plaintext highlighter-rouge">beginIndex</code>부터 문자열 끝까지의 부분 문자열을 <strong>추출</strong>합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">String substring(int beginIndex, int endIndex)</code>: <code class="language-plaintext highlighter-rouge">beginIndex</code>부터 <code class="language-plaintext highlighter-rouge">endIndex - 1</code>까지의 부분 문자열을 추출합니다 (<code class="language-plaintext highlighter-rouge">beginIndex &lt;= 인덱스 &lt; endIndex</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">String replace(CharSequence target, CharSequence replacement)</code>: 문자열 내에서 <code class="language-plaintext highlighter-rouge">target</code> 문자열을 <code class="language-plaintext highlighter-rouge">replacement</code> 문자열로 <strong>교체</strong>합니다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"자바 프로그래밍은 자바입니다."</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">newStr</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"자바"</span><span class="o">,</span> <span class="s">"JAVA"</span><span class="o">);</span> <span class="c1">// "JAVA 프로그래밍은 JAVA입니다."</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">String trim()</code>: 문자열의 <strong>양 끝 공백을 제거</strong>합니다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"             010"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">newStr</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">trim</span><span class="o">();</span> <span class="c1">// "010"</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h2 id="포장wrapper-클래스-기본-타입을-객체로">포장(Wrapper) 클래스: 기본 타입을 객체로</h2>

<p>자바의 <strong>기본(Primitive) 타입</strong>(예: <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">boolean</code>)은 객체가 아니므로, 객체 지향적인 특성을 가질 수 없고 컬렉션 프레임워크(예: <code class="language-plaintext highlighter-rouge">ArrayList</code>)에서 직접 사용할 수 없습니다. 이를 해결하기 위해 기본 타입에 해당하는 <strong>포장(Wrapper) 클래스</strong>가 제공됩니다.</p>

<ul>
  <li><strong>박싱(Boxing)</strong>: 기본 타입의 값을 포장 클래스의 객체로 변환하는 과정.</li>
  <li><strong>언박싱(Unboxing)</strong>: 포장 클래스의 객체에서 기본 타입의 값을 추출하는 과정.</li>
</ul>

<p>자바 5부터는 **오토 박싱(Auto-boxing)**과 <strong>오토 언박싱(Auto-unboxing)</strong> 기능이 도입되어 기본 타입과 포장 클래스 간의 변환이 매우 자유로워졌습니다.</p>

<p><strong>포장 클래스 비교 시 주의사항:</strong></p>

<p>포장 클래스는 객체이므로 <code class="language-plaintext highlighter-rouge">==</code> 연산자는 객체의 주소값을 비교합니다. 따라서 <code class="language-plaintext highlighter-rouge">-128</code>에서 <code class="language-plaintext highlighter-rouge">127</code> 범위 외의 값은 <code class="language-plaintext highlighter-rouge">==</code> 비교 시 예상과 다른 결과를 낼 수 있으므로, 반드시 <code class="language-plaintext highlighter-rouge">equals()</code> 메소드를 사용하여 값을 비교해야 합니다. (JVM이 이 범위의 <code class="language-plaintext highlighter-rouge">Integer</code> 객체들을 캐싱하기 때문입니다.)</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WrapperClassExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 자동 박싱 (int -&gt; Integer)</span>
        <span class="nc">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"자동 박싱된 Integer i: "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>

        <span class="c1">// 명시적 박싱 (int -&gt; Integer)</span>
        <span class="nc">Integer</span> <span class="n">i2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span> <span class="c1">// Deprecated</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"명시적 박싱된 Integer i2: "</span> <span class="o">+</span> <span class="n">i2</span><span class="o">);</span>

        <span class="c1">// 자동 언박싱 (Integer -&gt; int)</span>
        <span class="kt">int</span> <span class="n">i3</span> <span class="o">=</span> <span class="n">i2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"자동 언박싱된 int i3: "</span> <span class="o">+</span> <span class="n">i3</span><span class="o">);</span>

        <span class="c1">// 포장 클래스 비교 시 주의 (== vs equals)</span>
        <span class="nc">Integer</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
        <span class="nc">Integer</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a == b (100): "</span> <span class="o">+</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">));</span> <span class="c1">// true (캐싱 범위 내)</span>

        <span class="nc">Integer</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">200</span><span class="o">;</span>
        <span class="nc">Integer</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">200</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"x == y (200): "</span> <span class="o">+</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="o">));</span> <span class="c1">// false (캐싱 범위 밖, 다른 객체)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"x.equals(y) (200): "</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">y</span><span class="o">));</span> <span class="c1">// true (값 비교)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>출력 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>자동 박싱된 Integer i: 10
명시적 박싱된 Integer i2: 10
자동 언박싱된 int i3: 10
a == b (100): true
x == y (200): false
x.equals(y) (200): true
</code></pre></div></div>

<hr />

<h2 id="math-클래스-수학-계산-유틸리티"><code class="language-plaintext highlighter-rouge">Math</code> 클래스: 수학 계산 유틸리티</h2>

<p><code class="language-plaintext highlighter-rouge">java.lang.Math</code> 클래스는 수학에서 자주 사용하는 함수들을 제공하는 유틸리티 클래스입니다. 모든 메소드가 <strong><code class="language-plaintext highlighter-rouge">static</code> 메소드</strong>로 구성되어 있어, 객체를 생성할 필요 없이 <code class="language-plaintext highlighter-rouge">Math.메소드명()</code> 형태로 직접 호출하여 사용할 수 있습니다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Math.round(double a)</code>: 소수점 첫째 자리에서 <strong>반올림</strong>하여 정수(<code class="language-plaintext highlighter-rouge">long</code> 또는 <code class="language-plaintext highlighter-rouge">int</code>)로 리턴합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Math.random()</code>: <code class="language-plaintext highlighter-rouge">0.0</code> (포함) 이상 <code class="language-plaintext highlighter-rouge">1.0</code> (미포함) 미만의 <strong>실수형 난수</strong>(<code class="language-plaintext highlighter-rouge">double</code>)를 리턴합니다.</li>
</ul>

<!-- end list -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MathExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">value</span> <span class="o">=</span> <span class="mf">3.64</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">roundedValue</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="n">value</span><span class="o">);</span> <span class="c1">// 3.64를 반올림</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span> <span class="o">+</span> <span class="s">"의 반올림 값: "</span> <span class="o">+</span> <span class="n">roundedValue</span><span class="o">);</span> <span class="c1">// 4</span>

        <span class="kt">double</span> <span class="n">randomValue</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">();</span> <span class="c1">// 0.0 이상 1.0 미만의 난수</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"랜덤 값 (0.0 &lt;= x &lt; 1.0): "</span> <span class="o">+</span> <span class="n">randomValue</span><span class="o">);</span>

        <span class="c1">// 1부터 100까지의 정수 난수 생성 예시</span>
        <span class="kt">int</span> <span class="n">randomInt</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">100</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"1부터 100까지의 랜덤 정수: "</span> <span class="o">+</span> <span class="n">randomInt</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>출력 결과 (예시):</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3.64의 반올림 값: 4
랜덤 값 (0.0 &lt;= x &lt; 1.0): 0.7329487...
1부터 100까지의 랜덤 정수: 42
</code></pre></div></div>

<hr />

<h2 id="날짜와-시간-클래스-date-simpledateformat-localdate">날짜와 시간 클래스: <code class="language-plaintext highlighter-rouge">Date</code>, <code class="language-plaintext highlighter-rouge">SimpleDateFormat</code>, <code class="language-plaintext highlighter-rouge">LocalDate</code></h2>

<p>자바에서 날짜와 시간을 다루는 방법은 여러 가지가 있습니다. 크게 <code class="language-plaintext highlighter-rouge">java.util.Date</code> 계열과 자바 8부터 도입된 <code class="language-plaintext highlighter-rouge">java.time</code> 패키지 계열이 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DateTimeExample</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">// 1. java.util.Date (오래된 방식)</span>
		<span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Date</span> <span class="n">date</span> <span class="o">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Date</span><span class="o">();</span> <span class="c1">// 실행 시점의 날짜, 시간을 리턴 (util 패키지)</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"현재 날짜와 시간 (Date): "</span> <span class="o">+</span> <span class="n">date</span><span class="o">);</span>

		<span class="c1">// SimpleDateFormat: Date 객체와 문자열 간 변환 (포매팅/파싱)</span>
		<span class="n">java</span><span class="o">.</span><span class="na">text</span><span class="o">.</span><span class="na">SimpleDateFormat</span> <span class="n">sdf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">text</span><span class="o">.</span><span class="na">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy년 MM월 dd일 E요일"</span><span class="o">);</span>
		<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">date</span><span class="o">);</span> <span class="c1">// 날짜시간 객체 -&gt; 문자열 (예: 2025년 04월 15일 화요일)</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"SimpleDateFormat으로 포매팅된 날짜: "</span> <span class="o">+</span> <span class="n">str</span><span class="o">);</span>

		<span class="k">try</span> <span class="o">{</span>
		    <span class="n">str</span> <span class="o">=</span> <span class="s">"2025-04-15"</span><span class="o">;</span>
		    <span class="n">sdf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">text</span><span class="o">.</span><span class="na">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy-MM-dd"</span><span class="o">);</span>
			<span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Date</span> <span class="n">newDate</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">str</span><span class="o">);</span> <span class="c1">// 문자열 -&gt; 날짜시간 객체</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"문자열로부터 파싱된 Date: "</span> <span class="o">+</span> <span class="n">newDate</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">text</span><span class="o">.</span><span class="na">ParseException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
		<span class="o">}</span>
		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--------------------"</span><span class="o">);</span>

		<span class="c1">// 2. java.time 패키지 (Java 8 이후의 새로운 방식, 권장)</span>
		<span class="n">java</span><span class="o">.</span><span class="na">time</span><span class="o">.</span><span class="na">LocalDate</span> <span class="n">ld</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="na">time</span><span class="o">.</span><span class="na">LocalDate</span><span class="o">.</span><span class="na">now</span><span class="o">();</span> <span class="c1">// 날짜 정보만 저장 - now() 실행 시점 / of() 특정 날짜</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"현재 날짜 (LocalDate): "</span> <span class="o">+</span> <span class="n">ld</span><span class="o">);</span>
		
		<span class="n">java</span><span class="o">.</span><span class="na">time</span><span class="o">.</span><span class="na">format</span><span class="o">.</span><span class="na">DateTimeFormatter</span> <span class="n">df</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="na">time</span><span class="o">.</span><span class="na">format</span><span class="o">.</span><span class="na">DateTimeFormatter</span><span class="o">.</span><span class="na">ofPattern</span><span class="o">(</span><span class="s">"yyyy년 MM월 dd일"</span><span class="o">);</span>
		<span class="n">str</span> <span class="o">=</span> <span class="n">ld</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">df</span><span class="o">);</span> <span class="c1">// LocalDate 객체 -&gt; 문자열 (예: 2025년 4월 15일)</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DateTimeFormatter로 포매팅된 날짜: "</span> <span class="o">+</span> <span class="n">str</span><span class="o">);</span>
		
		<span class="n">java</span><span class="o">.</span><span class="na">time</span><span class="o">.</span><span class="na">LocalDate</span> <span class="n">newLocalDate</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="na">time</span><span class="o">.</span><span class="na">LocalDate</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">df</span><span class="o">);</span> <span class="c1">// 문자열, 포맷팅 규칙으로 파싱</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"문자열로부터 파싱된 LocalDate: "</span> <span class="o">+</span> <span class="n">newLocalDate</span><span class="o">);</span> <span class="c1">// newLocalDate.toString()</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>출력 결과 (예시):</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>현재 날짜와 시간 (Date): Wed Jun 25 14:47:51 KST 2025
SimpleDateFormat으로 포매팅된 날짜: 2025년 06월 25일 수요일
문자열로부터 파싱된 Date: Mon Apr 15 00:00:00 KST 2025
--------------------
현재 날짜 (LocalDate): 2025-06-25
DateTimeFormatter로 포매팅된 날짜: 2025년 06월 25일
문자열로부터 파싱된 LocalDate: 2025-06-25
</code></pre></div></div>

<hr />

<h3 id="-요약-정리-자바-핵심-클래스">📌 요약 정리: 자바 핵심 클래스</h3>

<table>
  <thead>
    <tr>
      <th>요소</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">Object</code> 클래스</strong></td>
      <td>모든 자바 클래스의 <strong>최상위 조상</strong>. 모든 객체가 기본적으로 가지는 <code class="language-plaintext highlighter-rouge">equals()</code>, <code class="language-plaintext highlighter-rouge">hashCode()</code>, <code class="language-plaintext highlighter-rouge">toString()</code> 등의 메소드를 정의.</td>
    </tr>
    <tr>
      <td><strong>객체 동등 비교</strong></td>
      <td><code class="language-plaintext highlighter-rouge">==</code> (주소 비교)와 <code class="language-plaintext highlighter-rouge">equals()</code> (내용 비교)로 나뉪. &lt;br&gt; <code class="language-plaintext highlighter-rouge">equals()</code>가 <code class="language-plaintext highlighter-rouge">true</code>면 <code class="language-plaintext highlighter-rouge">hashCode()</code>도 같아야 함.</td>
    </tr>
    <tr>
      <td><strong>객체 정의 패턴</strong></td>
      <td><code class="language-plaintext highlighter-rouge">private</code> 인스턴스 변수, <code class="language-plaintext highlighter-rouge">getter</code>/<code class="language-plaintext highlighter-rouge">setter</code> 메소드, 필드/기본 생성자, &lt;br&gt; <code class="language-plaintext highlighter-rouge">toString()</code>/<code class="language-plaintext highlighter-rouge">hashCode()</code>/<code class="language-plaintext highlighter-rouge">equals()</code> 재정의를 포함. &lt;br&gt; <code class="language-plaintext highlighter-rouge">hashCode()</code>/<code class="language-plaintext highlighter-rouge">equals()</code> 재정의 시 자주 변하는 값은 제외 권장.</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">String</code> 클래스</strong></td>
      <td>불변(immutable) 객체로, 문자열 조작을 위한 다양한 메소드 제공. &lt;br&gt; (<code class="language-plaintext highlighter-rouge">charAt</code>, <code class="language-plaintext highlighter-rouge">indexOf</code>, <code class="language-plaintext highlighter-rouge">contains</code>, <code class="language-plaintext highlighter-rouge">substring</code>, <code class="language-plaintext highlighter-rouge">replace</code>, <code class="language-plaintext highlighter-rouge">trim</code> 등)</td>
    </tr>
    <tr>
      <td><strong>포장(Wrapper) 클래스</strong></td>
      <td>기본 타입을 객체로 다루기 위해 사용. &lt;br&gt; <code class="language-plaintext highlighter-rouge">Integer</code>, <code class="language-plaintext highlighter-rouge">Double</code>, <code class="language-plaintext highlighter-rouge">Boolean</code> 등. &lt;br&gt; <strong>박싱</strong> (기본 → 포장), <strong>언박싱</strong> (포장 → 기본). &lt;br&gt; <code class="language-plaintext highlighter-rouge">-128~127</code> 범위 외 <code class="language-plaintext highlighter-rouge">Integer</code> 비교 시 <code class="language-plaintext highlighter-rouge">==</code> 대신 반드시 <code class="language-plaintext highlighter-rouge">equals()</code> 사용.</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">Math</code> 클래스</strong></td>
      <td>모든 메소드가 <code class="language-plaintext highlighter-rouge">static</code>으로 이루어진 수학 관련 유틸리티 클래스. &lt;br&gt; (<code class="language-plaintext highlighter-rouge">round</code>, <code class="language-plaintext highlighter-rouge">random</code> 등)</td>
    </tr>
    <tr>
      <td><strong>날짜/시간 클래스</strong></td>
      <td><code class="language-plaintext highlighter-rouge">java.util.Date</code> (구 방식)과 <code class="language-plaintext highlighter-rouge">java.time</code> 패키지 (Java 8 이후 권장). &lt;br&gt; <code class="language-plaintext highlighter-rouge">SimpleDateFormat</code> / <code class="language-plaintext highlighter-rouge">DateTimeFormatter</code>를 통해 문자열과 날짜/시간 객체 간 변환 가능.</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="-object-메소드-퀴즈">💡 <code class="language-plaintext highlighter-rouge">Object</code> 메소드 퀴즈</h3>

<p>다음 코드를 실행했을 때, 출력 결과로 가장 적절한 것은 무엇일까요?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">author</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Book</span><span class="o">(</span><span class="nc">String</span> <span class="n">title</span><span class="o">,</span> <span class="nc">String</span> <span class="n">author</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">title</span> <span class="o">=</span> <span class="n">title</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">author</span> <span class="o">=</span> <span class="n">author</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// equals와 hashCode는 재정의하지 않음</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BookComparison</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Book</span> <span class="n">book1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="s">"어린 왕자"</span><span class="o">,</span> <span class="s">"앙투안 드 생텍쥐페리"</span><span class="o">);</span>
        <span class="nc">Book</span> <span class="n">book2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="s">"어린 왕자"</span><span class="o">,</span> <span class="s">"앙투안 드 생텍쥐페리"</span><span class="o">);</span>
        <span class="nc">Book</span> <span class="n">book3</span> <span class="o">=</span> <span class="n">book1</span><span class="o">;</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"book1 == book2: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">book1</span> <span class="o">==</span> <span class="n">book2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"book1.equals(book2): "</span> <span class="o">+</span> <span class="n">book1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">book2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"book1 == book3: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">book1</span> <span class="o">==</span> <span class="n">book3</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<details>
<summary>정답 보기</summary>
<br />
출력 결과:<br /><br />

book1 == book2: false<br />
book1.equals(book2): false<br />
book1 == book3: true<br />

<br />
설명:
<br />

1.  book1 == book2: new Book(...)을 두 번 호출했으므로, book1과 book2는 서로 다른 메모리 공간에 있는 별개의 객체입니다. 따라서 false가 출력됩니다.<br />
2.  book1.equals(book2): Book 클래스에서 equals() 메소드를 재정의하지 않았습니다. 자바의 모든 클래스는 Object 클래스를 상속받는데, Object 클래스의 equals() 메소드는 기본적으로 == 연산자와 동일하게 객체의 메모리 주소(참조)를 비교합니다. book1과 book2는 다른 객체이므로 false가 출력됩니다.<br />
3.  book1 == book3: book3 = book1 코드를 통해 book3 변수는 book1이 참조하는 동일한 객체를 참조하게 됩니다. 따라서 true가 출력됩니다.

</details>

<hr />

<h3 id="-마치며-객체지향-심화의-시작">🔚 마치며: 객체지향 심화의 시작</h3>

<p>이번 글에서는 자바의 모든 객체가 기반이 되는 <code class="language-plaintext highlighter-rouge">Object</code> 클래스의 중요성을 이해하고, 객체의 <strong>동등성 비교 (<code class="language-plaintext highlighter-rouge">equals()</code>와 <code class="language-plaintext highlighter-rouge">hashCode()</code>)</strong> 원칙에 대해 깊이 있게 다루었습니다. 또한, 실제 자바 클래스를 설계할 때 활용되는 <strong>POJO 패턴</strong>을 익히고, 문자열(<code class="language-plaintext highlighter-rouge">String</code>), 숫자(<code class="language-plaintext highlighter-rouge">Wrapper</code>), 수학(<code class="language-plaintext highlighter-rouge">Math</code>), 날짜/시간(<code class="language-plaintext highlighter-rouge">Date</code>, <code class="language-plaintext highlighter-rouge">LocalDate</code>)과 같이 자주 사용되는 핵심 유틸리티 클래스들의 기능과 사용법을 살펴보았습니다.</p>

<p>이러한 내용들은 자바에서 데이터를 올바르게 모델링하고, 효율적으로 처리하며, 안정적인 애플리케이션을 개발하는 데 필수적인 지식입니다. 특히 <code class="language-plaintext highlighter-rouge">equals()</code>와 <code class="language-plaintext highlighter-rouge">hashCode()</code>의 올바른 재정의는 컬렉션 사용 시 예상치 못한 문제를 방지하는 데 결정적인 역할을 합니다.</p>]]></content><author><name>Lorem</name><email>loremipsum0115@gmail.com</email></author><category term="java" /><summary type="html"><![CDATA[]]></summary></entry><entry xml:lang="ko"><title type="html">자바 객체지향-인터페이스</title><link href="https://loremipsum0116.github.io/ko/java-interface/" rel="alternate" type="text/html" title="자바 객체지향-인터페이스" /><published>2025-06-17T03:02:21+00:00</published><updated>2025-06-17T03:02:21+00:00</updated><id>https://loremipsum0116.github.io/ko/java-interface</id><content type="html" xml:base="https://loremipsum0116.github.io/ko/java-interface/"><![CDATA[<hr />

<h2 id="자바-객체지향-인터페이스-interface">자바 객체지향: 인터페이스 (Interface)</h2>

<p>자바 객체지향 프로그래밍에서 **인터페이스(Interface)**는 클래스들이 구현해야 하는 <strong>메소드의 집합을 정의하는 특별한 종류의 추상 클래스</strong>라고 볼 수 있습니다. 인터페이스는 객체의 **행위(Behavior)**를 정의하고, 다양한 클래스들이 동일한 행위를 가지도록 <strong>표준을 제시</strong>하는 데 사용됩니다.</p>

<p>인터페이스는 클래스와는 다르게 객체를 직접 생성할 수 없으며, 주로 **다형성(Polymorphism)**을 높이고, 여러 클래스에 걸쳐 공통된 기능을 강제하거나, 느슨한 결합(Loose Coupling)을 통한 유연한 설계를 가능하게 합니다.</p>

<hr />

<h2 id="1-인터페이스의-특징과-역할">1. 인터페이스의 특징과 역할</h2>

<p>인터페이스는 다음과 같은 주요 특징과 역할을 가집니다.</p>

<ul>
  <li><strong>추상 메소드의 집합</strong>: 인터페이스는 기본적으로 **추상 메소드(Abstract Method)**로만 구성됩니다. 자바 8부터는 <code class="language-plaintext highlighter-rouge">default</code> 메소드와 <code class="language-plaintext highlighter-rouge">static</code> 메소드도 포함할 수 있게 되었지만, 본질적인 목적은 <strong>구현할 클래스에게 어떤 기능을 제공해야 하는지 정의</strong>하는 것입니다.</li>
  <li><strong>다중 상속의 대안</strong>: 자바는 클래스의 다중 상속을 허용하지 않습니다. 하지만 인터페이스는 **다중 구현(Multiple Implementation)**을 허용하여, 하나의 클래스가 여러 인터페이스를 구현함으로써 다중 상속과 유사한 효과를 낼 수 있습니다.</li>
  <li><strong>상수(Constant) 정의</strong>: 인터페이스 내에 정의되는 모든 필드(변수)는 <strong><code class="language-plaintext highlighter-rouge">public static final</code></strong> 특성을 가집니다. 즉, <strong>상수만 정의할 수 있으며, 인스턴스 변수나 static 변수는 직접 정의할 수 없습니다.</strong></li>
  <li><strong>느슨한 결합</strong>: 인터페이스를 사용하면 구현 클래스 간의 의존성을 줄여서 시스템을 더욱 유연하고 확장 가능하게 만듭니다.</li>
  <li><strong>설계 명세</strong>: 인터페이스는 특정 기능을 제공하는 클래스가 가져야 할 ‘계약’ 또는 ‘명세’의 역할을 합니다. 이는 협업 시 개발자 간의 약속을 명확히 합니다.</li>
</ul>

<hr />

<h2 id="2-인터페이스-선언-및-구현">2. 인터페이스 선언 및 구현</h2>

<h3 id="2-1-인터페이스-선언">2-1. 인터페이스 선언</h3>

<p>인터페이스는 <code class="language-plaintext highlighter-rouge">interface</code> 키워드를 사용하여 선언합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Soundable</span> <span class="o">{</span>
    <span class="c1">// 상수 정의 (public static final은 생략 가능)</span>
    <span class="nc">String</span> <span class="no">DEFAULT_SOUND_TYPE</span> <span class="o">=</span> <span class="s">"General Sound"</span><span class="o">;</span>

    <span class="c1">// 추상 메소드 (public abstract은 생략 가능)</span>
    <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">playMusic</span><span class="o">(</span><span class="nc">String</span> <span class="n">songName</span><span class="o">);</span>

    <span class="c1">// Java 8부터 추가된 default 메소드 (구현부가 있음)</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">describe</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"이 객체는 소리를 낼 수 있습니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Java 8부터 추가된 static 메소드 (인터페이스 이름으로 직접 호출)</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">showSoundCapability</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"모든 Soundable 객체는 소리를 내는 능력을 가집니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>특징:</strong></p>

<ul>
  <li><strong>메소드</strong>: 인터페이스의 모든 메소드는 자바 8 이전에는 <strong><code class="language-plaintext highlighter-rouge">public abstract</code></strong> 이었으며, 이 키워드는 생략 가능합니다. 자바 8부터는 <strong><code class="language-plaintext highlighter-rouge">default</code></strong> 메소드와 <strong><code class="language-plaintext highlighter-rouge">static</code></strong> 메소드도 추가되어 구현부를 가질 수 있게 되었습니다.</li>
  <li><strong>변수</strong>: 인터페이스에 선언되는 모든 변수는 <strong><code class="language-plaintext highlighter-rouge">public static final</code></strong> 상수로 간주되며, 이 키워드 역시 생략 가능합니다. <strong>인스턴스 변수나 단순한 static 변수는 정의할 수 없습니다.</strong> 즉, 상태(State)를 가질 수 없고 오직 상수만 가질 수 있습니다.</li>
</ul>

<h3 id="2-2-인터페이스-구현-implements">2-2. 인터페이스 구현 (implements)</h3>

<p>클래스는 <code class="language-plaintext highlighter-rouge">implements</code> 키워드를 사용하여 하나 이상의 인터페이스를 구현할 수 있습니다. 인터페이스를 구현하는 클래스는 해당 인터페이스에 정의된 <strong>모든 추상 메소드를 반드시 오버라이딩하여 구현</strong>해야 합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Soundable 인터페이스를 구현하는 Dog 클래스</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Soundable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Dog</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Soundable 인터페이스의 추상 메소드 구현</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">"가 멍멍 짖습니다!"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">playMusic</span><span class="o">(</span><span class="nc">String</span> <span class="n">songName</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">"는 "</span> <span class="o">+</span> <span class="n">songName</span> <span class="o">+</span> <span class="s">" 노래를 들으면 꼬리를 흔듭니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// default 메소드는 구현하지 않아도 되지만, 필요하면 오버라이딩 가능</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">describe</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">"는 "</span> <span class="o">+</span> <span class="no">DEFAULT_SOUND_TYPE</span> <span class="o">+</span> <span class="s">" 타입의 소리를 낼 수 있는 동물입니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Soundable 인터페이스를 구현하는 Car 클래스</span>
<span class="kd">class</span> <span class="nc">Car</span> <span class="kd">implements</span> <span class="nc">Soundable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">model</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Car</span><span class="o">(</span><span class="nc">String</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Soundable 인터페이스의 추상 메소드 구현</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">model</span> <span class="o">+</span> <span class="s">"가 빵빵 경적을 울립니다!"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">playMusic</span><span class="o">(</span><span class="nc">String</span> <span class="n">songName</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">model</span> <span class="o">+</span> <span class="s">"에서 "</span> <span class="o">+</span> <span class="n">songName</span> <span class="o">+</span> <span class="s">" 노래가 흘러나옵니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InterfaceExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 인터페이스 다형성 활용</span>
        <span class="nc">Soundable</span> <span class="n">myDog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"바둑이"</span><span class="o">);</span>
        <span class="nc">Soundable</span> <span class="n">myCar</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="s">"테슬라 모델3"</span><span class="o">);</span>

        <span class="n">myDog</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span> <span class="c1">// 바둑이가 멍멍 짖습니다!</span>
        <span class="n">myDog</span><span class="o">.</span><span class="na">playMusic</span><span class="o">(</span><span class="s">"강아지 송"</span><span class="o">);</span> <span class="c1">// 바둑이는 강아지 송 노래를 들으면 꼬리를 흔듭니다.</span>
        <span class="n">myDog</span><span class="o">.</span><span class="na">describe</span><span class="o">();</span> <span class="c1">// 바둑이는 General Sound 타입의 소리를 낼 수 있는 동물입니다.</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---"</span><span class="o">);</span>

        <span class="n">myCar</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span> <span class="c1">// 테슬라 모델3가 빵빵 경적을 울립니다!</span>
        <span class="n">myCar</span><span class="o">.</span><span class="na">playMusic</span><span class="o">(</span><span class="s">"드라이브 송"</span><span class="o">);</span> <span class="c1">// 테슬라 모델3에서 드라이브 송 노래가 흘러나옵니다.</span>
        <span class="c1">// myCar.carDescription(); // 컴파일 에러: Soundable 타입에는 carDescription 메소드가 없음</span>
        <span class="c1">// (myCar는 Soundable 인터페이스 타입으로 선언되었기 때문에 Soundable에 정의된 메소드만 호출 가능)</span>
        <span class="n">myCar</span><span class="o">.</span><span class="na">describe</span><span class="o">();</span> <span class="c1">// 이 객체는 소리를 낼 수 있습니다. (기본 default 메소드 호출)</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---"</span><span class="o">);</span>

        <span class="c1">// 인터페이스의 static 메소드 호출</span>
        <span class="nc">Soundable</span><span class="o">.</span><span class="na">showSoundCapability</span><span class="o">();</span> <span class="c1">// 모든 Soundable 객체는 소리를 내는 능력을 가집니다.</span>

        <span class="c1">// 인터페이스에 정의된 상수 사용</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"기본 사운드 타입: "</span> <span class="o">+</span> <span class="nc">Soundable</span><span class="o">.</span><span class="na">DEFAULT_SOUND_TYPE</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h2 id="3-인터페이스의-핵심-개념-추상-메소드-집합-및-변수-제한">3. 인터페이스의 핵심 개념: 추상 메소드 집합 및 변수 제한</h2>

<h3 id="3-1-추상-메소드의-집합-abstract-method-collection">3-1. 추상 메소드의 집합 (Abstract Method Collection)</h3>

<p>인터페이스의 가장 본질적인 역할은 **클래스가 따라야 할 행위의 청사진(Blueprint)**을 제공하는 것입니다. 이 청사진은 <strong>오직 추상 메소드</strong>로만 이루어져 있었습니다 (자바 8 이전).</p>

<ul>
  <li>인터페이스에 선언된 추상 메소드는 **메소드 시그니처(이름, 매개변수, 반환 타입)**만 있고, <strong>구현부(Body)가 없습니다.</strong></li>
  <li>인터페이스를 구현하는 모든 클래스는 이 추상 메소드들을 <strong>반드시 자신의 목적에 맞게 구현</strong>해야 합니다. 이를 통해 다양한 클래스들이 동일한 인터페이스를 구현함으로써 <strong>다형성</strong>을 활용할 수 있게 됩니다.</li>
  <li>예시: <code class="language-plaintext highlighter-rouge">Soundable</code> 인터페이스의 <code class="language-plaintext highlighter-rouge">makeSound()</code> 메소드를 <code class="language-plaintext highlighter-rouge">Dog</code> 클래스는 “멍멍”으로, <code class="language-plaintext highlighter-rouge">Car</code> 클래스는 “빵빵”으로 다르게 구현하지만, 두 객체 모두 <code class="language-plaintext highlighter-rouge">Soundable</code> 타입으로 <code class="language-plaintext highlighter-rouge">makeSound()</code>를 호출할 수 있습니다.</li>
</ul>

<h3 id="3-2-인스턴스-변수-및-static-변수-정의-불가">3-2. 인스턴스 변수 및 static 변수 정의 불가</h3>

<p>인터페이스는 클래스와 달리 <strong>객체의 상태(State)를 가질 수 없습니다.</strong></p>

<ul>
  <li>인터페이스 내부에 **인스턴스 변수(non-static field)**를 선언하는 것은 허용되지 않습니다.
    <ul>
      <li>이는 인터페이스가 <strong>구현 객체들의 공통적인 행위 명세</strong>를 위한 것이지, <strong>개별 객체의 데이터를 저장</strong>하기 위한 것이 아니기 때문입니다.</li>
    </ul>
  </li>
  <li>인터페이스 내부에 <strong>일반적인 static 변수</strong>를 선언하는 것도 허용되지 않습니다.
    <ul>
      <li>인터페이스에 선언되는 모든 변수는 컴파일 시 자동으로 <strong><code class="language-plaintext highlighter-rouge">public static final</code></strong> 특성을 부여받아 **상수(Constant)**로 처리됩니다. 이는 인터페이스가 특정 값을 공유하는 데 사용될 수 있지만, 변하는 상태를 가지는 필드는 정의할 수 없다는 의미입니다.</li>
    </ul>
  </li>
</ul>

<p>이러한 제한은 인터페이스가 <strong>행위의 추상화</strong>에만 집중하고, 데이터 관리의 책임은 이를 구현하는 클래스에게 위임하여 설계의 <strong>단순성과 명확성</strong>을 유지하도록 돕습니다.</p>

<hr />

<h2 id="-요약-정리-인터페이스">📌 요약 정리: 인터페이스</h2>

<ul>
  <li><strong>인터페이스</strong>: 클래스들이 구현해야 할 <strong>추상 메소드의 집합</strong>을 정의하는 특별한 형태의 추상 클래스.</li>
  <li><strong>주요 역할</strong>: 다형성 증진, 다중 구현을 통한 다중 상속 효과, 느슨한 결합, 설계 명세 제시.</li>
  <li><strong>특징</strong>:
    <ul>
      <li>기본적으로 <strong><code class="language-plaintext highlighter-rouge">public abstract</code> 메소드</strong>로 구성 (Java 8부터 <code class="language-plaintext highlighter-rouge">default</code>, <code class="language-plaintext highlighter-rouge">static</code> 메소드 추가).</li>
      <li>선언된 모든 필드는 <strong><code class="language-plaintext highlighter-rouge">public static final</code> 상수</strong>이다.</li>
      <li><strong>인스턴스 변수 및 일반적인 static 변수는 정의할 수 없다.</strong> (오직 상수만 가능)</li>
    </ul>
  </li>
  <li><strong>구현</strong>: <code class="language-plaintext highlighter-rouge">implements</code> 키워드를 사용하며, 인터페이스의 모든 추상 메소드를 반드시 구현해야 한다.</li>
</ul>

<hr />

<h2 id="-인터페이스-심화-퀴즈">💡 인터페이스 심화 퀴즈</h2>

<p>다음 자바 코드와 설명에 대한 질문입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Flyable</span> <span class="o">{</span>
    <span class="c1">// #1</span>
    <span class="kt">int</span> <span class="no">MAX_ALTITUDE</span> <span class="o">=</span> <span class="mi">10000</span><span class="o">;</span>

    <span class="c1">// #2</span>
    <span class="kt">void</span> <span class="nf">takeOff</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">land</span><span class="o">();</span>

    <span class="c1">// #3</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">accelerate</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"가속합니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// #4</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">describeFlight</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"비행 객체의 공통 특성."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// #5</span>
    <span class="c1">// private String type; // 인터페이스 내 인스턴스 변수 선언 시도</span>
<span class="o">}</span>

<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Vehicle</span> <span class="kd">implements</span> <span class="nc">Flyable</span> <span class="o">{</span>
    <span class="c1">// #6</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">speed</span><span class="o">;</span> <span class="c1">// 이 선언은 가능할까?</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">takeOff</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"차량이 이륙합니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// land 메소드는 추상으로 남겨둘 수 있다.</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Airplane</span> <span class="kd">extends</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">land</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"비행기가 착륙합니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>질문:</strong> 위 코드에서 컴파일 에러가 발생하거나, 인터페이스의 본질적 특성(메소드 및 변수 정의 제한)을 위배하는 주석 처리된 라인은 몇 번일까요? (정답은 하나 이상일 수 있습니다.)</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">#1</code></li>
  <li><code class="language-plaintext highlighter-rouge">#2</code></li>
  <li><code class="language-plaintext highlighter-rouge">#3</code></li>
  <li><code class="language-plaintext highlighter-rouge">#4</code></li>
  <li><code class="language-plaintext highlighter-rouge">#5</code></li>
  <li><code class="language-plaintext highlighter-rouge">#6</code></li>
</ol>

<details>
<summary>정답 보기</summary>
<br />
**정답:** 5번<br /><br />

**설명:**<br /><br />

  * **\#5는 컴파일 에러를 발생**시킵니다. 인터페이스는 **인스턴스 변수를 가질 수 없습니다.** 인터페이스 내의 모든 필드는 암묵적으로 `public static final` 상수가 됩니다.<br />
  * 나머지 옵션들은 유효한 선언입니다:<br />
      * `#1`은 인터페이스 내 유효한 상수 선언입니다.<br />
      * `#2`는 인터페이스 내 유효한 추상 메소드 선언입니다.<br />
      * `#3`은 자바 8부터 허용되는 `default` 메소드 선언입니다.<br />
      * `#4`는 자바 8부터 허용되는 `static` 메소드 선언입니다.<br />
      * `#6`은 추상 클래스 `Vehicle` 내의 인스턴스 변수 선언입니다. **추상 클래스는 상태(인스턴스 변수)를 가질 수 있습니다.** 이는 인터페이스와 추상 클래스의 중요한 차이점 중 하나입니다.<br /><br />

</details>

<hr />

<h2 id="-마치며-설계의-유연성을-위한-인터페이스">🔚 마치며: 설계의 유연성을 위한 인터페이스</h2>

<p>이번 글에서는 자바 객체지향의 중요한 요소인 <strong>인터페이스</strong>에 대해 깊이 있게 다루었습니다. 인터페이스가 어떻게 <strong>클래스의 행위를 표준화</strong>하고, <strong>다형성을 활용</strong>하여 유연하고 확장 가능한 설계를 가능하게 하는지 이해하셨을 것입니다. 특히 <strong>인터페이스가 추상 메소드의 집합으로 구성되며, 인스턴스 변수나 static 변수를 직접 정의할 수 없고 오직 상수만을 가질 수 있다는 점</strong>은 인터페이스의 본질적인 목적을 이해하는 데 핵심적인 부분입니다.</p>

<p>클래스의 상속이 ‘is-a’ 관계(A는 B이다)를 나타내며 객체의 상태(필드)를 가질 수 있는 반면, 인터페이스의 구현은 ‘can-do’ 관계(A는 ~를 할 수 있다)를 나타내며 오직 행위(메소드)의 명세만을 제공합니다. 이러한 차이를 명확히 이해하면 객체지향 설계에서 인터페이스를 언제, 왜 사용해야 하는지 명확히 판단할 수 있습니다.</p>]]></content><author><name>Lorem</name><email>loremipsum0115@gmail.com</email></author><category term="java" /><summary type="html"><![CDATA[]]></summary></entry><entry xml:lang="ko"><title type="html">자바 생성자 호출 순서</title><link href="https://loremipsum0116.github.io/ko/java-oop&class(3)/" rel="alternate" type="text/html" title="자바 생성자 호출 순서" /><published>2025-06-17T02:57:54+00:00</published><updated>2025-06-17T02:57:54+00:00</updated><id>https://loremipsum0116.github.io/ko/java-oop&amp;class(3)</id><content type="html" xml:base="https://loremipsum0116.github.io/ko/java-oop&amp;class(3)/"><![CDATA[<hr />

<h2 id="자바-객체지향-상속과-생성자-호출-순서-constructor-chaining">자바 객체지향: 상속과 생성자 호출 순서 (Constructor Chaining)</h2>

<p>자바에서 객체가 생성될 때, 우리는 <code class="language-plaintext highlighter-rouge">new</code> 키워드와 함께 클래스의 **생성자(Constructor)**를 호출합니다. 그런데 만약 클래스들이 <strong>상속 관계</strong>에 있다면, 단 하나의 생성자를 호출하더라도 내부적으로 여러 클래스의 생성자들이 <strong>연쇄적으로 호출</strong>되는 복잡한 과정이 일어납니다. 이 과정을 **생성자 연쇄 호출(Constructor Chaining)**이라고 합니다.</p>

<p>이러한 생성자 호출 순서를 정확히 이해하는 것은 객체지향 프로그래밍에서 객체의 초기화가 어떻게 이루어지는지 파악하고, 잠재적인 오류를 방지하는 데 매우 중요합니다.</p>

<hr />

<h2 id="1-생성자-연쇄-호출의-기본-원리">1. 생성자 연쇄 호출의 기본 원리</h2>

<p>자바에서 모든 클래스는 <code class="language-plaintext highlighter-rouge">java.lang.Object</code> 클래스를 암시적으로 상속받습니다. 따라서 어떤 객체를 생성하든, 그 객체의 가장 상위 부모는 <code class="language-plaintext highlighter-rouge">Object</code> 클래스입니다.</p>

<p>객체가 생성될 때의 생성자 호출 순서는 다음과 같은 핵심 원칙을 따릅니다:</p>

<ol>
  <li><strong>자식 클래스의 생성자를 호출하면, 가장 먼저 부모 클래스의 생성자가 호출됩니다.</strong></li>
  <li>이 과정은 가장 상위의 부모 클래스인 <code class="language-plaintext highlighter-rouge">Object</code> 클래스의 생성자까지 거슬러 올라갑니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Object</code> 클래스의 생성자가 실행 완료되면, 이제 <strong>하위 클래스 방향으로 내려오면서 각 클래스의 생성자 코드 블록이 순차적으로 실행</strong>됩니다.</li>
</ol>

<p><strong>요약하자면, 호출은 위로 올라가서(<code class="language-plaintext highlighter-rouge">Object</code>까지), 실행은 아래로 내려옵니다.</strong></p>

<h3 id="super와-this의-역할"><code class="language-plaintext highlighter-rouge">super()</code>와 <code class="language-plaintext highlighter-rouge">this()</code>의 역할</h3>

<p>생성자 연쇄 호출은 주로 <code class="language-plaintext highlighter-rouge">super()</code>와 <code class="language-plaintext highlighter-rouge">this()</code> 키워드를 통해 제어됩니다.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">super(...)</code></strong>: 부모 클래스의 생성자를 호출할 때 사용합니다.
    <ul>
      <li><strong>반드시 자식 클래스 생성자의 첫 줄에 위치</strong>해야 합니다.</li>
      <li>만약 개발자가 명시적으로 <code class="language-plaintext highlighter-rouge">super()</code>를 호출하지 않으면, 자바 컴파일러가 매개변수 없는 <code class="language-plaintext highlighter-rouge">super()</code>를 <strong>자동으로 첫 줄에 삽입</strong>합니다. (따라서 부모 클래스에 기본 생성자가 없으면 컴파일 에러가 발생할 수 있습니다.)</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">this(...)</code></strong>: 같은 클래스 내의 <strong>다른 생성자를 호출</strong>할 때 사용합니다.
    <ul>
      <li><strong>반드시 해당 생성자의 첫 줄에 위치</strong>해야 합니다.</li>
      <li><code class="language-plaintext highlighter-rouge">this(...)</code>를 호출하는 경우, <code class="language-plaintext highlighter-rouge">super()</code>는 명시적으로 호출할 수 없으며, <code class="language-plaintext highlighter-rouge">this(...)</code>가 호출하는 다른 생성자에서 최종적으로 <code class="language-plaintext highlighter-rouge">super()</code>가 호출되게 됩니다.</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="2-상속-관계에서의-생성자-호출-예제">2. 상속 관계에서의 생성자 호출 예제</h2>

<p>아래 코드를 통해 실제 생성자 호출 순서가 어떻게 이루어지는지 살펴보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 최상위 부모 (Grandparent) 클래스</span>
<span class="kd">class</span> <span class="nc">Grandparent</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">gVal</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Grandparent</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">gVal</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Grandparent 기본 생성자 호출 (gVal="</span> <span class="o">+</span> <span class="n">gVal</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">Grandparent</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">gVal</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Grandparent(int) 생성자 호출 (gVal="</span> <span class="o">+</span> <span class="n">gVal</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 부모 (Parent) 클래스 - Grandparent 상속</span>
<span class="kd">class</span> <span class="nc">Parent</span> <span class="kd">extends</span> <span class="nc">Grandparent</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">pVal</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Parent</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// super(); // 컴파일러가 자동으로 Grandparent의 기본 생성자를 삽입</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pVal</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Parent 기본 생성자 호출 (pVal="</span> <span class="o">+</span> <span class="n">pVal</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">Parent</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span> <span class="c1">// Grandparent(int) 생성자 명시적 호출</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pVal</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Parent(String) 생성자 호출 (pVal="</span> <span class="o">+</span> <span class="n">pVal</span> <span class="o">+</span> <span class="s">", name="</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 자식 (Child) 클래스 - Parent 상속</span>
<span class="kd">class</span> <span class="nc">Child</span> <span class="kd">extends</span> <span class="nc">Parent</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">cVal</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Child</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// super(); // 컴파일러가 자동으로 Parent의 기본 생성자를 삽입</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cVal</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Child 기본 생성자 호출 (cVal="</span> <span class="o">+</span> <span class="n">cVal</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">Child</span><span class="o">(</span><span class="kt">int</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="s">"데이터: "</span> <span class="o">+</span> <span class="n">data</span><span class="o">);</span> <span class="c1">// Child 클래스 내의 다른 생성자(String 매개변수) 호출</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Child(int) 생성자 호출 완료 (cVal="</span> <span class="o">+</span> <span class="n">cVal</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">Child</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">message</span><span class="o">);</span> <span class="c1">// Parent 클래스의 String 매개변수 생성자 명시적 호출</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cVal</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Child(String) 생성자 호출 (cVal="</span> <span class="o">+</span> <span class="n">cVal</span> <span class="o">+</span> <span class="s">", message="</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">")"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConstructorChainingExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--- 1. Child 객체 생성: new Child() ---"</span><span class="o">);</span>
        <span class="nc">Child</span> <span class="n">c1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Child</span><span class="o">();</span>
        <span class="cm">/*
         * 예상 호출 및 실행 순서:
         * 1. new Child() 호출
         * 2. Child() 생성자 내부에서 (자동으로 삽입된) super() 호출 -&gt; Parent() 호출
         * 3. Parent() 생성자 내부에서 (자동으로 삽입된) super() 호출 -&gt; Grandparent() 호출
         * 4. Grandparent() 생성자 실행 (Object 생성자까지 갔다가 돌아옴)
         * -&gt; "Grandparent 기본 생성자 호출..." 출력
         * 5. Parent() 생성자 실행
         * -&gt; "Parent 기본 생성자 호출..." 출력
         * 6. Child() 생성자 실행
         * -&gt; "Child 기본 생성자 호출..." 출력
         */</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\n--- 2. Child 객체 생성: new Child(500) ---"</span><span class="o">);</span>
        <span class="nc">Child</span> <span class="n">c2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Child</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="cm">/*
         * 예상 호출 및 실행 순서:
         * 1. new Child(500) 호출
         * 2. Child(int data) 생성자 내부에서 this("데이터: " + data) 호출 -&gt; Child(String) 호출
         * 3. Child(String message) 생성자 내부에서 super(message) 호출 -&gt; Parent(String) 호출
         * 4. Parent(String name) 생성자 내부에서 super(100) 호출 -&gt; Grandparent(int) 호출
         * 5. Grandparent(int) 생성자 실행 (Object 생성자까지 갔다가 돌아옴)
         * -&gt; "Grandparent(int) 생성자 호출..." 출력
         * 6. Parent(String) 생성자 실행
         * -&gt; "Parent(String) 생성자 호출..." 출력
         * 7. Child(String) 생성자 실행
         * -&gt; "Child(String) 생성자 호출..." 출력
         * 8. Child(int) 생성자 실행
         * -&gt; "Child(int) 생성자 호출 완료" 출력
         */</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--- 1. Child 객체 생성: new Child() ---
Grandparent 기본 생성자 호출 (gVal=0)
Parent 기본 생성자 호출 (pVal=0)
Child 기본 생성자 호출 (cVal=0)

--- 2. Child 객체 생성: new Child(500) ---
Grandparent(int) 생성자 호출 (gVal=100)
Parent(String) 생성자 호출 (pVal=8, name=데이터: 500)
Child(String) 생성자 호출 (cVal=8, message=데이터: 500)
Child(int) 생성자 호출 완료 (cVal=8)
</code></pre></div></div>

<p>위 결과를 보면, 객체를 생성할 때 항상 가장 상위의 부모 생성자부터 호출되어 내부 로직이 실행된 후, 차례대로 자식 생성자의 로직이 실행되는 것을 명확히 확인할 수 있습니다. <code class="language-plaintext highlighter-rouge">this()</code>와 <code class="language-plaintext highlighter-rouge">super()</code>를 어떻게 사용하느냐에 따라 생성자 호출 연쇄의 경로가 달라집니다.</p>

<hr />

<h2 id="3-왜-이런-호출-순서가-중요할까">3. 왜 이런 호출 순서가 중요할까?</h2>

<p>생성자 연쇄 호출의 원리를 이해하는 것은 다음과 같은 이유로 중요합니다:</p>

<ul>
  <li><strong>객체 초기화의 안정성</strong>: 부모 클래스의 멤버(필드, 메소드)가 먼저 초기화되어야 자식 클래스에서 이를 안전하게 사용할 수 있습니다. 이 순서가 보장되지 않으면 자식 생성자가 부모의 미초기화된 멤버를 사용하려다 오류가 발생할 수 있습니다.</li>
  <li><strong>자원 할당 및 해제</strong>: 복잡한 객체 초기화 과정에서 부모 객체가 먼저 필요한 자원을 할당하고, 자식 객체가 그 위에 추가적인 자원을 할당하는 방식으로 일관성을 유지할 수 있습니다.</li>
  <li><strong>코드 이해 및 디버깅</strong>: 객체 생성 시 예상치 못한 동작이 발생했을 때, 생성자 호출 순서를 알면 문제의 원인을 더 쉽게 파악하고 디버깅할 수 있습니다.</li>
</ul>

<hr />

<h2 id="-요약-정리-상속과-생성자-호출-순서">📌 요약 정리: 상속과 생성자 호출 순서</h2>

<ul>
  <li><strong>생성자 연쇄 호출(Constructor Chaining)</strong>: 상속 관계에서 자식 클래스 객체 생성 시, 부모 클래스의 생성자가 먼저 호출되는 일련의 과정.</li>
  <li><strong>호출 순서</strong>:
    <ol>
      <li>자식 생성자가 호출되면, 내부적으로 <code class="language-plaintext highlighter-rouge">super()</code> (명시적 또는 자동 삽입)를 통해 부모 생성자를 호출.</li>
      <li>이 과정이 <code class="language-plaintext highlighter-rouge">Object</code> 클래스까지 재귀적으로 반복.</li>
      <li><code class="language-plaintext highlighter-rouge">Object</code> 생성자부터 시작하여 <strong>가장 상위 부모 -&gt; 중간 부모 -&gt; 자식 클래스 순서로 각 생성자 내부의 코드 블록이 실행</strong>됨.</li>
    </ol>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">super(...)</code></strong>: 자식 생성자의 첫 줄에서 부모 생성자를 호출.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">this(...)</code></strong>: 같은 클래스 내의 다른 생성자를 호출. <code class="language-plaintext highlighter-rouge">this()</code>가 <code class="language-plaintext highlighter-rouge">super()</code>를 대신 호출하는 역할.</li>
  <li><strong>중요성</strong>: 객체의 안정적인 초기화 보장, 자원 관리의 일관성 유지, 디버깅 용이성 향상.</li>
</ul>

<hr />

<h2 id="-생성자-호출-순서-퀴즈">💡 생성자 호출 순서 퀴즈</h2>

<p>다음 코드를 실행했을 때 출력 결과는 무엇일까요?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"A's Constructor"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"A's Constructor with int: "</span> <span class="o">+</span> <span class="n">x</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="no">A</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">B</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"B's Constructor"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">B</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">());</span> <span class="c1">// A 클래스의 int 매개변수 생성자 호출</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"B's Constructor with String: "</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">C</span> <span class="kd">extends</span> <span class="no">B</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">C</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// super(); // 컴파일러 자동 삽입 (B의 기본 생성자 호출)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"C's Constructor"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">C</span><span class="o">(</span><span class="kt">double</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="s">"Value: "</span> <span class="o">+</span> <span class="n">d</span><span class="o">);</span> <span class="c1">// C 클래스의 String 매개변수 생성자 호출</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"C's Constructor with double: "</span> <span class="o">+</span> <span class="n">d</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">C</span><span class="o">(</span><span class="nc">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// super(); // 컴파일러 자동 삽입 (B의 기본 생성자 호출) -&gt; 하지만 이 경우엔 B의 기본 생성자가 아닌 String 생성자가 호출되어야 한다.</span>
        <span class="c1">// 올바른 호출을 위해서는 super(String)을 명시적으로 호출해야 합니다.</span>
        <span class="c1">// 예를 들어, super(msg + " from C");</span>
        <span class="c1">// 이 예제에서는 B의 기본 생성자가 호출됩니다.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"C's Constructor with String: "</span> <span class="o">+</span> <span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConstructorQuiz</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--- Creating C1 ---"</span><span class="o">);</span>
        <span class="no">C</span> <span class="n">c1</span> <span class="o">=</span> <span class="k">new</span> <span class="no">C</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\n--- Creating C2 ---"</span><span class="o">);</span>
        <span class="no">C</span> <span class="n">c2</span> <span class="o">=</span> <span class="k">new</span> <span class="no">C</span><span class="o">(</span><span class="mf">3.14</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<details>
<summary>정답 보기</summary>
<br />


출력 결과:
<br /><br />

--- Creating C1 ---<br />
A's Constructor<br />
B's Constructor<br />
C's Constructor<br />
<br />
--- Creating C2 ---<br />
A's Constructor<br />
B's Constructor<br />
C's Constructor with String: Value: 3.14<br />
C's Constructor with double: 3.14<br />
<br />
<br />

**주의:** 위 퀴즈의 `C(String msg)` 생성자에 대한 주석은 약간 혼란을 줄 수 있습니다. 자바 컴파일러는 `super()`나 `this()`가 없으면 **무조건 `super()`를 삽입**하며, 이는 **부모의 기본 생성자를 호출**합니다. 따라서 `C(String msg)`에서는 `B()`가 호출됩니다.


<br />
설명:
<br />

1.  **`new C()`**:<br /><br />

      * `C()` 호출. `super()`가 생략되어 `B()`를 호출.<br />
      * `B()` 호출. `super()`가 생략되어 `A()`를 호출.<br />
      * `A()` 호출. 실행: "A's Constructor"<br />
      * `B()` 실행: "B's Constructor"<br />
      * `C()` 실행: "C's Constructor"<br /><br />

2.  **`new C(3.14)`**:<br /><br />

      * `C(double d)` 호출. `this("Value: " + d)`를 통해 `C(String)`을 호출.<br />
      * `C(String msg)` 호출. `super()`가 생략되어 `B()`를 호출.<br />
      * `B()` 호출. `super()`가 생략되어 `A()`를 호출.<br />
      * `A()` 실행: "A's Constructor"<br />
      * `B()` 실행: "B's Constructor"<br />
      * `C(String)` 실행: "C's Constructor with String: Value: 3.14"<br />
      * `C(double)` 실행: "C's Constructor with double: 3.14"<br /><br />

이 퀴즈는 `super()`가 명시되지 않았을 때 컴파일러가 부모의 기본 생성자를 자동으로 호출한다는 규칙과 `this()`를 통한 생성자 연쇄 호출을 잘 보여줍니다.

</details>

<hr />

<h2 id="-마치며-객체의-완벽한-탄생">🔚 마치며: 객체의 완벽한 탄생</h2>

<p>이번 글에서는 자바 객체지향 프로그래밍에서 매우 중요한 **생성자 연쇄 호출(Constructor Chaining)**의 원리와 동작 방식에 대해 상세히 알아보았습니다. 특히 상속 관계에서 <code class="language-plaintext highlighter-rouge">super()</code>와 <code class="language-plaintext highlighter-rouge">this()</code> 키워드가 생성자 호출 흐름을 어떻게 제어하는지 예제를 통해 확인했습니다.</p>

<p>객체가 생성될 때 가장 상위 부모부터 시작하여 자식 클래스 방향으로 생성자가 연쇄적으로 호출되고 실행된다는 점을 명심하는 것은, 객체의 올바른 초기화를 보장하고 복잡한 시스템에서 발생할 수 있는 초기화 관련 오류를 이해하고 해결하는 데 필수적인 지식입니다.</p>

<p>이로써 객체지향의 핵심인 클래스, 객체, 생성자, 그리고 상속 및 다형성 개념을 깊이 있게 다루었습니다. 다음 글에서는 객체지향의 마지막 큰 축인 **인터페이스(Interface)**와 그 활용에 대해 알아보겠습니다.</p>]]></content><author><name>Lorem</name><email>loremipsum0115@gmail.com</email></author><category term="java" /><summary type="html"><![CDATA[]]></summary></entry><entry xml:lang="ko"><title type="html">자바 객체지향-상속, 다형성, 추상 클래스</title><link href="https://loremipsum0116.github.io/ko/java-oop&inheritance/" rel="alternate" type="text/html" title="자바 객체지향-상속, 다형성, 추상 클래스" /><published>2025-06-17T02:38:47+00:00</published><updated>2025-06-17T02:38:47+00:00</updated><id>https://loremipsum0116.github.io/ko/java-oop&amp;inheritance</id><content type="html" xml:base="https://loremipsum0116.github.io/ko/java-oop&amp;inheritance/"><![CDATA[<hr />

<h2 id="자바-객체지향-프로그래밍-상속과-다형성-추상-클래스">자바 객체지향 프로그래밍: 상속과 다형성, 추상 클래스</h2>

<p>이전 글들에서 객체지향의 기본 요소인 <strong>클래스, 객체, 생성자, 그리고 캡슐화</strong>에 대해 알아보았습니다. 이제 객체지향 프로그래밍의 또 다른 강력한 기둥인 **상속(Inheritance)**과 <strong>다형성(Polymorphism)</strong>, 그리고 이와 밀접하게 관련된 <strong>추상 클래스(Abstract Class)</strong> 개념을 탐구할 차례입니다. 이 개념들은 코드의 <strong>재사용성을 극대화</strong>하고, 프로그램을 더욱 <strong>유연하고 확장 가능</strong>하게 만듭니다.</p>

<p>현실 세계에서 우리는 부모로부터 유전적 특성을 물려받듯, 프로그램에서도 특정 클래스가 다른 클래스의 특성(속성, 행동)을 물려받아 재사용하고 확장할 수 있습니다. 이것이 바로 상속의 기본 아이디어입니다. 이러한 상속 관계를 통해 우리는 더 추상적인 개념을 정의하고, 이를 바탕으로 다양한 형태의 객체를 일관된 방식으로 다룰 수 있게 됩니다.</p>

<hr />

<h2 id="1-상속inheritance-코드-재사용의-마법">1. 상속(Inheritance): 코드 재사용의 마법</h2>

<p><strong>상속</strong>은 하나의 클래스가 다른 클래스의 필드(속성)와 메소드(행동)를 물려받아 코드의 <strong>재사용성</strong>을 높이고, 계층적인 관계를 형성하는 객체지향의 핵심 원리입니다. 특성을 물려주는 클래스를 <strong>부모 클래스(Parent Class)</strong> 또는 **슈퍼 클래스(Super Class)**라고 하고, 특성을 물려받는 클래스를 <strong>자식 클래스(Child Class)</strong> 또는 **서브 클래스(Sub Class)**라고 합니다.</p>

<h3 id="상속-구현-extends-키워드">상속 구현: <code class="language-plaintext highlighter-rouge">extends</code> 키워드</h3>

<p>자바에서 상속은 <code class="language-plaintext highlighter-rouge">extends</code> 키워드를 사용하여 구현합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">부모클래스</span> <span class="o">{</span>
    <span class="c1">// 부모 클래스의 필드와 메소드</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">자식클래스</span> <span class="kd">extends</span> <span class="n">부모클래스</span> <span class="o">{</span>
    <span class="c1">// 부모의 필드와 메소드를 물려받음</span>
    <span class="c1">// 자식 클래스 고유의 필드와 메소드 추가 가능</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>상속의 특징:</strong></p>

<ul>
  <li><strong>코드 재사용</strong>: 부모 클래스에 정의된 필드와 메소드를 자식 클래스에서 별도로 구현할 필요 없이 바로 사용할 수 있습니다.</li>
  <li><strong>계층 구조</strong>: 현실 세계의 “is-a” 관계(예: “자동차는 운송수단이다”, “개는 동물이다”)를 모델링하는 데 적합합니다.</li>
  <li><strong>확장성</strong>: 부모 클래스의 기능을 그대로 사용하면서, 자식 클래스에서 새로운 기능(필드, 메소드)을 추가하거나, 부모의 기능을 재정의(오버라이딩)할 수 있습니다.</li>
  <li><strong>단일 상속</strong>: 자바는 다중 상속(여러 부모로부터 동시에 상속)을 허용하지 않고, 하나의 부모 클래스만 상속받을 수 있습니다. (인터페이스를 통해 다중 상속의 장점을 유사하게 구현할 수 있습니다.)</li>
</ul>

<!-- end list -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 부모 클래스: Animal</span>
<span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Animal</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">" (동물) 생성됨."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">"이(가) 먹습니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sleep</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">"이(가) 잠을 잡니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 자식 클래스: Dog (Animal을 상속받음)</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">breed</span><span class="o">;</span> <span class="c1">// Dog 고유의 필드</span>

    <span class="c1">// 자식 클래스 생성자는 부모 클래스 생성자를 호출해야 합니다.</span>
    <span class="c1">// super(...)를 사용하여 부모 생성자를 호출</span>
    <span class="kd">public</span> <span class="nf">Dog</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">,</span> <span class="nc">String</span> <span class="n">breed</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span> <span class="c1">// 부모 클래스(Animal)의 생성자 호출</span>
        <span class="k">this</span><span class="o">.</span><span class="na">breed</span> <span class="o">=</span> <span class="n">breed</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">breed</span> <span class="o">+</span> <span class="s">"종 개 "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">" 생성됨."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Dog 고유의 메소드</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">bark</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">"이(가) 멍멍 짖습니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 메소드 재정의(Override): 부모의 eat() 메소드를 자식에 맞게 변경</span>
    <span class="nd">@Override</span> <span class="c1">// @Override 어노테이션은 필수는 아니지만, 재정의임을 명시하고 컴파일러가 오류를 체크하도록 돕습니다.</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span> <span class="c1">// 부모의 eat() 메소드를 먼저 호출할 수도 있습니다.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">"이(가) 사료를 먹습니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InheritanceExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Animal 객체 생성</span>
        <span class="nc">Animal</span> <span class="n">genericAnimal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">(</span><span class="s">"동물이"</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
        <span class="n">genericAnimal</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
        <span class="n">genericAnimal</span><span class="o">.</span><span class="na">sleep</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---"</span><span class="o">);</span>

        <span class="c1">// Dog 객체 생성 (Animal의 필드와 메소드를 물려받음)</span>
        <span class="nc">Dog</span> <span class="n">myDog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"바둑이"</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="s">"진돗개"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"이름: "</span> <span class="o">+</span> <span class="n">myDog</span><span class="o">.</span><span class="na">name</span><span class="o">);</span> <span class="c1">// 부모로부터 물려받은 필드</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"나이: "</span> <span class="o">+</span> <span class="n">myDog</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>   <span class="c1">// 부모로부터 물려받은 필드</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"품종: "</span> <span class="o">+</span> <span class="n">myDog</span><span class="o">.</span><span class="na">breed</span><span class="o">);</span> <span class="c1">// Dog 고유의 필드</span>

        <span class="n">myDog</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>    <span class="c1">// Dog에서 재정의된 eat() 메소드 호출</span>
        <span class="n">myDog</span><span class="o">.</span><span class="na">sleep</span><span class="o">();</span>  <span class="c1">// 부모로부터 물려받은 sleep() 메소드 호출</span>
        <span class="n">myDog</span><span class="o">.</span><span class="na">bark</span><span class="o">();</span>   <span class="c1">// Dog 고유의 메소드 호출</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>동물이 (동물) 생성됨.
동물이(가) 먹습니다.
동물이(가) 잠을 잡니다.
---
바둑이 (동물) 생성됨.
진돗개종 개 바둑이 생성됨.
이름: 바둑이
나이: 3
품종: 진돗개
바둑이이(가) 먹습니다.
바둑이이(가) 사료를 먹습니다.
바둑이이(가) 잠을 잡니다.
바둑이이(가) 멍멍 짖습니다.
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Dog</code> 클래스는 <code class="language-plaintext highlighter-rouge">Animal</code> 클래스를 상속받아 <code class="language-plaintext highlighter-rouge">name</code>과 <code class="language-plaintext highlighter-rouge">age</code> 필드, <code class="language-plaintext highlighter-rouge">eat()</code>과 <code class="language-plaintext highlighter-rouge">sleep()</code> 메소드를 자동으로 물려받았습니다. 또한 <code class="language-plaintext highlighter-rouge">bark()</code>라는 자신만의 고유한 메소드를 추가하고, 부모의 <code class="language-plaintext highlighter-rouge">eat()</code> 메소드를 <code class="language-plaintext highlighter-rouge">Dog</code>에 맞게 **재정의(Override)**했습니다.</p>

<hr />

<h2 id="2-다형성polymorphism-하나의-참조로-다양한-형태-다루기">2. 다형성(Polymorphism): 하나의 참조로 다양한 형태 다루기</h2>

<p><strong>다형성</strong>은 객체지향 프로그래밍의 가장 강력한 특징 중 하나로, **“하나의 타입으로 여러 형태의 객체를 참조할 수 있는 성질”**을 의미합니다. 좀 더 쉽게 말하면, 부모 타입의 참조 변수로 자식 타입의 객체를 참조할 수 있고, 이 참조 변수를 통해 호출되는 메소드의 실행 결과는 참조하는 객체의 실제 타입에 따라 달라지는 성질입니다.</p>

<h3 id="다형성의-원리-부모-타입--자식-객체">다형성의 원리: 부모 타입 = 자식 객체</h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">부모타입 변수 = new 자식타입();</code></strong> 형태로 객체를 생성하고 참조할 수 있습니다.</li>
  <li>이렇게 참조할 경우, 해당 변수를 통해서는 <strong>부모 타입에 정의된 필드와 메소드만 접근이 가능</strong>합니다.</li>
  <li><strong>하지만</strong>, 자식 클래스에서 <strong>재정의(Override)된 메소드</strong>가 있다면, 부모 타입의 변수로 호출하더라도 <strong>항상 자식 클래스에서 재정의된 메소드가 호출</strong>됩니다. 이를 **동적 바인딩(Dynamic Binding)**이라고 합니다.</li>
</ul>

<!-- end list -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PolymorphismExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 부모 타입 변수로 자식 객체를 참조</span>
        <span class="nc">Animal</span> <span class="n">myAnimal1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"흰둥이"</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"말티즈"</span><span class="o">);</span> <span class="c1">// Animal 타입으로 Dog 객체 참조</span>
        <span class="nc">Animal</span> <span class="n">myAnimal2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">(</span><span class="s">"고양이"</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>     <span class="c1">// Animal 타입으로 Animal 객체 참조</span>

        <span class="c1">// myAnimal1은 Animal 타입이지만, 실제로는 Dog 객체를 참조합니다.</span>
        <span class="n">myAnimal1</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span> <span class="c1">// Dog에서 재정의된 eat() 메소드가 호출됨</span>
        <span class="n">myAnimal1</span><span class="o">.</span><span class="na">sleep</span><span class="o">();</span> <span class="c1">// Animal의 sleep() 메소드 호출 (Dog에는 재정의 안 됨)</span>
        <span class="c1">// myAnimal1.bark(); // 에러! Animal 타입 변수로는 Dog 고유의 bark() 메소드에 접근 불가</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---"</span><span class="o">);</span>

        <span class="c1">// myAnimal2는 Animal 타입으로 Animal 객체를 참조합니다.</span>
        <span class="n">myAnimal2</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span> <span class="c1">// Animal의 eat() 메소드 호출</span>
        <span class="n">myAnimal2</span><span class="o">.</span><span class="na">sleep</span><span class="o">();</span> <span class="c1">// Animal의 sleep() 메소드 호출</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---"</span><span class="o">);</span>

        <span class="c1">// 배열을 이용한 다형성: 하나의 Animal 배열에 여러 종류의 Animal 객체 저장 가능</span>
        <span class="nc">Animal</span><span class="o">[]</span> <span class="n">animals</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>
        <span class="n">animals</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"메리"</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="s">"푸들"</span><span class="o">);</span>
        <span class="n">animals</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">(</span><span class="s">"오리"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">animals</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"로빈"</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="s">"치와와"</span><span class="o">);</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span> <span class="o">:</span> <span class="n">animals</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">animal</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span> <span class="c1">// 모든 동물이 각자의 eat() 방식을 호출 (다형성)</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>흰둥이 (동물) 생성됨.
말티즈종 개 흰둥이 생성됨.
고양이 (동물) 생성됨.
흰둥이이(가) 먹습니다.
흰둥이이(가) 사료를 먹습니다.
흰둥이이(가) 잠을 잡니다.
---
고양이이(가) 먹습니다.
고양이이(가) 잠을 잡니다.
---
메리 (동물) 생성됨.
푸들종 개 메리 생성됨.
오리 (동물) 생성됨.
로빈 (동물) 생성됨.
치와와종 개 로빈 생성됨.
메리이(가) 먹습니다.
메리이(가) 사료를 먹습니다.
오리이(가) 먹습니다.
로빈이(가) 먹습니다.
로빈이(가) 사료를 먹습니다.
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">myAnimal1</code>은 <code class="language-plaintext highlighter-rouge">Animal</code> 타입으로 선언되었지만, 실제로는 <code class="language-plaintext highlighter-rouge">Dog</code> 객체를 참조하고 있기 때문에 <code class="language-plaintext highlighter-rouge">eat()</code> 메소드를 호출하면 <code class="language-plaintext highlighter-rouge">Dog</code> 클래스에서 재정의된 <code class="language-plaintext highlighter-rouge">eat()</code> 메소드가 실행됩니다. 이것이 다형성의 핵심입니다.</p>

<hr />

<h2 id="3-추상-클래스abstract-class-미완성의-설계도">3. 추상 클래스(Abstract Class): 미완성의 설계도</h2>

<p><strong>추상 클래스</strong>는 이름 그대로 ‘추상적인’, 즉 <strong>미완성된 메소드(추상 메소드)를 포함할 수 있는 클래스</strong>입니다. 오로지 <strong>상속을 목적으로 만들어진 클래스</strong>이며, 자식 클래스에게 특정 메소드를 <strong>반드시 구현하도록 강제</strong>함으로써 일관된 기능을 제공하도록 돕습니다.</p>

<h3 id="추상-클래스의-특징">추상 클래스의 특징</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">abstract</code> 키워드를 사용하여 선언합니다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">new</code> 연산자로 직접 객체를 생성할 수 없습니다.</strong> (미완성된 클래스이므로)</li>
  <li>일반 필드, 생성자, 일반 메소드를 가질 수 있습니다.</li>
  <li><strong>추상 메소드</strong>를 포함할 수 있습니다. (하나라도 추상 메소드가 있다면 그 클래스는 반드시 추상 클래스여야 합니다.)</li>
  <li><strong>추상 클래스가 반드시 추상 메소드를 포함해야 하는 것은 아닙니다.</strong> 추상 메소드가 없더라도 <code class="language-plaintext highlighter-rouge">abstract</code> 키워드를 붙여 추상 클래스로 만들 수 있습니다. (이 경우 주로 객체 생성을 막고 상속을 통한 확장만 허용하려는 목적)</li>
  <li>추상 클래스를 상속받는 자식 클래스는 **반드시 부모의 모든 추상 메소드를 오버라이딩(구현)**해야 합니다. 만약 하나라도 구현하지 않는다면, 그 자식 클래스도 추상 클래스가 되어야 합니다.</li>
</ul>

<h3 id="추상-메소드abstract-method">추상 메소드(Abstract Method)</h3>

<ul>
  <li>메소드의 선언부만 있고, <strong>구현부(<code class="language-plaintext highlighter-rouge">{}</code>)가 없는 메소드</strong>입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">abstract</code> 키워드를 사용하여 선언하며, 끝에 세미콜론(;)을 붙입니다.</li>
  <li>반드시 <strong>추상 클래스 내부</strong>에서만 정의될 수 있습니다.</li>
</ul>

<!-- end list -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 추상 클래스: Shape (도형)</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Shape</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">color</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Shape</span><span class="o">(</span><span class="nc">String</span> <span class="n">color</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">color</span> <span class="o">+</span> <span class="s">" 도형 생성."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 일반 메소드</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printColor</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"이 도형의 색상은 "</span> <span class="o">+</span> <span class="n">color</span> <span class="o">+</span> <span class="s">"입니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 추상 메소드: 넓이를 계산하는 방법은 도형마다 다르므로 자식에게 구현을 강제</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">double</span> <span class="nf">calculateArea</span><span class="o">();</span> <span class="c1">// 구현부가 없고 선언만 있음</span>
<span class="o">}</span>

<span class="c1">// Concrete Class (구현 클래스): Circle (원)</span>
<span class="kd">class</span> <span class="nc">Circle</span> <span class="kd">extends</span> <span class="nc">Shape</span> <span class="o">{</span>
    <span class="kt">double</span> <span class="n">radius</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Circle</span><span class="o">(</span><span class="nc">String</span> <span class="n">color</span><span class="o">,</span> <span class="kt">double</span> <span class="n">radius</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">color</span><span class="o">);</span> <span class="c1">// 부모 추상 클래스의 생성자 호출</span>
        <span class="k">this</span><span class="o">.</span><span class="na">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"원 생성됨. 반지름: "</span> <span class="o">+</span> <span class="n">radius</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 추상 메소드 구현 (오버라이딩)</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateArea</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">PI</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Concrete Class (구현 클래스): Rectangle (직사각형)</span>
<span class="kd">class</span> <span class="nc">Rectangle</span> <span class="kd">extends</span> <span class="nc">Shape</span> <span class="o">{</span>
    <span class="kt">double</span> <span class="n">width</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">height</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Rectangle</span><span class="o">(</span><span class="nc">String</span> <span class="n">color</span><span class="o">,</span> <span class="kt">double</span> <span class="n">width</span><span class="o">,</span> <span class="kt">double</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">color</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">width</span> <span class="o">=</span> <span class="n">width</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">height</span> <span class="o">=</span> <span class="n">height</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"직사각형 생성됨. 너비: "</span> <span class="o">+</span> <span class="n">width</span> <span class="o">+</span> <span class="s">", 높이: "</span> <span class="o">+</span> <span class="n">height</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 추상 메소드 구현 (오버라이딩)</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateArea</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AbstractClassExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Shape s = new Shape("Black"); // 에러! 추상 클래스는 직접 객체 생성 불가</span>

        <span class="nc">Circle</span> <span class="n">circle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Circle</span><span class="o">(</span><span class="s">"Red"</span><span class="o">,</span> <span class="mf">5.0</span><span class="o">);</span>
        <span class="n">circle</span><span class="o">.</span><span class="na">printColor</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"원의 넓이: "</span> <span class="o">+</span> <span class="n">circle</span><span class="o">.</span><span class="na">calculateArea</span><span class="o">());</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---"</span><span class="o">);</span>

        <span class="nc">Rectangle</span> <span class="n">rectangle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="s">"Blue"</span><span class="o">,</span> <span class="mf">4.0</span><span class="o">,</span> <span class="mf">6.0</span><span class="o">);</span>
        <span class="n">rectangle</span><span class="o">.</span><span class="na">printColor</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"직사각형의 넓이: "</span> <span class="o">+</span> <span class="n">rectangle</span><span class="o">.</span><span class="na">calculateArea</span><span class="o">());</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--- 다형성을 이용한 추상 클래스 참조 ---"</span><span class="o">);</span>
        <span class="c1">// 부모(추상) 타입으로 자식 객체 참조 가능</span>
        <span class="nc">Shape</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Circle</span><span class="o">(</span><span class="s">"Green"</span><span class="o">,</span> <span class="mf">3.0</span><span class="o">);</span>
        <span class="nc">Shape</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="s">"Yellow"</span><span class="o">,</span> <span class="mf">7.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">);</span>

        <span class="n">s1</span><span class="o">.</span><span class="na">printColor</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"s1의 넓이: "</span> <span class="o">+</span> <span class="n">s1</span><span class="o">.</span><span class="na">calculateArea</span><span class="o">());</span> <span class="c1">// 실제 객체(Circle)의 calculateArea 호출</span>

        <span class="n">s2</span><span class="o">.</span><span class="na">printColor</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"s2의 넓이: "</span> <span class="o">+</span> <span class="n">s2</span><span class="o">.</span><span class="na">calculateArea</span><span class="o">());</span> <span class="c1">// 실제 객체(Rectangle)의 calculateArea 호출</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Red 도형 생성.
원 생성됨. 반지름: 5.0
이 도형의 색상은 Red입니다.
원의 넓이: 78.53981633974483
---
Blue 도형 생성.
직사각형 생성됨. 너비: 4.0, 높이: 6.0
이 도형의 색상은 Blue입니다.
직사각형의 넓이: 24.0
--- 다형성을 이용한 추상 클래스 참조 ---
Green 도형 생성.
원 생성됨. 반지름: 3.0
이 도형의 색상은 Green입니다.
s1의 넓이: 28.27433388230813
Yellow 도형 생성.
직사각형 생성됨. 너비: 7.0, 높이: 2.0
이 도형의 색상은 Yellow입니다.
s2의 넓이: 14.0
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Shape</code> 클래스는 <code class="language-plaintext highlighter-rouge">calculateArea()</code>라는 추상 메소드를 가지고 있으므로 <code class="language-plaintext highlighter-rouge">abstract</code> 클래스가 됩니다. <code class="language-plaintext highlighter-rouge">Circle</code>과 <code class="language-plaintext highlighter-rouge">Rectangle</code>은 <code class="language-plaintext highlighter-rouge">Shape</code>를 상속받아 <code class="language-plaintext highlighter-rouge">calculateArea()</code> 메소드를 각자의 방식대로 <strong>반드시 구현</strong>해야 합니다. 마지막으로, <code class="language-plaintext highlighter-rouge">Shape</code> 타입의 변수로 <code class="language-plaintext highlighter-rouge">Circle</code>과 <code class="language-plaintext highlighter-rouge">Rectangle</code> 객체를 참조하여 <code class="language-plaintext highlighter-rouge">calculateArea()</code>를 호출할 때 <strong>다형성</strong>에 의해 각 객체에 맞는 메소드가 실행되는 것을 확인할 수 있습니다.</p>

<hr />

<h2 id="-요약-정리-상속-다형성-추상-클래스">📌 요약 정리: 상속, 다형성, 추상 클래스</h2>

<ul>
  <li><strong>상속(Inheritance)</strong>: <code class="language-plaintext highlighter-rouge">extends</code> 키워드를 사용하여 부모 클래스의 필드와 메소드를 자식 클래스가 물려받아 재사용하고 확장하는 객체지향 원리.
    <ul>
      <li>자식 클래스 생성자는 <code class="language-plaintext highlighter-rouge">super()</code>를 통해 부모 생성자를 호출해야 합니다.</li>
      <li><strong>메소드 오버라이딩</strong>: 자식 클래스에서 부모의 메소드를 자신에게 맞게 재정의하는 것.</li>
    </ul>
  </li>
  <li><strong>다형성(Polymorphism)</strong>: 하나의 타입으로 여러 형태의 객체를 참조할 수 있는 성질.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">부모타입 변수 = new 자식타입();</code> 형태로 참조 가능.</li>
      <li>부모 타입 변수로는 부모에 정의된 멤버만 접근 가능.</li>
      <li><strong>자식에서 재정의된 메소드는 호출 시 자식의 메소드가 실행됩니다 (동적 바인딩).</strong></li>
    </ul>
  </li>
  <li><strong>추상 클래스(Abstract Class)</strong>: <code class="language-plaintext highlighter-rouge">abstract</code> 키워드로 선언되며, <strong>상속만을 목적으로</strong> 합니다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">new</code> 연산자로 <strong>직접 객체 생성 불가</strong>.</li>
      <li>필드, 생성자, 일반 메소드를 가질 수 있습니다.</li>
      <li>**추상 메소드(Abstract Method)**를 포함할 수 있습니다 (구현부 없음).</li>
      <li><strong>추상 클래스가 반드시 추상 메소드를 포함해야 하는 것은 아닙니다.</strong></li>
      <li>추상 클래스를 상속받는 자식 클래스는 모든 추상 메소드를 <strong>반드시 구현</strong>해야 합니다 (그렇지 않으면 자식 클래스도 추상 클래스가 되어야 함).</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="-상속다형성-퀴즈-동물-소리내기">💡 상속/다형성 퀴즈: 동물 소리내기</h2>

<p>다음 코드를 보고 출력 결과를 예상해 보세요.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Animal2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"동물이 소리를 냅니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="nc">Animal2</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"야옹!"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">groom</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"고양이가 몸단장을 합니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog2</span> <span class="kd">extends</span> <span class="nc">Animal2</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnimalSoundQuiz</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal2</span> <span class="n">animal1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cat</span><span class="o">();</span>
        <span class="nc">Animal2</span> <span class="n">animal2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog2</span><span class="o">();</span>
        <span class="nc">Animal2</span> <span class="n">animal3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal2</span><span class="o">();</span>

        <span class="n">animal1</span><span class="o">.</span><span class="na">sound</span><span class="o">();</span>
        <span class="n">animal2</span><span class="o">.</span><span class="na">sound</span><span class="o">();</span>
        <span class="n">animal3</span><span class="o">.</span><span class="na">sound</span><span class="o">();</span>

        <span class="c1">// animal1.groom(); // 이 코드는 컴파일 될까요?</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<details>
<summary>정답 보기</summary>
<br />
출력 결과:

```
야옹!
멍멍!
동물이 소리를 냅니다.
```

<br />
설명:
<br />

1.  `animal1`은 `Animal2` 타입으로 선언되었지만 `Cat` 객체를 참조하고 있습니다. `Cat`에서 `sound()` 메소드를 재정의했으므로, `animal1.sound()`는 "야옹\!"을 출력합니다.
2.  `animal2`는 `Animal2` 타입으로 선언되었지만 `Dog2` 객체를 참조하고 있습니다. `Dog2`에서 `sound()` 메소드를 재정의했으므로, `animal2.sound()`는 "멍멍\!"을 출력합니다.
3.  `animal3`은 `Animal2` 타입으로 `Animal2` 객체를 참조하고 있습니다. `sound()` 메소드는 재정의되지 않았으므로, `Animal2`의 "동물이 소리를 냅니다."를 출력합니다.
4.  주석 처리된 `animal1.groom()` 코드는 **컴파일 에러**가 발생합니다. `animal1`은 `Animal2` 타입으로 선언되었기 때문에, `Cat` 클래스에만 존재하는 `groom()` 메소드에는 접근할 수 없습니다. 다형성에서 부모 타입 변수는 부모에 정의된 메소드만 호출할 수 있고, 재정의된 메소드만 자식의 것으로 실행됩니다.
    </details>

<hr />

<h2 id="-마치며-유연한-객체지향-설계의-기반">🔚 마치며: 유연한 객체지향 설계의 기반</h2>

<p>이번 글에서는 객체지향 프로그래밍의 핵심 개념인 <strong>상속, 다형성, 그리고 추상 클래스</strong>에 대해 알아보았습니다. 이 개념들은 단순히 코드 재사용을 넘어, 프로그램을 더욱 유연하고 확장 가능하며 유지보수하기 쉽게 만드는 강력한 도구입니다.</p>

<p>상속을 통해 코드 중복을 줄이고 계층적인 관계를 형성하며, 다형성을 통해 하나의 타입으로 다양한 객체를 일관된 방식으로 다룰 수 있게 됩니다. 또한, 추상 클래스는 자식 클래스에게 특정 기능을 구현하도록 강제함으로써, 설계의 일관성을 유지하고 협업을 용이하게 합니다.</p>

<p>이러한 개념들을 잘 이해하고 활용하는 것은 복잡한 소프트웨어를 효율적으로 개발하는 데 필수적입니다. 다음 글에서는 상속, 생성자 관련 핵심 개념인 **생성자 호출 순서**에 대해 알아보겠습니다.</p>]]></content><author><name>Lorem</name><email>loremipsum0115@gmail.com</email></author><category term="java" /><summary type="html"><![CDATA[]]></summary></entry><entry xml:lang="ko"><title type="html">자바 객체지향-클래스(2)</title><link href="https://loremipsum0116.github.io/ko/java-oop&class(2)/" rel="alternate" type="text/html" title="자바 객체지향-클래스(2)" /><published>2025-06-17T02:33:57+00:00</published><updated>2025-06-17T02:33:57+00:00</updated><id>https://loremipsum0116.github.io/ko/java-oop&amp;class(2)</id><content type="html" xml:base="https://loremipsum0116.github.io/ko/java-oop&amp;class(2)/"><![CDATA[<hr />

<h2 id="자바-객체지향-프로그래밍-생성자와-초기화-그리고-캡슐화">자바 객체지향 프로그래밍: 생성자와 초기화, 그리고 캡슐화</h2>

<p>이전 글에서 <strong>클래스, 객체, 인스턴스</strong>의 개념과 <strong>메소드</strong>의 다양한 활용법을 배웠습니다. 이제 객체지향 프로그래밍의 또 다른 핵심 요소인 **생성자(Constructor)**를 통해 객체가 처음 만들어질 때 어떻게 초기화되는지 알아보겠습니다. 또한, 객체지향의 중요한 원칙 중 하나인 **캡슐화(Encapsulation)**를 구현하는 방법과 이를 위한 <strong>접근 제어자(Access Modifier)</strong>, 그리고 <strong>Getter/Setter</strong> 메소드에 대해서도 깊이 있게 다룰 것입니다.</p>

<p>객체지향은 현실 세계를 모델링하는 데 초점을 둡니다. 이는 단순히 기능(메소드)을 정의하는 것을 넘어, 객체가 안전하고 올바른 ‘상태’로 시작하고 유지되도록 하는 것을 포함합니다. 생성자와 캡슐화는 이러한 ‘객체의 올바른 상태 관리’에 필수적인 도구입니다.</p>

<hr />

<h2 id="1-생성자constructor-객체-초기화의-시작점">1. 생성자(Constructor): 객체 초기화의 시작점</h2>

<p><strong>생성자</strong>는 클래스로부터 <strong>객체(인스턴스)를 생성할 때 딱 한 번 호출되는 특별한 형태의 메소드</strong>입니다. 주된 목적은 생성되는 객체의 <strong>인스턴스 변수를 초기화</strong>하거나, 객체 사용에 필요한 초기 설정을 하는 것입니다.</p>

<h3 id="생성자의-특징">생성자의 특징</h3>

<ul>
  <li><strong>이름이 클래스 이름과 동일</strong>해야 합니다.</li>
  <li><strong>반환 타입(void 포함)을 명시하지 않습니다.</strong></li>
  <li><code class="language-plaintext highlighter-rouge">new</code> 연산자와 함께 호출됩니다.</li>
  <li>클래스에 생성자가 하나도 없으면, 자바 컴파일러가 매개변수 없는 **기본 생성자(Default Constructor)**를 자동으로 추가해 줍니다.</li>
</ul>

<!-- end list -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>  <span class="c1">// 인스턴스 변수</span>
    <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>      <span class="c1">// 인스턴스 변수</span>
    <span class="nc">String</span> <span class="n">gender</span><span class="o">;</span> <span class="c1">// 인스턴스 변수</span>

    <span class="c1">// 1. 기본 생성자 (매개변수가 없음)</span>
    <span class="c1">// 개발자가 명시적으로 정의하지 않으면 컴파일러가 자동 추가</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"기본 생성자가 호출되었습니다."</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"이름없음"</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">gender</span> <span class="o">=</span> <span class="s">"미정"</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 2. 매개변수가 있는 생성자 (이름과 나이를 초기화)</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// this.name은 인스턴스 변수 name, name은 매개변수 name</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">gender</span> <span class="o">=</span> <span class="s">"미정"</span><span class="o">;</span> <span class="c1">// 다른 필드는 기본값으로 초기화 또는 명시</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">" ("</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span> <span class="s">"세) Person 객체가 생성되었습니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 3. 매개변수가 더 많은 생성자 (이름, 나이, 성별 초기화)</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">,</span> <span class="nc">String</span> <span class="n">gender</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// this(...)를 사용하여 다른 생성자를 호출할 수 있습니다.</span>
        <span class="c1">// 첫 줄에서만 사용 가능하며, 다른 초기화 코드보다 먼저 실행되어야 합니다.</span>
        <span class="k">this</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span> <span class="c1">// 매개변수 2개짜리 생성자 호출 (코드 중복 방지)</span>
        <span class="k">this</span><span class="o">.</span><span class="na">gender</span> <span class="o">=</span> <span class="n">gender</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"성별 포함, "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">" Person 객체 생성 완료."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">introduce</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"안녕하세요, 저는 "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"이고 "</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span> <span class="s">"세이며, "</span> <span class="o">+</span> <span class="n">gender</span> <span class="o">+</span> <span class="s">"입니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Person</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">();</span> <span class="c1">// 기본 생성자 호출</span>
        <span class="n">p1</span><span class="o">.</span><span class="na">introduce</span><span class="o">();</span> <span class="c1">// 출력: 안녕하세요, 저는 이름없음이고 0세이며, 미정입니다.</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---"</span><span class="o">);</span>

        <span class="nc">Person</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"김철수"</span><span class="o">,</span> <span class="mi">25</span><span class="o">);</span> <span class="c1">// 매개변수 2개짜리 생성자 호출</span>
        <span class="n">p2</span><span class="o">.</span><span class="na">introduce</span><span class="o">();</span> <span class="c1">// 출력: 안녕하세요, 저는 김철수이고 25세이며, 미정입니다.</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"---"</span><span class="o">);</span>

        <span class="nc">Person</span> <span class="n">p3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"이영희"</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="s">"여성"</span><span class="o">);</span> <span class="c1">// 매개변수 3개짜리 생성자 호출</span>
        <span class="n">p3</span><span class="o">.</span><span class="na">introduce</span><span class="o">();</span> <span class="c1">// 출력: 안녕하세요, 저는 이영희이고 30세이며, 여성입니다.</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="2-생성자-오버로딩-constructor-overloading">2. 생성자 오버로딩 (Constructor Overloading)</h2>

<p>메소드 오버로딩과 마찬가지로, <strong>생성자도 오버로딩이 가능</strong>합니다. 즉, <strong>매개변수의 개수, 타입, 또는 순서가 다른 여러 개의 생성자를 한 클래스 안에 정의</strong>할 수 있습니다. 이를 통해 객체를 다양한 방식으로 초기화할 수 있는 유연성을 제공합니다.</p>

<p>위 <code class="language-plaintext highlighter-rouge">Person</code> 클래스의 예시에서 이미 <strong>생성자 오버로딩</strong>이 적용되어 있습니다. 매개변수가 없는 생성자, 이름과 나이만 받는 생성자, 그리고 이름, 나이, 성별을 모두 받는 생성자까지 세 가지 형태의 생성자를 정의했습니다.</p>

<h3 id="this를-이용한-다른-생성자-호출-참조변수-this-활용"><code class="language-plaintext highlighter-rouge">this()</code>를 이용한 다른 생성자 호출 (참조변수 <code class="language-plaintext highlighter-rouge">this</code> 활용)</h3>

<p>생성자 오버로딩 시 <strong><code class="language-plaintext highlighter-rouge">this()</code> 키워드</strong>를 사용하면 같은 클래스 내의 <strong>다른 생성자를 호출</strong>할 수 있습니다. 이는 생성자 간의 코드 중복을 줄이고 유지보수성을 높이는 데 유용합니다. <code class="language-plaintext highlighter-rouge">this()</code> 호출은 <strong>반드시 생성자의 첫 줄에 위치</strong>해야 합니다.</p>

<p><code class="language-plaintext highlighter-rouge">Person</code> 클래스의 세 번째 생성자 <code class="language-plaintext highlighter-rouge">public Person(String name, int age, String gender)</code>에서 <code class="language-plaintext highlighter-rouge">this(name, age);</code>를 사용하여 매개변수 두 개인 생성자를 호출하는 것이 그 예시입니다. 이렇게 하면 이름과 나이를 초기화하는 코드를 중복해서 작성할 필요가 없어집니다.</p>

<hr />

<h2 id="3-변수-초기화-인스턴스-static-지역-변수">3. 변수 초기화: 인스턴스, static, 지역 변수</h2>

<p>자바에서 변수는 사용되기 전에 반드시 초기화되어야 합니다. 변수의 종류에 따라 초기화되는 시점과 방식이 다릅니다.</p>

<h3 id="3-1-인스턴스-변수-초기화">3-1. 인스턴스 변수 초기화</h3>

<p>객체(인스턴스)가 생성될 때 초기화됩니다.</p>

<ul>
  <li><strong>명시적 초기화</strong>: 선언과 동시에 값을 할당합니다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">instanceVar</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span> <span class="c1">// 명시적 초기화</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>생성자를 통한 초기화</strong>: 생성자 내부에서 인스턴스 변수를 초기화합니다. (가장 일반적이고 권장되는 방법)
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span> <span class="c1">// 생성자를 통한 초기화</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>초기화 블록 (Instance Initializer Block)</strong>: 인스턴스 생성 시 생성자보다 먼저 실행되는 코드 블록입니다. 여러 생성자에서 공통적으로 초기화해야 할 내용이 있을 때 유용하지만, 잘 사용되지는 않습니다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">instanceVar</span><span class="o">;</span>
    <span class="o">{</span> <span class="c1">// 인스턴스 초기화 블록</span>
        <span class="n">instanceVar</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"인스턴스 초기화 블록 실행"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">()</span> <span class="o">{</span> <span class="cm">/* ... */</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>기본값 (Default Value)</strong>: 만약 인스턴스 변수가 초기화되지 않으면, 자바는 해당 타입의 기본값으로 자동 초기화합니다. (숫자 타입: 0, boolean: false, 참조 타입: null)</li>
</ul>

<h3 id="3-2-static-변수-클래스-변수-초기화">3-2. static 변수 (클래스 변수) 초기화</h3>

<p>클래스가 메모리에 로드될 때(가장 먼저) 초기화됩니다. 단 한 번만 초기화됩니다.</p>

<ul>
  <li><strong>명시적 초기화</strong>: 선언과 동시에 값을 할당합니다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">staticVar</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span> <span class="c1">// 명시적 초기화</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>static 초기화 블록 (Static Initializer Block)</strong>: 클래스가 로드될 때 실행되는 코드 블록입니다. 복잡한 static 변수 초기화 로직에 사용됩니다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="nc">String</span> <span class="n">appName</span><span class="o">;</span>
    <span class="kd">static</span> <span class="o">{</span> <span class="c1">// static 초기화 블록</span>
        <span class="n">appName</span> <span class="o">=</span> <span class="s">"My Awesome App"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Static 초기화 블록 실행"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>기본값 (Default Value)</strong>: 인스턴스 변수와 마찬가지로, static 변수도 초기화되지 않으면 해당 타입의 기본값으로 자동 초기화됩니다.</li>
</ul>

<h3 id="3-3-지역-변수-초기화">3-3. 지역 변수 초기화</h3>

<p>메소드나 블록 내에서 선언되는 지역 변수는 <strong>반드시 사용하기 전에 개발자가 직접 초기화</strong>해야 합니다. 명시적으로 초기화하지 않으면 컴파일 에러가 발생합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">myMethod</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">localVar</span><span class="o">;</span> <span class="c1">// 지역 변수</span>
        <span class="c1">// System.out.println(localVar); // 에러! 초기화되지 않은 지역 변수 사용 시도</span>
        <span class="n">localVar</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span> <span class="c1">// 직접 초기화</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">localVar</span><span class="o">);</span> <span class="c1">// 5 출력</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="3-4-변수-초기화-순서">3-4. 변수 초기화 순서</h3>

<p>클래스가 로드되고 객체가 생성될 때, 변수들이 초기화되는 순서는 다음과 같습니다.</p>

<ol>
  <li><strong>static 변수 및 static 초기화 블록</strong>: 클래스 로딩 시점에 정의된 순서대로 실행됩니다.</li>
  <li><strong>인스턴스 변수 명시적 초기화 및 인스턴스 초기화 블록</strong>: 객체 생성 시점에 정의된 순서대로 실행됩니다.</li>
  <li><strong>생성자</strong>: 마지막으로 생성자가 실행되어 인스턴스 변수를 최종적으로 초기화합니다.</li>
</ol>

<!-- end list -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InitializationOrder</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">sNum</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"1. static 초기화 블록: sNum = "</span> <span class="o">+</span> <span class="n">sNum</span><span class="o">++);</span> <span class="c1">// 1</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="n">iNum</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="o">{</span> <span class="c1">// 인스턴스 초기화 블록</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"2. 인스턴스 초기화 블록: iNum = "</span> <span class="o">+</span> <span class="n">iNum</span><span class="o">++);</span> <span class="c1">// 10</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">InitializationOrder</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"3. 생성자 호출: iNum = "</span> <span class="o">+</span> <span class="n">iNum</span><span class="o">++);</span> <span class="c1">// 11</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main 메소드 시작"</span><span class="o">);</span>
        <span class="nc">InitializationOrder</span> <span class="n">order1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InitializationOrder</span><span class="o">();</span> <span class="c1">// 객체 생성</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"order1.iNum: "</span> <span class="o">+</span> <span class="n">order1</span><span class="o">.</span><span class="na">iNum</span><span class="o">);</span> <span class="c1">// 12</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"order1.sNum: "</span> <span class="o">+</span> <span class="nc">InitializationOrder</span><span class="o">.</span><span class="na">sNum</span><span class="o">);</span> <span class="c1">// 2</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. static 초기화 블록: sNum = 1
main 메소드 시작
2. 인스턴스 초기화 블록: iNum = 10
3. 생성자 호출: iNum = 11
order1.iNum: 12
order1.sNum: 2
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sNum</code>은 클래스 로드 시점에 초기화되고, <code class="language-plaintext highlighter-rouge">iNum</code>은 객체가 생성될 때마다 매번 초기화되는 것을 알 수 있습니다.</p>

<hr />

<h2 id="4-접근-제어자access-modifier와-캡슐화encapsulation">4. 접근 제어자(Access Modifier)와 캡슐화(Encapsulation)</h2>

<p>객체지향의 중요한 원칙 중 하나는 **정보 은닉(Information Hiding)**입니다. 이는 객체 내부의 중요한 데이터를 외부에서 함부로 변경하거나 접근하지 못하도록 막는 것을 의미하며, 이를 통해 객체의 **무결성(Integrity)**을 유지하고 코드의 <strong>유지보수성</strong>을 높일 수 있습니다. 자바에서는 <strong>접근 제어자</strong>와 <strong>Getter/Setter 메소드</strong>를 통해 캡슐화를 구현합니다.</p>

<h3 id="4-1-접근-제어자-access-modifier">4-1. 접근 제어자 (Access Modifier)</h3>

<p>접근 제어자는 클래스, 필드(변수), 메소드, 생성자 등의 멤버에 대한 접근 범위를 지정하는 키워드입니다.</p>

<table>
  <thead>
    <tr>
      <th>접근 제어자</th>
      <th>설명</th>
      <th>접근 가능 범위</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">public</code></td>
      <td>모든 곳에서 접근 가능합니다. (가장 넓은 범위)</td>
      <td>같은 패키지 + 다른 패키지</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">protected</code></td>
      <td>같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능합니다.</td>
      <td>같은 패키지 + 다른 패키지의 자손 클래스</td>
    </tr>
    <tr>
      <td>(default)</td>
      <td>아무런 접근 제어자를 붙이지 않은 경우. 같은 패키지 내에서만 접근 가능합니다.</td>
      <td>같은 패키지 내</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">private</code></td>
      <td>해당 클래스 내부에서만 접근 가능합니다. (가장 좁은 범위)</td>
      <td>같은 클래스 내</td>
    </tr>
  </tbody>
</table>

<h3 id="4-2-캡슐화-구현-encapsulation">4-2. 캡슐화 구현 (Encapsulation)</h3>

<p>캡슐화는 데이터(필드)와 그 데이터를 조작하는 메소드를 하나로 묶고, 외부로부터 데이터를 직접 접근하는 것을 막아 <strong>데이터를 보호</strong>하는 객체지향의 핵심 원칙입니다. 즉, 객체의 내부 구현을 숨기고, 미리 정의된 메소드를 통해서만 상호작용하도록 합니다.</p>

<p><strong>캡슐화 구현 단계:</strong></p>

<ol>
  <li><strong>필드(인스턴스 변수)를 <code class="language-plaintext highlighter-rouge">private</code>으로 선언</strong>하여 외부 직접 접근을 막습니다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">public</code> 메소드(Getter/Setter)를 통해 간접적으로 필드에 접근</strong>하도록 허용합니다.</li>
</ol>

<!-- end list -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Account</span> <span class="o">{</span>
    <span class="c1">// 1. private으로 선언된 필드 (외부에서 직접 접근 불가)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">accountNumber</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">balance</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">ownerName</span><span class="o">;</span>

    <span class="c1">// 생성자 (필드 초기화)</span>
    <span class="kd">public</span> <span class="nf">Account</span><span class="o">(</span><span class="nc">String</span> <span class="n">accountNumber</span><span class="o">,</span> <span class="nc">String</span> <span class="n">ownerName</span><span class="o">,</span> <span class="kt">double</span> <span class="n">balance</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">accountNumber</span> <span class="o">=</span> <span class="n">accountNumber</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ownerName</span> <span class="o">=</span> <span class="n">ownerName</span><span class="o">;</span>
        <span class="c1">// 잔액은 음수가 될 수 없도록 검증 로직 추가</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">balance</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">balance</span> <span class="o">=</span> <span class="n">balance</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">balance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"경고: 초기 잔액은 음수가 될 수 없습니다. 0으로 설정됩니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 2. Getter 메소드: 필드 값을 읽을 때 사용 (public)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getAccountNumber</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">accountNumber</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getBalance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">balance</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getOwnerName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">ownerName</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 3. Setter 메소드: 필드 값을 변경할 때 사용 (public)</span>
    <span class="c1">// 잔액 변경 시 유효성 검증 로직 추가 가능</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deposit</span><span class="o">(</span><span class="kt">double</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 입금 (setter 역할 겸용)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">balance</span> <span class="o">+=</span> <span class="n">amount</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">amount</span> <span class="o">+</span> <span class="s">"원이 입금되었습니다. 현재 잔액: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">balance</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"입금액은 0보다 커야 합니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">withdraw</span><span class="o">(</span><span class="kt">double</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 출금 (setter 역할 겸용)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">balance</span> <span class="o">&gt;=</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">balance</span> <span class="o">-=</span> <span class="n">amount</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">amount</span> <span class="o">+</span> <span class="s">"원이 출금되었습니다. 현재 잔액: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">balance</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"출금액이 유효하지 않거나 잔액이 부족합니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 이름은 변경할 일이 적다고 가정하고 Setter를 만들지 않을 수도 있습니다.</span>
    <span class="c1">// public void setOwnerName(String ownerName) {</span>
    <span class="c1">//     this.ownerName = ownerName;</span>
    <span class="c1">// }</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Account</span> <span class="n">myAccount</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Account</span><span class="o">(</span><span class="s">"123-456-7890"</span><span class="o">,</span> <span class="s">"홍길동"</span><span class="o">,</span> <span class="mf">10000.0</span><span class="o">);</span>

        <span class="c1">// myAccount.balance = -5000; // private 필드이므로 직접 접근 불가 (컴파일 에러)</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"계좌번호: "</span> <span class="o">+</span> <span class="n">myAccount</span><span class="o">.</span><span class="na">getAccountNumber</span><span class="o">());</span> <span class="c1">// Getter로 값 읽기</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"현재 잔액: "</span> <span class="o">+</span> <span class="n">myAccount</span><span class="o">.</span><span class="na">getBalance</span><span class="o">());</span>     <span class="c1">// Getter로 값 읽기</span>

        <span class="n">myAccount</span><span class="o">.</span><span class="na">deposit</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span> <span class="c1">// Setter 역할을 하는 메소드로 잔액 변경</span>
        <span class="n">myAccount</span><span class="o">.</span><span class="na">withdraw</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span> <span class="c1">// Setter 역할을 하는 메소드로 잔액 변경</span>
        <span class="n">myAccount</span><span class="o">.</span><span class="na">withdraw</span><span class="o">(</span><span class="mi">20000</span><span class="o">);</span> <span class="c1">// 유효하지 않은 출금 시도</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"최종 잔액: "</span> <span class="o">+</span> <span class="n">myAccount</span><span class="o">.</span><span class="na">getBalance</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>캡슐화를 통해 <code class="language-plaintext highlighter-rouge">balance</code> 필드를 <code class="language-plaintext highlighter-rouge">private</code>으로 숨기고, <code class="language-plaintext highlighter-rouge">deposit()</code>과 <code class="language-plaintext highlighter-rouge">withdraw()</code>와 같은 <code class="language-plaintext highlighter-rouge">public</code> 메소드를 통해서만 잔액을 조작하도록 했습니다. 이 메소드들 안에서 입금/출금액이 양수인지, 잔액이 충분한지 등을 <strong>검증하는 로직</strong>을 추가하여 객체의 상태(balance)를 더욱 안전하게 관리할 수 있습니다.</p>

<hr />

<h2 id="-요약-정리-객체-초기화와-캡슐화">📌 요약 정리: 객체 초기화와 캡슐화</h2>

<ul>
  <li><strong>생성자</strong>: 객체 생성 시 딱 한 번 호출되어 인스턴스 변수를 초기화하고 초기 설정을 수행하는 특별한 메소드. 클래스 이름과 동일하며 반환 타입 없음.</li>
  <li><strong>생성자 오버로딩</strong>: 매개변수의 개수, 타입, 순서가 다른 여러 생성자를 정의하여 객체를 다양한 방식으로 초기화 가능. <code class="language-plaintext highlighter-rouge">this(...)</code>로 다른 생성자 호출 가능 (첫 줄에만).</li>
  <li><strong>변수 초기화 순서</strong>:
    <ol>
      <li><strong>static 변수/블록</strong> (클래스 로딩 시)</li>
      <li><strong>인스턴스 변수 명시적 초기화/블록</strong> (객체 생성 시)</li>
      <li><strong>생성자</strong> (객체 생성 시)</li>
    </ol>
  </li>
  <li><strong>지역 변수</strong>: 반드시 사용 전 직접 초기화해야 함 (컴파일 에러 방지).</li>
  <li><strong>접근 제어자</strong>: <code class="language-plaintext highlighter-rouge">public</code>, <code class="language-plaintext highlighter-rouge">protected</code>, <code class="language-plaintext highlighter-rouge">(default)</code>, <code class="language-plaintext highlighter-rouge">private</code>으로 멤버의 접근 범위를 지정.</li>
  <li><strong>캡슐화</strong>: 필드(데이터)를 <code class="language-plaintext highlighter-rouge">private</code>으로 숨기고, <code class="language-plaintext highlighter-rouge">public</code> 메소드(Getter/Setter)를 통해 간접적으로 접근하여 객체의 무결성을 보호하는 객체지향 원칙.</li>
  <li><strong>Getter/Setter</strong>: 캡슐화된 필드의 값을 읽고(<code class="language-plaintext highlighter-rouge">get</code>), 변경하는(<code class="language-plaintext highlighter-rouge">set</code>) <code class="language-plaintext highlighter-rouge">public</code> 메소드. 변경 시 유효성 검증 로직 추가 가능.</li>
</ul>

<hr />

<h2 id="-객체지향-퀴즈-스마트폰-클래스">💡 객체지향 퀴즈: 스마트폰 클래스</h2>

<p>다음 <code class="language-plaintext highlighter-rouge">Smartphone</code> 클래스를 보고, 출력 결과를 예상하고 캡슐화가 잘 적용되었는지 생각해 보세요.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Smartphone</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">model</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">color</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">batteryPercentage</span><span class="o">;</span> <span class="c1">// 배터리 잔량 (0~100)</span>

    <span class="kd">public</span> <span class="nf">Smartphone</span><span class="o">(</span><span class="nc">String</span> <span class="n">model</span><span class="o">,</span> <span class="nc">String</span> <span class="n">color</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">batteryPercentage</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span> <span class="c1">// 초기 배터리 100%</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">model</span> <span class="o">+</span> <span class="s">" 스마트폰이 새로 생성되었습니다!"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Getter for model</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getModel</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">model</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Getter for color</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getColor</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">color</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Getter for batteryPercentage</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getBatteryPercentage</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">batteryPercentage</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 배터리 충전 메소드 (Setter 역할)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">chargeBattery</span><span class="o">(</span><span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">batteryPercentage</span> <span class="o">+=</span> <span class="n">amount</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">batteryPercentage</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">batteryPercentage</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">model</span> <span class="o">+</span> <span class="s">" 배터리 "</span> <span class="o">+</span> <span class="n">amount</span> <span class="o">+</span> <span class="s">"% 충전 완료. 현재: "</span> <span class="o">+</span> <span class="n">batteryPercentage</span> <span class="o">+</span> <span class="s">"%"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"충전량은 양수여야 합니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 스마트폰 사용 메소드 (Setter 역할)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">useBattery</span><span class="o">(</span><span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">batteryPercentage</span> <span class="o">-</span> <span class="n">amount</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">batteryPercentage</span> <span class="o">-=</span> <span class="n">amount</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">model</span> <span class="o">+</span> <span class="s">" 배터리 "</span> <span class="o">+</span> <span class="n">amount</span> <span class="o">+</span> <span class="s">"% 사용. 현재: "</span> <span class="o">+</span> <span class="n">batteryPercentage</span> <span class="o">+</span> <span class="s">"%"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">batteryPercentage</span> <span class="o">-</span> <span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">batteryPercentage</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">model</span> <span class="o">+</span> <span class="s">" 배터리 부족! 폰이 꺼집니다."</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"사용량은 양수여야 합니다."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Smartphone</span> <span class="n">myPhone</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Smartphone</span><span class="o">(</span><span class="s">"Galaxy S24"</span><span class="o">,</span> <span class="s">"Black"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"모델: "</span> <span class="o">+</span> <span class="n">myPhone</span><span class="o">.</span><span class="na">getModel</span><span class="o">()</span> <span class="o">+</span> <span class="s">", 색상: "</span> <span class="o">+</span> <span class="n">myPhone</span><span class="o">.</span><span class="na">getColor</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"초기 배터리: "</span> <span class="o">+</span> <span class="n">myPhone</span><span class="o">.</span><span class="na">getBatteryPercentage</span><span class="o">()</span> <span class="o">+</span> <span class="s">"%"</span><span class="o">);</span>

        <span class="n">myPhone</span><span class="o">.</span><span class="na">useBattery</span><span class="o">(</span><span class="mi">30</span><span class="o">);</span>
        <span class="n">myPhone</span><span class="o">.</span><span class="na">chargeBattery</span><span class="o">(</span><span class="mi">15</span><span class="o">);</span>
        <span class="n">myPhone</span><span class="o">.</span><span class="na">useBattery</span><span class="o">(</span><span class="mi">90</span><span class="o">);</span> <span class="c1">// 배터리 부족 상황</span>
        <span class="n">myPhone</span><span class="o">.</span><span class="na">chargeBattery</span><span class="o">(-</span><span class="mi">10</span><span class="o">);</span> <span class="c1">// 잘못된 충전 시도</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"최종 배터리: "</span> <span class="o">+</span> <span class="n">myPhone</span><span class="o">.</span><span class="na">getBatteryPercentage</span><span class="o">()</span> <span class="o">+</span> <span class="s">"%"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<details>
<summary>정답 보기</summary>
<br />

출력 결과:
<br /><br />

Galaxy S24 스마트폰이 새로 생성되었습니다!<br />
모델: Galaxy S24, 색상: Black<br />
초기 배터리: 100%<br />
Galaxy S24 배터리 30% 사용. 현재: 70%<br />
Galaxy S24 배터리 15% 충전 완료. 현재: 85%<br />
Galaxy S24 배터리 부족! 폰이 꺼집니다.<br />
충전량은 양수여야 합니다.<br />
최종 배터리: 0%<br /><br />


<br />
설명:
<br />

1.  `Smartphone` 객체가 생성될 때, 생성자에 따라 `model`, `color`가 초기화되고 `batteryPercentage`는 100으로 고정 초기화됩니다.<br /><br />
2.  `model`, `color`, `batteryPercentage` 필드는 `private`으로 선언되어 외부에서 직접 접근하거나 변경할 수 없습니다. (캡슐화 적용)<br /><br />
3.  `getModel()`, `getColor()`, `getBatteryPercentage()` 메소드를 통해 필드 값을 읽을 수 있습니다.<br /><br />
4.  `chargeBattery()`와 `useBattery()` 메소드는 `batteryPercentage` 값을 변경하는 역할을 합니다. 이 메소드들 안에는 배터리 값이 0\~100% 범위를 벗어나지 않도록 하거나, 유효하지 않은 입력(음수)을 막는 **유효성 검증 로직**이 포함되어 객체의 상태를 안전하게 유지합니다.<br /><br />
5.  `myPhone.useBattery(90)` 호출 시, 잔량 85%에서 90% 사용을 시도하므로 잔액 부족 메시지와 함께 배터리가 0%로 설정됩니다.<br /><br />
6.  `myPhone.chargeBattery(-10)` 호출 시, 음수 충전량에 대한 유효성 검증으로 인해 "충전량은 양수여야 합니다." 메시지가 출력되고 실제 배터리 값은 변경되지 않습니다.<br />

</details>

<hr />

<h2 id="-마치며-견고한-객체-설계를-위한-필수-요소">🔚 마치며: 견고한 객체 설계를 위한 필수 요소</h2>

<p>이번 글에서는 객체지향 프로그래밍에서 객체의 생명 주기와 상태 관리에 매우 중요한 <strong>생성자</strong>와 <strong>변수 초기화</strong> 개념을 심도 있게 다루었습니다. 또한, 객체의 내부 데이터를 안전하게 보호하고 유효성을 보장하는 <strong>캡슐화</strong>의 중요성, 그리고 이를 위한 <strong>접근 제어자</strong>와 <strong>Getter/Setter</strong> 활용법도 알아보았습니다.</p>

<p>생성자와 초기화는 객체가 올바른 상태로 시작하도록 보장하고, 캡슐화는 객체가 이후에도 안전하고 예측 가능한 방식으로 동작하도록 돕습니다. 이 모든 개념은 재사용 가능하고 유지보수하기 쉬운 견고한 객체지향 시스템을 구축하는 데 필수적인 요소들입니다.</p>]]></content><author><name>Lorem</name><email>loremipsum0115@gmail.com</email></author><category term="java" /><summary type="html"><![CDATA[]]></summary></entry><entry xml:lang="ko"><title type="html">자바 객체지향-메소드</title><link href="https://loremipsum0116.github.io/ko/java-oop&method/" rel="alternate" type="text/html" title="자바 객체지향-메소드" /><published>2025-06-17T02:28:43+00:00</published><updated>2025-06-17T02:28:43+00:00</updated><id>https://loremipsum0116.github.io/ko/java-oop&amp;method</id><content type="html" xml:base="https://loremipsum0116.github.io/ko/java-oop&amp;method/"><![CDATA[<hr />

<h2 id="자바-객체지향-프로그래밍-메소드-심화와-활용">자바 객체지향 프로그래밍: 메소드 심화와 활용</h2>

<p>이전 글에서 객체지향 프로그래밍의 핵심인 <strong>클래스, 객체, 인스턴스</strong> 개념을 배우고, 클래스 내부에 선언되는 <strong>변수의 종류</strong>에 대해서도 알아보았습니다. 이제 객체가 ‘행동’을 수행하는 통로인 **메소드(Method)**에 대해 더 깊이 파고들 시간입니다. 메소드는 단순한 기능 단위를 넘어, 객체지향의 다양한 원칙을 구현하는 데 중요한 역할을 합니다.</p>

<p>이번 글에서는 자바 메소드의 다양한 측면을 서술할 것입니다. 특히 **매개변수 전달 방식(기본형 vs 참조형)**의 차이, <strong>인스턴스 메소드와 static 메소드</strong>의 역할, 그리고 **메소드 오버로딩(Method Overloading)**을 통한 유연한 기능 제공 방법까지 자세히 살펴보겠습니다.</p>

<hr />

<h2 id="메소드method란">메소드(Method)란?</h2>

<p>메소드는 특정 작업을 수행하는 코드 블록입니다. 객체의 ‘행동’ 또는 ‘기능’을 정의하며, 외부로부터 데이터를 입력받을 수도 있고(매개변수), 작업 수행 후 결과를 반환할 수도 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Calculator</span> <span class="o">{</span>
    <span class="c1">// 덧셈을 수행하는 메소드</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// int a, int b는 매개변수</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span> <span class="c1">// result는 지역 변수</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span> <span class="c1">// int 타입의 값을 반환</span>
    <span class="o">}</span>

    <span class="c1">// 환영 메시지를 출력하는 메소드 (반환값 없고, 매개변수 없음)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">greet</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"안녕하세요!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 예시에서 <code class="language-plaintext highlighter-rouge">add</code> 메소드는 두 개의 정수(<code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>)를 입력받아 덧셈을 수행하고, 그 결과를 정수(<code class="language-plaintext highlighter-rouge">result</code>)로 반환합니다. <code class="language-plaintext highlighter-rouge">greet</code> 메소드는 아무것도 입력받지 않고, 아무것도 반환하지 않지만 특정 동작(메시지 출력)을 수행합니다.</p>

<hr />

<h2 id="1-매개변수-전달-방식-기본형-vs-참조형">1. 매개변수 전달 방식: 기본형 vs 참조형</h2>

<p>메소드를 호출할 때 매개변수를 전달하는 방식은 기본형(Primitive Type)과 참조형(Reference Type)에서 큰 차이를 보입니다. 이는 자바의 ‘Pass by Value(값에 의한 전달)’ 원칙 때문입니다.</p>

<h3 id="1-1-기본형-매개변수-call-by-value">1-1. 기본형 매개변수 (Call by Value)</h3>

<p>기본형(int, double, boolean 등) 변수를 메소드의 매개변수로 전달할 때는 <strong>변수에 저장된 실제 값</strong>이 복사되어 전달됩니다. 따라서 메소드 내부에서 이 복사된 값(매개변수)을 변경하더라도, <strong>원본 변수의 값은 변경되지 않습니다.</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParameterExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">originalValue</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"메소드 호출 전 originalValue: "</span> <span class="o">+</span> <span class="n">originalValue</span><span class="o">);</span> <span class="c1">// 10 출력</span>

        <span class="n">changePrimitive</span><span class="o">(</span><span class="n">originalValue</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"메소드 호출 후 originalValue: "</span> <span class="o">+</span> <span class="n">originalValue</span><span class="o">);</span> <span class="c1">// 여전히 10 출력</span>
    <span class="o">}</span>

    <span class="c1">// 기본형 매개변수: value의 '값'이 복사되어 전달됨</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">changePrimitive</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span> <span class="c1">// 복사된 값을 변경</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"메소드 내에서 value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span> <span class="c1">// 20 출력</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>메소드 호출 전 originalValue: 10
메소드 내에서 value: 20
메소드 호출 후 originalValue: 10
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">changePrimitive</code> 메소드 내에서 <code class="language-plaintext highlighter-rouge">value</code>를 20으로 변경했지만, <code class="language-plaintext highlighter-rouge">main</code> 메소드의 <code class="language-plaintext highlighter-rouge">originalValue</code>는 여전히 10입니다. 이는 <code class="language-plaintext highlighter-rouge">originalValue</code>의 ‘값’ 10이 <code class="language-plaintext highlighter-rouge">value</code>라는 새로운 변수에 복사되었기 때문입니다.</p>

<h3 id="1-2-참조형-매개변수-call-by-value-but-value-is-reference">1-2. 참조형 매개변수 (Call by Value, but ‘Value’ is Reference)</h3>

<p>참조형(객체, 배열) 변수를 메소드의 매개변수로 전달할 때도 ‘값에 의한 전달’이 적용됩니다. 하지만 이때 전달되는 ‘값’은 실제 객체 자체가 아니라 **객체가 저장된 메모리 ‘주소’(참조값)**입니다. 따라서 메소드 내부에서 이 복사된 주소(매개변수)를 통해 <strong>객체에 접근하여 객체의 내용을 변경하면, 원본 객체도 변경됩니다.</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyObject</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="o">;</span>
    <span class="nc">MyObject</span><span class="o">(</span><span class="kt">int</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParameterExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyObject</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyObject</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"메소드 호출 전 obj.data: "</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="na">data</span><span class="o">);</span> <span class="c1">// 100 출력</span>

        <span class="n">changeReference</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span> <span class="c1">// obj가 가리키는 '주소값'이 o에 복사됨</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"메소드 호출 후 obj.data: "</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="na">data</span><span class="o">);</span> <span class="c1">// 200 출력</span>
        
        <span class="c1">// 새로운 객체를 할당해도 원본은 바뀌지 않음</span>
        <span class="n">createNewObject</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span> <span class="c1">// obj가 가리키는 '주소값'이 o에 복사됨</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"새 객체 할당 메소드 호출 후 obj.data: "</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="na">data</span><span class="o">);</span> <span class="c1">// 여전히 200 출력</span>
    <span class="o">}</span>

    <span class="c1">// 참조형 매개변수: o에 obj가 가리키는 '주소값'이 복사되어 전달됨</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">changeReference</span><span class="o">(</span><span class="nc">MyObject</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">o</span><span class="o">.</span><span class="na">data</span> <span class="o">=</span> <span class="mi">200</span><span class="o">;</span> <span class="c1">// 복사된 주소값을 통해 원본 객체의 내용 변경</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"메소드 내에서 o.data: "</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="na">data</span><span class="o">);</span> <span class="c1">// 200 출력</span>
    <span class="o">}</span>

    <span class="c1">// 매개변수에 새로운 객체를 할당하는 경우</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">createNewObject</span><span class="o">(</span><span class="nc">MyObject</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyObject</span><span class="o">(</span><span class="mi">300</span><span class="o">);</span> <span class="c1">// o가 새로운 객체를 참조하게 됨 (원본 obj와는 무관)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"메소드 내에서 새로운 객체 o.data: "</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="na">data</span><span class="o">);</span> <span class="c1">// 300 출력</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>메소드 호출 전 obj.data: 100
메소드 내에서 o.data: 200
메소드 호출 후 obj.data: 200
메소드 내에서 새로운 객체 o.data: 300
새 객체 할당 메소드 호출 후 obj.data: 200
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">changeReference</code> 메소드에서 <code class="language-plaintext highlighter-rouge">o.data = 200;</code>을 통해 <code class="language-plaintext highlighter-rouge">o</code>가 가리키는 객체의 <code class="language-plaintext highlighter-rouge">data</code> 값을 변경했을 때, <code class="language-plaintext highlighter-rouge">main</code> 메소드의 <code class="language-plaintext highlighter-rouge">obj</code>가 가리키는 객체의 <code class="language-plaintext highlighter-rouge">data</code> 값도 200으로 변경된 것을 알 수 있습니다. 이는 두 변수가 <strong>동일한 힙 영역의 객체를 참조</strong>하고 있기 때문입니다.</p>

<p>하지만 <code class="language-plaintext highlighter-rouge">createNewObject</code> 메소드에서 <code class="language-plaintext highlighter-rouge">o = new MyObject(300);</code>처럼 매개변수 <code class="language-plaintext highlighter-rouge">o</code>에 아예 <strong>새로운 객체를 할당</strong>하면, <code class="language-plaintext highlighter-rouge">o</code>는 이제 원래 <code class="language-plaintext highlighter-rouge">obj</code>가 참조하던 객체가 아닌, 새로운 객체를 참조하게 됩니다. 이 경우 <code class="language-plaintext highlighter-rouge">obj</code>는 여전히 원래 객체를 참조하므로 <code class="language-plaintext highlighter-rouge">obj.data</code>는 변경되지 않습니다.</p>

<hr />

<h2 id="2-인스턴스-메소드-vs-static-메소드">2. 인스턴스 메소드 vs static 메소드</h2>

<p>메소드도 변수처럼 <code class="language-plaintext highlighter-rouge">static</code> 키워드의 유무에 따라 동작 방식이 달라집니다.</p>

<h3 id="2-1-인스턴스-메소드-instance-method">2-1. 인스턴스 메소드 (Instance Method)</h3>

<ul>
  <li><strong>선언 방식</strong>: <code class="language-plaintext highlighter-rouge">static</code> 키워드 없이 선언됩니다.</li>
  <li><strong>호출 방식</strong>: 반드시 <strong>객체(인스턴스)를 생성한 후, 객체 참조 변수를 통해서 호출</strong>해야 합니다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">객체참조변수.메소드명()</code></li>
    </ul>
  </li>
  <li><strong>접근 가능 범위</strong>: 해당 객체의 <strong>인스턴스 변수</strong>와 <strong>인스턴스 메소드</strong>는 물론, <strong>static 변수</strong>와 <strong>static 메소드</strong>에도 접근할 수 있습니다.</li>
  <li><strong>용도</strong>: 객체마다 다른 값을 가지는 인스턴스 변수를 조작하거나, 객체의 고유한 행동을 정의할 때 사용합니다.</li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">Car</code> 클래스의 <code class="language-plaintext highlighter-rouge">startEngine()</code>, <code class="language-plaintext highlighter-rouge">accelerate()</code>, <code class="language-plaintext highlighter-rouge">stop()</code></li>
</ul>

<!-- end list -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Car 클래스 (이전 글 예시)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">model</span><span class="o">;</span> <span class="c1">// 인스턴스 변수</span>
    <span class="kd">static</span> <span class="nc">String</span> <span class="n">manufacturer</span> <span class="o">=</span> <span class="s">"JavaMotors"</span><span class="o">;</span> <span class="c1">// static 변수</span>

    <span class="c1">// 인스턴스 메소드: 객체의 model 필드를 사용합니다.</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startEngine</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">model</span> <span class="o">+</span> <span class="s">"의 시동을 겁니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// static 메소드: static 필드만 사용하거나, 객체와 무관한 공통 기능 제공</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printManufacturer</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"모든 "</span> <span class="o">+</span> <span class="n">manufacturer</span> <span class="o">+</span> <span class="s">" 자동차"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MethodCallExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Car</span> <span class="n">myCar</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">();</span> <span class="c1">// 객체 생성</span>
        <span class="n">myCar</span><span class="o">.</span><span class="na">model</span> <span class="o">=</span> <span class="s">"Tesla"</span><span class="o">;</span>

        <span class="n">myCar</span><span class="o">.</span><span class="na">startEngine</span><span class="o">();</span> <span class="c1">// 인스턴스 메소드 호출 (객체를 통해서)</span>
        <span class="c1">// System.out.println(Car.model); // 에러! static 메소드에서 인스턴스 변수에 직접 접근 불가</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2-2-static-메소드-class-method">2-2. static 메소드 (Class Method)</h3>

<ul>
  <li><strong>선언 방식</strong>: <code class="language-plaintext highlighter-rouge">static</code> 키워드를 사용하여 선언됩니다.</li>
  <li><strong>호출 방식</strong>: <strong>클래스 이름을 통해서 직접 호출</strong>하는 것이 일반적입니다. 객체를 생성하지 않고도 호출할 수 있습니다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">클래스명.메소드명()</code></li>
    </ul>
  </li>
  <li><strong>접근 가능 범위</strong>: 오직 <strong>static 변수</strong>와 <strong>static 메소드</strong>에만 직접 접근할 수 있습니다. 인스턴스 변수나 인스턴스 메소드에는 직접 접근할 수 없습니다. (왜냐하면 static 메소드가 호출될 시점에 객체가 존재하지 않을 수도 있기 때문입니다.)</li>
  <li><strong>용도</strong>: 객체와 독립적으로 동작하는 유틸리티 메소드 (예: 수학 계산, 공통 설정), 모든 객체가 공유하는 데이터를 다룰 때 사용합니다.</li>
  <li><strong>예시</strong>: <code class="language-plaintext highlighter-rouge">Math.random()</code>, <code class="language-plaintext highlighter-rouge">System.out.println()</code></li>
</ul>

<!-- end list -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MethodCallExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// static 메소드 호출 (클래스명으로 직접 호출)</span>
        <span class="nc">Car</span><span class="o">.</span><span class="na">printManufacturer</span><span class="o">();</span>
        <span class="c1">// Car.startEngine(); // 에러! static 메소드에서 인스턴스 메소드를 직접 호출할 수 없음</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>핵심 정리</strong>:</p>

<ul>
  <li><strong>인스턴스 메소드</strong>는 <strong>객체의 고유한 상태(인스턴스 변수)에 따라 동작</strong>해야 할 때 사용합니다. (객체 없이는 의미가 없음)</li>
  <li><strong>static 메소드</strong>는 <strong>객체의 생성과 무관하게 공통적으로 사용되는 기능</strong>이나 <strong>클래스 전체에 관련된 작업</strong>을 수행할 때 사용합니다. (객체 없이도 동작 가능)</li>
</ul>

<hr />

<h2 id="3-메소드-반환값-기본형-vs-참조형">3. 메소드 반환값: 기본형 vs 참조형</h2>

<p>메소드는 작업을 수행한 후 그 결과를 호출한 곳으로 반환할 수 있습니다. 이때 반환되는 값의 타입도 기본형과 참조형으로 나뉩니다.</p>

<h3 id="3-1-기본형-반환값">3-1. 기본형 반환값</h3>

<p>메소드가 <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">boolean</code> 등 기본형 타입의 값을 반환할 경우, <strong>실제 값</strong>이 복사되어 반환됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReturnValueExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">multiply</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">;</span> <span class="c1">// x * y의 실제 값(정수)이 반환됨</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ReturnValueExample</span> <span class="n">re</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReturnValueExample</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span> <span class="c1">// 15가 반환되어 result에 저장</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"곱셈 결과: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span> <span class="c1">// 출력: 15</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="3-2-참조형-반환값">3-2. 참조형 반환값</h3>

<p>메소드가 <code class="language-plaintext highlighter-rouge">String</code>, 배열, 또는 사용자 정의 클래스(객체)와 같은 참조형 타입의 값을 반환할 경우, **객체의 메모리 ‘주소’(참조값)**가 복사되어 반환됩니다. 이 주소를 통해 호출한 쪽에서 반환된 객체에 접근할 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="nc">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">introduce</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"안녕하세요, 저는 "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"입니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReturnValueExample</span> <span class="o">{</span>
    <span class="c1">// Person 객체를 생성하여 반환하는 메소드</span>
    <span class="kd">public</span> <span class="nc">Person</span> <span class="nf">createPerson</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">);</span> <span class="c1">// 힙에 새로운 Person 객체 생성</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// p가 가리키는 '주소값'이 반환됨</span>
    <span class="o">}</span>

    <span class="c1">// 배열을 반환하는 메소드</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">createNumbersArray</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">};</span> <span class="c1">// 힙에 새로운 배열 객체 생성</span>
        <span class="k">return</span> <span class="n">numbers</span><span class="o">;</span> <span class="c1">// numbers가 가리키는 '주소값'이 반환됨</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ReturnValueExample</span> <span class="n">re</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReturnValueExample</span><span class="o">();</span>

        <span class="c1">// Person 객체 반환</span>
        <span class="nc">Person</span> <span class="n">myPerson</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="na">createPerson</span><span class="o">(</span><span class="s">"홍길동"</span><span class="o">);</span> <span class="c1">// 힙에 생성된 Person 객체의 주소가 myPerson에 저장</span>
        <span class="n">myPerson</span><span class="o">.</span><span class="na">introduce</span><span class="o">();</span> <span class="c1">// 출력: 안녕하세요, 저는 홍길동입니다.</span>

        <span class="c1">// 배열 반환</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">returnedArray</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="na">createNumbersArray</span><span class="o">();</span> <span class="c1">// 힙에 생성된 배열 객체의 주소가 returnedArray에 저장</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"반환된 배열의 첫 번째 요소: "</span> <span class="o">+</span> <span class="n">returnedArray</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span> <span class="c1">// 출력: 10</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>메소드에서 참조형을 반환하면, 실제 객체는 힙에 그대로 남아 있고, 해당 객체의 주소만 반환되어 호출한 곳의 참조 변수에 할당됩니다. 이를 통해 여러 메소드가 동일한 객체를 공유하고 조작할 수 있게 됩니다.</p>

<hr />

<h2 id="4-메소드-오버로딩-method-overloading">4. 메소드 오버로딩 (Method Overloading)</h2>

<p><strong>메소드 오버로딩</strong>은 하나의 클래스 내에서 <strong>이름은 같지만 매개변수의 타입, 개수, 또는 순서가 다른 메소드를 여러 개 정의</strong>하는 객체지향의 특징입니다. 이는 동일한 기능을 수행하지만 입력 데이터의 형태가 다를 때 유용하며, 코드의 직관성과 가독성을 높여줍니다.</p>

<p>컴파일러는 메소드 호출 시 제공된 매개변수 정보를 바탕으로 어떤 오버로딩된 메소드를 호출해야 할지 자동으로 판단합니다.</p>

<p><strong>오버로딩의 조건:</strong></p>

<ol>
  <li><strong>메소드 이름이 같아야 한다.</strong></li>
  <li><strong>매개변수의 개수, 타입, 또는 순서 중 적어도 하나는 달라야 한다.</strong></li>
  <li><strong>반환 타입은 오버로딩 조건에 영향을 주지 않는다.</strong> (반환 타입만 다르고 매개변수가 같으면 오버로딩이 아님)</li>
</ol>

<!-- end list -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Calculator</span> <span class="o">{</span>
    <span class="c1">// 1. 두 정수의 덧셈</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"정수 두 개 덧셈"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 2. 세 정수의 덧셈 (매개변수 개수 다름)</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"정수 세 개 덧셈"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 3. 두 실수의 덧셈 (매개변수 타입 다름)</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">add</span><span class="o">(</span><span class="kt">double</span> <span class="n">a</span><span class="o">,</span> <span class="kt">double</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"실수 두 개 덧셈"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 4. 문자열과 정수 덧셈 (매개변수 타입 순서 다름)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">add</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"문자열과 정수 덧셈"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 5. 정수와 문자열 덧셈 (매개변수 타입 순서 다름)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"정수와 문자열 덧셈"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 다음은 오버로딩이 아님 (반환 타입만 다름) - 컴파일 에러 발생</span>
    <span class="c1">// public double add(int a, int b) { return (double)a + b; }</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Calculator</span> <span class="n">calc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Calculator</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">calc</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">));</span>       <span class="c1">// 정수 두 개 덧셈: 30</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">calc</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">));</span>   <span class="c1">// 정수 세 개 덧셈: 60</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">calc</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mf">10.5</span><span class="o">,</span> <span class="mf">20.5</span><span class="o">));</span>   <span class="c1">// 실수 두 개 덧셈: 31.0</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">calc</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="mi">123</span><span class="o">));</span> <span class="c1">// 문자열과 정수 덧셈: Hello123</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">calc</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">456</span><span class="o">,</span> <span class="s">"World"</span><span class="o">));</span> <span class="c1">// 정수와 문자열 덧셈: 456World</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>메소드 오버로딩은 <code class="language-plaintext highlighter-rouge">System.out.println()</code>처럼 다양한 타입의 데이터를 출력할 때 동일한 메소드 이름을 사용하지만 내부적으로는 다른 오버로딩된 메소드를 호출하는 경우를 통해 일상적으로 접할 수 있습니다.</p>

<hr />

<h2 id="-요약-정리-메소드-심화와-활용">📌 요약 정리: 메소드 심화와 활용</h2>

<ul>
  <li><strong>메소드</strong>: 객체의 ‘행동’을 정의하는 코드 블록.</li>
  <li><strong>매개변수 전달</strong>:
    <ul>
      <li><strong>기본형</strong>: <strong>값 복사</strong> (원본 변경 X)</li>
      <li><strong>참조형</strong>: <strong>주소 값 복사</strong> (주소로 접근하는 <strong>객체 내용 변경 O</strong>, 새 객체 할당 X)</li>
    </ul>
  </li>
  <li><strong>메소드 종류</strong>:
    <ul>
      <li><strong>인스턴스 메소드</strong>: <code class="language-plaintext highlighter-rouge">static</code> 없이 선언. <strong>객체를 생성 후 호출</strong>. 인스턴스 변수/메소드, static 변수/메소드 모두 접근 가능.</li>
      <li><strong>static 메소드</strong>: <code class="language-plaintext highlighter-rouge">static</code> 키워드 사용. <strong>클래스 이름으로 호출</strong>. static 변수/메소드만 직접 접근 가능.</li>
    </ul>
  </li>
  <li><strong>메소드 반환값</strong>:
    <ul>
      <li><strong>기본형</strong>: 실제 값 반환.</li>
      <li><strong>참조형</strong>: 객체의 <strong>메모리 주소</strong> 반환.</li>
    </ul>
  </li>
  <li><strong>메소드 오버로딩</strong>: 동일한 클래스 내에서 <strong>같은 이름</strong>을 가지지만 <strong>매개변수의 타입, 개수, 순서가 다른</strong> 여러 메소드를 정의하는 것. 반환 타입은 오버로딩 조건에 해당하지 않음.</li>
  <li><strong>생성자</strong>: 객체 생성 및 초기화 시 호출되는 특별한 메소드. 클래스 이름과 동일하며 반환 타입 없음.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">this</code></strong>: 현재 객체(인스턴스) 자신을 참조.</li>
</ul>

<hr />

<h2 id="-메소드-퀴즈-오버로딩과-매개변수">💡 메소드 퀴즈: 오버로딩과 매개변수</h2>

<p>다음 코드의 출력 결과를 예상해 보세요.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">QuizMethods</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">modify</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"modify(int x) 내 x: "</span> <span class="o">+</span> <span class="n">x</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">modify</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"modify(int[] arr) 내 arr[0]: "</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main 시작 num: "</span> <span class="o">+</span> <span class="n">num</span><span class="o">);</span>
        <span class="n">modify</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main 끝 num: "</span> <span class="o">+</span> <span class="n">num</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--------------------"</span><span class="o">);</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="o">{</span><span class="mi">100</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main 시작 data[0]: "</span> <span class="o">+</span> <span class="n">data</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="n">modify</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main 끝 data[0]: "</span> <span class="o">+</span> <span class="n">data</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<details>
<summary>정답 보기</summary>
<br />
출력 결과:

```
main 시작 num: 5
modify(int x) 내 x: 15
main 끝 num: 5
--------------------
main 시작 data[0]: 100
modify(int[] arr) 내 arr[0]: 110
main 끝 data[0]: 110
```

<br />
설명:
<br />

1.  **`modify(int x)` 호출**: `num` (기본형)의 `값 5`가 `x`로 복사됩니다. `x`는 15로 변경되지만, `main` 메소드의 `num`에는 영향을 주지 않습니다.
2.  **`modify(int[] arr)` 호출**: `data` (참조형)가 가리키는 **배열의 주소값**이 `arr`로 복사됩니다. `arr[0]`을 변경하는 것은 `arr`이 참조하는 **힙 영역의 실제 배열 객체의 값**을 변경하는 것이므로, `main` 메소드의 `data[0]`도 변경됩니다.
3.  두 `modify` 메소드는 이름이 같지만 매개변수 타입(int vs int[])이 다르므로 **오버로딩**된 메소드입니다. 자바는 호출 시 인자의 타입에 따라 올바른 메소드를 선택합니다.
    </details>

<hr />

<h2 id="-마치며-객체의-행동-정의하기">🔚 마치며: 객체의 행동 정의하기</h2>

<p>이번 글에서는 자바 메소드의 심화된 개념과 객체지향에서 메소드가 어떻게 활용되는지 자세히 살펴보았습니다.인스턴스 메소드와 static 메소드의 구분을 통해 객체지향 설계를 더욱 명확하게 할 수 있습니다. 또한, 메소드 오버로딩은 코드의 유연성과 재사용성을 높여주는 강력한 기능입니다.</p>

<p>메소드는 객체의 ‘행동’을 정의하는 핵심 요소이며, 이들을 잘 활용하는 것이 곧 효율적이고 유지보수하기 좋은 객체지향 코드를 작성하는 길입니다.</p>]]></content><author><name>Lorem</name><email>loremipsum0115@gmail.com</email></author><category term="java" /><summary type="html"><![CDATA[]]></summary></entry><entry xml:lang="ko"><title type="html">자바 객체지향-클래스</title><link href="https://loremipsum0116.github.io/ko/java-oop&class/" rel="alternate" type="text/html" title="자바 객체지향-클래스" /><published>2025-06-17T02:18:56+00:00</published><updated>2025-06-17T02:18:56+00:00</updated><id>https://loremipsum0116.github.io/ko/java-oop&amp;class</id><content type="html" xml:base="https://loremipsum0116.github.io/ko/java-oop&amp;class/"><![CDATA[<hr />

<h2 id="자바-객체지향-프로그래밍-현실-세계를-코드로-담다">자바 객체지향 프로그래밍: 현실 세계를 코드로 담다</h2>

<p>지금까지 우리는 자바의 기본적인 데이터 타입, 변수, 연산자, 조건문 등 프로그램을 구성하는 개별적인 요소들을 배워왔습니다. 하지만 실제 복잡한 소프트웨어를 만들 때는 단순히 이러한 요소들을 나열하는 것만으로는 부족합니다. 마치 건물을 지을 때 벽돌 하나하나를 놓는 것을 넘어, 전체적인 설계도와 각 부분의 역할을 이해해야 하는 것과 같습니다.</p>

<p>여기서 등장하는 핵심 개념이 바로 <strong>객체지향 프로그래밍(Object-Oriented Programming, OOP)</strong> 입니다. 자바는 대표적인 객체지향 언어로, 현실 세계의 사물과 개념을 코드 속 ‘객체’로 모델링하여 프로그램을 만드는 방식을 지향합니다. 이러한 접근 방식은 코드의 <strong>재사용성, 유지보수성, 확장성</strong>을 크게 향상시킵니다.</p>

<p>이번 글에서는 객체지향 프로그래밍의 가장 기본적이면서도 중요한 요소인 <strong>클래스(Class)</strong>, <strong>객체(Object)</strong>, 그리고 **인스턴스(Instance)**가 무엇인지, 그리고 이들이 어떻게 서로 연관되어 프로그램 속에서 동작하는지 자세히 알아보겠습니다. 또한, 클래스 내부에 선언되는 **변수의 종류(인스턴스 변수, static 변수, 지역 변수)**가 어떻게 클래스, 객체와 연결되는지도 함께 살펴보겠습니다.</p>

<hr />

<h2 id="객체지향-프로그래밍oop이란">객체지향 프로그래밍(OOP)이란?</h2>

<p>**객체지향 프로그래밍(OOP)**은 프로그램을 여러 개의 독립적인 ‘객체’ 단위로 나누어 설계하고 구현하는 프로그래밍 패러다임입니다. 각 객체는 고유한 **상태(데이터)**와 그 상태를 조작하는 **행동(메소드)**을 가집니다.</p>

<p>예를 들어, 현실 세계의 ‘자동차’를 생각해 봅시다.</p>

<ul>
  <li><strong>상태</strong>: 색상, 모델, 속도, 연식 등</li>
  <li><strong>행동</strong>: 시동 걸기, 가속하기, 정지하기, 방향 바꾸기 등</li>
</ul>

<p>객체지향 프로그래밍은 이러한 현실 세계의 사물이나 개념을 컴퓨터 프로그램 속으로 그대로 가져와 표현하는 방식입니다.</p>

<h2 id="클래스class-객체를-만들기-위한-설계도">클래스(Class): 객체를 만들기 위한 ‘설계도’</h2>

<p><strong>클래스</strong>는 객체를 생성하기 위한 <strong>‘틀’</strong> 또는 <strong>‘설계도’</strong> 역할을 합니다. 클래스 자체는 객체가 아닙니다. 마치 자동차를 만들기 위한 설계도면이 실제 자동차가 아닌 것처럼 말이죠. 클래스에는 객체가 가질 **속성(변수, Field)**과 객체가 수행할 **행동(메소드, Method)**이 정의됩니다.</p>

<ul>
  <li><strong>속성(Field)</strong>: 객체가 가질 데이터나 상태를 나타냅니다. 예를 들어, <code class="language-plaintext highlighter-rouge">Car</code> 클래스라면 <code class="language-plaintext highlighter-rouge">color</code>, <code class="language-plaintext highlighter-rouge">model</code>, <code class="language-plaintext highlighter-rouge">speed</code> 등이 속성이 됩니다. 클래스 내에서 선언된 변수를 ‘멤버 변수’ 또는 ‘필드’라고 부릅니다.</li>
  <li><strong>행동(Method)</strong>: 객체가 수행할 동작이나 기능을 나타냅니다. 예를 들어, <code class="language-plaintext highlighter-rouge">Car</code> 클래스라면 <code class="language-plaintext highlighter-rouge">startEngine()</code>, <code class="language-plaintext highlighter-rouge">accelerate()</code>, <code class="language-plaintext highlighter-rouge">stop()</code> 등이 메소드가 됩니다.</li>
</ul>

<!-- end list -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Car 클래스 선언 (자동차의 설계도)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="c1">// 1. 속성 (Field, 멤버 변수) 정의</span>
    <span class="nc">String</span> <span class="n">color</span><span class="o">;</span> <span class="c1">// 인스턴스 변수: 각 자동차(객체)마다 다른 색상을 가집니다.</span>
    <span class="nc">String</span> <span class="n">model</span><span class="o">;</span> <span class="c1">// 인스턴스 변수: 각 자동차(객체)마다 다른 모델명을 가집니다.</span>
    <span class="kt">int</span> <span class="n">speed</span><span class="o">;</span>    <span class="c1">// 인스턴스 변수: 각 자동차(객체)마다 현재 속도가 다릅니다.</span>

    <span class="c1">// static 변수 (클래스 변수): 모든 자동차(객체)가 공유하는 속성</span>
    <span class="c1">// 이 클래스로부터 만들어지는 모든 자동차가 공유하는 제조사 이름이라고 가정해 봅시다.</span>
    <span class="kd">static</span> <span class="nc">String</span> <span class="n">manufacturer</span> <span class="o">=</span> <span class="s">"JavaMotors"</span><span class="o">;</span> 

    <span class="c1">// 2. 행동 (Method) 정의</span>
    <span class="c1">// 시동을 거는 메소드</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startEngine</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">model</span> <span class="o">+</span> <span class="s">"의 시동을 겁니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 가속하는 메소드</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accelerate</span><span class="o">(</span><span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">speed</span> <span class="o">+=</span> <span class="n">amount</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">model</span> <span class="o">+</span> <span class="s">"이(가) "</span> <span class="o">+</span> <span class="n">speed</span> <span class="o">+</span> <span class="s">"km/h로 가속합니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 정지하는 메소드</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">model</span> <span class="o">+</span> <span class="s">"이(가) 정지합니다."</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 제조사 정보를 출력하는 메소드 (static 변수 활용)</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printManufacturer</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"모든 "</span> <span class="o">+</span> <span class="n">manufacturer</span> <span class="o">+</span> <span class="s">" 자동차의 총 생산 대수는 아직 미정입니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위 코드에서 <code class="language-plaintext highlighter-rouge">Car</code>는 클래스이며, 이 클래스는 <code class="language-plaintext highlighter-rouge">color</code>, <code class="language-plaintext highlighter-rouge">model</code>, <code class="language-plaintext highlighter-rouge">speed</code>라는 속성과 <code class="language-plaintext highlighter-rouge">startEngine()</code>, <code class="language-plaintext highlighter-rouge">accelerate()</code>, <code class="language-plaintext highlighter-rouge">stop()</code>, <code class="language-plaintext highlighter-rouge">printManufacturer()</code>이라는 행동을 가질 것이라고 정의하고 있습니다.</p>

<hr />

<h2 id="클래스-내-변수의-종류-인스턴스-static-지역-변수">클래스 내 변수의 종류: 인스턴스, static, 지역 변수</h2>

<p>클래스 내부에서 선언되는 변수는 그 위치와 <code class="language-plaintext highlighter-rouge">static</code> 키워드 유무에 따라 세 가지 종류로 나뉩니다.</p>

<ol>
  <li>
    <p><strong>인스턴스 변수 (Instance Variable)</strong></p>

    <ul>
      <li><strong>선언 위치</strong>: 클래스 내부, 메소드 외부에 선언됩니다.</li>
      <li><strong>생명 주기</strong>: 객체(인스턴스)가 생성될 때 함께 생성되고, 해당 객체가 메모리에서 사라질 때 함께 사라집니다.</li>
      <li><strong>공유 범위</strong>: 각 객체(인스턴스)마다 <strong>고유한 값</strong>을 가집니다. 즉, <code class="language-plaintext highlighter-rouge">myCar</code>의 <code class="language-plaintext highlighter-rouge">color</code>와 <code class="language-plaintext highlighter-rouge">yourCar</code>의 <code class="language-plaintext highlighter-rouge">color</code>는 다를 수 있습니다.</li>
      <li><strong>메모리</strong>: <strong>힙(Heap) 영역</strong>에 저장됩니다.</li>
      <li><strong>예시</strong>: 위 <code class="language-plaintext highlighter-rouge">Car</code> 클래스의 <code class="language-plaintext highlighter-rouge">color</code>, <code class="language-plaintext highlighter-rouge">model</code>, <code class="language-plaintext highlighter-rouge">speed</code></li>
    </ul>
  </li>
  <li>
    <p><strong>클래스 변수 (Class Variable) 또는 static 변수</strong></p>

    <ul>
      <li><strong>선언 위치</strong>: 클래스 내부, 메소드 외부에 <code class="language-plaintext highlighter-rouge">static</code> 키워드와 함께 선언됩니다.</li>
      <li><strong>생명 주기</strong>: 프로그램 시작 시 클래스가 메모리에 로드될 때 함께 생성되고, 프로그램이 종료될 때 해제됩니다. 객체 생성 여부와 관계없이 존재합니다.</li>
      <li><strong>공유 범위</strong>: 해당 클래스로부터 생성된 <strong>모든 객체가 공유하는 값</strong>입니다. 어떤 객체에서 이 변수 값을 변경하면, 다른 모든 객체에도 그 변경 내용이 반영됩니다.</li>
      <li><strong>메모리</strong>: **메소드 영역(Method Area)**에 저장됩니다.</li>
      <li><strong>접근 방법</strong>: <code class="language-plaintext highlighter-rouge">클래스명.변수명</code> 또는 <code class="language-plaintext highlighter-rouge">객체참조변수.변수명</code>으로 접근 가능하나, 일반적으로 <code class="language-plaintext highlighter-rouge">클래스명.변수명</code>으로 접근하는 것을 권장합니다.</li>
      <li><strong>예시</strong>: 위 <code class="language-plaintext highlighter-rouge">Car</code> 클래스의 <code class="language-plaintext highlighter-rouge">manufacturer</code></li>
    </ul>
  </li>
  <li>
    <p><strong>지역 변수 (Local Variable)</strong></p>

    <ul>
      <li><strong>선언 위치</strong>: 메소드, 생성자, 또는 초기화 블록 내부에 선언됩니다.</li>
      <li><strong>생명 주기</strong>: 해당 블록이 실행될 때 생성되고, 블록의 실행이 끝나면 자동으로 소멸됩니다.</li>
      <li><strong>공유 범위</strong>: 선언된 블록 내에서만 유효하며, 다른 블록이나 객체와는 무관합니다.</li>
      <li><strong>메모리</strong>: <strong>스택(Stack) 영역</strong>에 저장됩니다.</li>
      <li><strong>예시</strong>: 아래 <code class="language-plaintext highlighter-rouge">main</code> 메소드의 <code class="language-plaintext highlighter-rouge">myCar</code>, <code class="language-plaintext highlighter-rouge">yourCar</code> 또는 <code class="language-plaintext highlighter-rouge">accelerate</code> 메소드의 <code class="language-plaintext highlighter-rouge">amount</code> 변수</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="객체object와-인스턴스instance-설계도로-만들어진-실체">객체(Object)와 인스턴스(Instance): 설계도로 만들어진 ‘실체’</h2>

<p><strong>객체</strong>는 클래스를 기반으로 메모리에 실제로 만들어진 **‘실체’**를 의미합니다. 즉, 설계도(<code class="language-plaintext highlighter-rouge">클래스</code>)를 바탕으로 만들어진 실제 ‘자동차’입니다. 객체는 생성될 때마다 독립적인 속성값을 가질 수 있습니다.</p>

<p><strong>인스턴스</strong>는 ‘객체’와 거의 같은 의미로 사용되지만, 좀 더 관계에 초점을 맞춘 용어입니다. 특정 클래스로부터 생성된 객체를 그 클래스의 **‘인스턴스’**라고 부릅니다.
예를 들어, “myCar는 <code class="language-plaintext highlighter-rouge">Car</code> 클래스의 객체이다”라고 말할 수도 있지만, “myCar는 <code class="language-plaintext highlighter-rouge">Car</code> 클래스의 인스턴스이다”라고 말하는 것이 더 정확한 표현입니다.</p>

<h3 id="-클래스로-객체인스턴스-생성하기">✅ 클래스로 객체(인스턴스) 생성하기</h3>

<p>객체를 생성하는 과정은 다음 두 단계로 이루어집니다.</p>

<ol>
  <li><strong>클래스 타입의 변수 선언</strong>: 객체의 주소값을 저장할 변수를 선언합니다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">클래스명</span> <span class="n">변수명</span><span class="o">;</span>
</code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">new</code> 연산자를 사용하여 객체 생성 및 할당</strong>: <code class="language-plaintext highlighter-rouge">new</code> 키워드를 사용하여 클래스의 생성자를 호출하고, 힙(Heap) 메모리 영역에 실제 객체를 생성한 후, 그 객체의 메모리 주소를 선언된 변수에 할당합니다.</li>
</ol>

<!-- end list -->

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CarExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 지역 변수: main 메소드 안에서만 유효한 변수</span>
        <span class="c1">// 1. Car 클래스 타입의 변수 선언 (아직 객체는 생성되지 않음)</span>
        <span class="nc">Car</span> <span class="n">myCar</span><span class="o">;</span> <span class="c1">// myCar는 Car 객체를 '참조'할 지역 변수입니다.</span>

        <span class="c1">// 2. new 연산자를 사용하여 Car 클래스의 객체(인스턴스)를 생성하고 변수에 할당</span>
        <span class="n">myCar</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">();</span> <span class="c1">// 힙 메모리에 Car 객체가 생성되고, 그 주소가 myCar에 저장됩니다.</span>

        <span class="c1">// myCar 인스턴스의 인스턴스 변수에 접근하고 값 설정</span>
        <span class="n">myCar</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="s">"Red"</span><span class="o">;</span>
        <span class="n">myCar</span><span class="o">.</span><span class="na">model</span> <span class="o">=</span> <span class="s">"Tesla Model 3"</span><span class="o">;</span>
        <span class="n">myCar</span><span class="o">.</span><span class="na">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"내 차의 제조사: "</span> <span class="o">+</span> <span class="nc">Car</span><span class="o">.</span><span class="na">manufacturer</span><span class="o">);</span> <span class="c1">// static 변수는 클래스명으로 접근</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"내 차의 색상: "</span> <span class="o">+</span> <span class="n">myCar</span><span class="o">.</span><span class="na">color</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"내 차의 모델: "</span> <span class="o">+</span> <span class="n">myCar</span><span class="o">.</span><span class="na">model</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"내 차의 현재 속도: "</span> <span class="o">+</span> <span class="n">myCar</span><span class="o">.</span><span class="na">speed</span> <span class="o">+</span> <span class="s">"km/h"</span><span class="o">);</span>

        <span class="n">myCar</span><span class="o">.</span><span class="na">startEngine</span><span class="o">();</span> <span class="c1">// 메소드 호출</span>
        <span class="n">myCar</span><span class="o">.</span><span class="na">accelerate</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span> <span class="c1">// 메소드 호출 (amount는 이 메소드 내의 지역 변수)</span>
        <span class="n">myCar</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>        <span class="c1">// 메소드 호출</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--------------------"</span><span class="o">);</span>

        <span class="c1">// 또 다른 Car 객체(인스턴스) 생성</span>
        <span class="nc">Car</span> <span class="n">yourCar</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">();</span> <span class="c1">// 힙 메모리에 새로운 Car 객체가 생성됩니다.</span>
        <span class="n">yourCar</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="s">"Blue"</span><span class="o">;</span>
        <span class="n">yourCar</span><span class="o">.</span><span class="na">model</span> <span class="o">=</span> <span class="s">"Hyundai Sonata"</span><span class="o">;</span>
        <span class="n">yourCar</span><span class="o">.</span><span class="na">speed</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"네 차의 제조사: "</span> <span class="o">+</span> <span class="nc">Car</span><span class="o">.</span><span class="na">manufacturer</span><span class="o">);</span> <span class="c1">// static 변수는 클래스명으로 접근</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"네 차의 색상: "</span> <span class="o">+</span> <span class="n">yourCar</span><span class="o">.</span><span class="na">color</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"네 차의 모델: "</span> <span class="o">+</span> <span class="n">yourCar</span><span class="o">.</span><span class="na">model</span><span class="o">);</span>
        <span class="n">yourCar</span><span class="o">.</span><span class="na">accelerate</span><span class="o">(</span><span class="mi">30</span><span class="o">);</span>

        <span class="c1">// myCar와 yourCar는 서로 독립적인 객체입니다.</span>
        <span class="c1">// 각자의 인스턴스 변수 속성을 가지고, 각자의 행동을 수행합니다.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"myCar의 최종 속도: "</span> <span class="o">+</span> <span class="n">myCar</span><span class="o">.</span><span class="na">speed</span> <span class="o">+</span> <span class="s">"km/h"</span><span class="o">);</span> <span class="c1">// 0 (stop() 호출 후)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"yourCar의 최종 속도: "</span> <span class="o">+</span> <span class="n">yourCar</span><span class="o">.</span><span class="na">speed</span> <span class="o">+</span> <span class="s">"km/h"</span><span class="o">);</span> <span class="c1">// 30</span>

        <span class="c1">// static 변수 값 변경 (모든 객체에 영향)</span>
        <span class="nc">Car</span><span class="o">.</span><span class="na">manufacturer</span> <span class="o">=</span> <span class="s">"Global Motors"</span><span class="o">;</span> <span class="c1">// 클래스 변수 값 변경</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--------------------"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"제조사 변경 후 myCar의 제조사: "</span> <span class="o">+</span> <span class="n">myCar</span><span class="o">.</span><span class="na">manufacturer</span><span class="o">);</span> <span class="c1">// 변경된 값 출력</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"제조사 변경 후 yourCar의 제조사: "</span> <span class="o">+</span> <span class="n">yourCar</span><span class="o">.</span><span class="na">manufacturer</span><span class="o">);</span> <span class="c1">// 변경된 값 출력</span>
        <span class="nc">Car</span><span class="o">.</span><span class="na">printManufacturer</span><span class="o">();</span> <span class="c1">// static 메소드도 클래스명으로 호출</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>실행 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>내 차의 제조사: JavaMotors
내 차의 색상: Red
내 차의 모델: Tesla Model 3
내 차의 현재 속도: 0km/h
Tesla Model 3의 시동을 겁니다.
Tesla Model 3이(가) 50km/h로 가속합니다.
Tesla Model 3이(가) 정지합니다.
--------------------
네 차의 제조사: JavaMotors
네 차의 색상: Blue
네 차의 모델: Hyundai Sonata
Hyundai Sonata이(가) 30km/h로 가속합니다.
myCar의 최종 속도: 0km/h
yourCar의 최종 속도: 30km/h
--------------------
제조사 변경 후 myCar의 제조사: Global Motors
제조사 변경 후 yourCar의 제조사: Global Motors
모든 Global Motors 자동차의 총 생산 대수는 아직 미정입니다.
</code></pre></div></div>

<p>위 예시에서 <code class="language-plaintext highlighter-rouge">myCar</code>와 <code class="language-plaintext highlighter-rouge">yourCar</code>는 모두 <code class="language-plaintext highlighter-rouge">Car</code>라는 **동일한 설계도(클래스)**로부터 만들어졌지만, 각각 고유한 <code class="language-plaintext highlighter-rouge">color</code>, <code class="language-plaintext highlighter-rouge">model</code>, <code class="language-plaintext highlighter-rouge">speed</code> 값(인스턴스 변수)을 가집니다. 반면 <code class="language-plaintext highlighter-rouge">manufacturer</code>(static 변수)는 모든 <code class="language-plaintext highlighter-rouge">Car</code> 객체가 <strong>공유</strong>하며, 어느 한 곳에서 값을 바꾸면 모든 객체에 영향을 미치는 것을 확인할 수 있습니다. <code class="language-plaintext highlighter-rouge">main</code> 메소드 안에서 선언된 <code class="language-plaintext highlighter-rouge">myCar</code>, <code class="language-plaintext highlighter-rouge">yourCar</code> 변수들은 메소드 실행이 끝나면 사라지는 <strong>지역 변수</strong>입니다.</p>

<hr />

<h2 id="-요약-정리-클래스-객체-인스턴스-그리고-변수의-종류">📌 요약 정리: 클래스, 객체, 인스턴스 그리고 변수의 종류</h2>

<ul>
  <li>
    <p><strong>클래스(Class)</strong>: 객체를 만들기 위한 <strong>설계도</strong>. 객체가 가질 속성(필드)과 행동(메소드)을 정의합니다. 클래스 자체는 메모리에 실제 데이터를 저장하지 않습니다.</p>
  </li>
  <li>
    <p><strong>객체(Object)</strong>: 클래스 설계도를 바탕으로 <strong>메모리에 생성된 실제 실체</strong>. 독립적인 속성 값을 가지며, 정의된 행동을 수행할 수 있습니다.</p>
  </li>
  <li>
    <p><strong>인스턴스(Instance)</strong>: 특정 클래스로부터 생성된 <strong>객체</strong>를 지칭할 때 사용되는 용어. “myCar는 <code class="language-plaintext highlighter-rouge">Car</code> 클래스의 인스턴스이다” 와 같이 특정 클래스와의 관계를 강조합니다.</p>
  </li>
  <li>
    <p><strong>생성</strong>: <code class="language-plaintext highlighter-rouge">new</code> 연산자를 통해 클래스로부터 객체(인스턴스)를 생성합니다. 이때 실제 데이터는 <strong>힙 영역</strong>에 저장되고, 객체를 참조하는 변수는 <strong>스택 영역</strong>에 그 주소값을 가집니다.</p>
  </li>
  <li>
    <p><strong>변수의 종류</strong>:</p>

    <ul>
      <li><strong>인스턴스 변수</strong>: 각 <strong>객체(인스턴스)마다 고유</strong>하게 값을 가집니다. (<code class="language-plaintext highlighter-rouge">color</code>, <code class="language-plaintext highlighter-rouge">model</code>, <code class="language-plaintext highlighter-rouge">speed</code>)</li>
      <li><strong>클래스 변수 (static 변수)</strong>: <strong>모든 객체가 공유</strong>하는 값입니다. 클래스 로드 시점에 메모리(메소드 영역)에 할당됩니다. (<code class="language-plaintext highlighter-rouge">manufacturer</code>)</li>
      <li><strong>지역 변수</strong>: 메소드/블록 내에서 선언되며, 해당 블록이 끝나면 사라집니다. (<code class="language-plaintext highlighter-rouge">myCar</code>, <code class="language-plaintext highlighter-rouge">yourCar</code>, <code class="language-plaintext highlighter-rouge">amount</code>)</li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="-클래스객체-퀴즈-동물-농장">💡 클래스/객체 퀴즈: 동물 농장</h2>

<p>다음 <code class="language-plaintext highlighter-rouge">Animal</code> 클래스와 <code class="language-plaintext highlighter-rouge">main</code> 메소드를 보고, 어떤 결과가 출력될지 예상해 보세요.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span> <span class="c1">// public 키워드를 붙이지 않으면 파일명과 달라도 됩니다.</span>
    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span> <span class="c1">// 인스턴스 변수</span>
    <span class="nc">String</span> <span class="n">sound</span><span class="o">;</span> <span class="c1">// 인스턴스 변수</span>
    <span class="kd">static</span> <span class="nc">String</span> <span class="n">kingdom</span> <span class="o">=</span> <span class="s">"동물계"</span><span class="o">;</span> <span class="c1">// 클래스 변수 (static 변수)</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">"이(가) "</span> <span class="o">+</span> <span class="n">sound</span> <span class="o">+</span> <span class="s">" 소리를 냅니다."</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printKingdom</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"모든 생명체는 "</span> <span class="o">+</span> <span class="n">kingdom</span> <span class="o">+</span> <span class="s">"에 속합니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnimalFarm</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">();</span> <span class="c1">// 지역 변수 dog</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"바둑이"</span><span class="o">;</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">sound</span> <span class="o">=</span> <span class="s">"멍멍"</span><span class="o">;</span>

        <span class="nc">Animal</span> <span class="n">cat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">();</span> <span class="c1">// 지역 변수 cat</span>
        <span class="n">cat</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"나비"</span><span class="o">;</span>
        <span class="n">cat</span><span class="o">.</span><span class="na">sound</span> <span class="o">=</span> <span class="s">"야옹"</span><span class="o">;</span>

        <span class="n">dog</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span>
        <span class="n">cat</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--- Static 변수 확인 ---"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"강아지의 종: "</span> <span class="o">+</span> <span class="n">dog</span><span class="o">.</span><span class="na">kingdom</span><span class="o">);</span> <span class="c1">// 객체를 통해서도 static 변수 접근 가능</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"고양이의 종: "</span> <span class="o">+</span> <span class="n">cat</span><span class="o">.</span><span class="na">kingdom</span><span class="o">);</span> <span class="c1">// 객체를 통해서도 static 변수 접근 가능</span>
        <span class="nc">Animal</span><span class="o">.</span><span class="na">printKingdom</span><span class="o">();</span> <span class="c1">// static 메소드는 클래스명으로 호출</span>

        <span class="nc">Animal</span><span class="o">.</span><span class="na">kingdom</span> <span class="o">=</span> <span class="s">"생물계"</span><span class="o">;</span> <span class="c1">// static 변수 값 변경</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--- Static 변수 변경 후 확인 ---"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"강아지의 종: "</span> <span class="o">+</span> <span class="n">dog</span><span class="o">.</span><span class="na">kingdom</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"고양이의 종: "</span> <span class="o">+</span> <span class="n">cat</span><span class="o">.</span><span class="na">kingdom</span><span class="o">);</span>
        <span class="nc">Animal</span><span class="o">.</span><span class="na">printKingdom</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<details>
<summary>정답 보기</summary>
<br />
출력 결과:<br /><br />


바둑이이(가) 멍멍 소리를 냅니다.<br />
나비이(가) 야옹 소리를 냅니다.<br />
--- Static 변수 확인 ---<br />
강아지의 종: 동물계<br />
고양이의 종: 동물계<br />
모든 생명체는 동물계에 속합니다.<br />
--- Static 변수 변경 후 확인 ---<br />
강아지의 종: 생물계<br />
고양이의 종: 생물계<br />
모든 생명체는 생물계에 속합니다.<br />


<br />
설명:
<br />

1.  `Animal` 클래스는 `name`, `sound` (인스턴스 변수)와 `kingdom` (static 변수), `makeSound()` (인스턴스 메소드), `printKingdom()` (static 메소드)를 가집니다.<br />
2.  `main` 메소드에서 `dog`와 `cat`이라는 두 개의 `Animal` 인스턴스를 생성하고 각각의 `name`과 `sound`를 설정합니다. 이들은 각 객체에 독립적으로 저장됩니다.<br />
3.  `dog.makeSound()`와 `cat.makeSound()`는 각 인스턴스의 고유한 `name`과 `sound` 값을 사용하여 출력합니다.<br />
4.  `kingdom`은 `static` 변수이므로 `dog.kingdom`이든 `cat.kingdom`이든 `Animal.kingdom`이든 모두 동일한 메모리 공간을 참조합니다. 따라서 처음에는 "동물계"가 출력됩니다.<br />
5.  `Animal.printKingdom()`도 `static` 메소드이므로 `kingdom` 변수의 현재 값을 출력합니다.<br />
6.  `Animal.kingdom = &quot;생물계&quot;;` 코드를 통해 `static` 변수 `kingdom`의 값을 "생물계"로 변경합니다. 이 변경은 `dog`와 `cat` 등 **모든 `Animal` 인스턴스에 즉시 반영**됩니다.<br />
7.  변경 후 다시 `dog.kingdom`, `cat.kingdom`, `Animal.printKingdom()`을 호출하면 모두 변경된 "생물계"가 출력되는 것을 확인할 수 있습니다.
    </details>

<hr />

<h2 id="-마치며-객체지향의-첫걸음">🔚 마치며: 객체지향의 첫걸음</h2>

<p>이번 글에서는 자바 객체지향 프로그래밍의 핵심 축인 <strong>클래스, 객체, 인스턴스</strong> 개념을 알아보았습니다. 이 개념들은 자바를 넘어 대부분의 현대 프로그래밍 언어에서 매우 중요하게 다뤄지는 기초입니다. 클래스가 설계도이고, 객체/인스턴스는 그 설계도를 통해 만들어진 실제 사물이라는 비유를 기억한다면 이해하기 쉬울 것입니다. 또한, 클래스 내부에 선언되는 변수의 종류(인스턴스, static, 지역 변수)와 그 특징을 이해하는 것은 객체지향 설계에 있어 매우 중요합니다.</p>

<p>이러한 객체지향의 기본 개념을 이해하는 것은 앞으로 배우게 될 상속, 다형성, 캡슐화 등 더 깊이 있는 객체지향 특성들을 이해하는 데 필수적인 토대가 됩니다.</p>]]></content><author><name>Lorem</name><email>loremipsum0115@gmail.com</email></author><category term="java" /><summary type="html"><![CDATA[]]></summary></entry><entry xml:lang="ko"><title type="html">자바 참조타입 - 다차원 배열</title><link href="https://loremipsum0116.github.io/ko/java-array(2)/" rel="alternate" type="text/html" title="자바 참조타입 - 다차원 배열" /><published>2025-06-16T07:46:15+00:00</published><updated>2025-06-16T07:46:15+00:00</updated><id>https://loremipsum0116.github.io/ko/java-array(2)</id><content type="html" xml:base="https://loremipsum0116.github.io/ko/java-array(2)/"><![CDATA[<hr />

<h2 id="자바-배열-심화-다차원-배열과-배열-복사">자바 배열 심화: <strong>다차원 배열</strong>과 <strong>배열 복사</strong></h2>

<p>앞서 일차원 배열의 개념과 활용법을 익혔습니다. 하지만 실제 데이터를 다루다 보면 일렬로 나열된 형태를 넘어, 표나 격자처럼 여러 차원으로 구성된 데이터를 처리해야 할 때가 많습니다. 이때 유용하게 사용되는 것이 바로 **다차원 배열(Multi-dimensional Array)**입니다. 특히 <strong>이차원 배열</strong>은 행(Row)과 열(Column)로 구성된 표 형태의 데이터를 다루는 데 가장 일반적으로 사용됩니다.</p>

<p>또한, 배열은 참조 타입의 특성상 복사 시 주의가 필요합니다. 단순히 대입 연산자를 사용하는 것만으로는 진정한 의미의 복사가 이루어지지 않으므로, 데이터를 안전하게 다루기 위한 다양한 <strong>배열 복사(Array Copying)</strong> 방법에 대해서도 자세히 알아보겠습니다.</p>

<hr />

<h2 id="이차원-배열-two-dimensional-array"><strong>이차원 배열</strong> (Two-dimensional Array)</h2>

<p>이차원 배열은 ‘배열의 배열’이라고 생각할 수 있습니다. 즉, 각 요소가 또 다른 배열을 가리키는 배열입니다. 마치 스프레드시트의 행과 열처럼 데이터를 조직할 때 사용됩니다.</p>

<h3 id="-이차원-배열의-선언-및-생성">✅ 이차원 배열의 선언 및 생성</h3>

<p>이차원 배열은 대괄호를 두 개 사용합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 이차원 배열 선언만 하기</span>
<span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">;</span> <span class="c1">// int 타입의 이차원 배열을 참조할 변수 matrix 선언</span>

<span class="c1">// 2. 이차원 배열 선언과 동시에 생성 (행과 열의 크기 지정)</span>
<span class="c1">// 3행 4열 (3개의 행, 각 행마다 4개의 열)을 가지는 배열</span>
<span class="kt">int</span><span class="o">[][]</span> <span class="n">scores</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">3</span><span class="o">][</span><span class="mi">4</span><span class="o">];</span> 

<span class="c1">// 3. 이차원 배열 선언과 동시에 초기화</span>
<span class="kt">int</span><span class="o">[][]</span> <span class="n">numbers</span> <span class="o">=</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">},</span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="c1">// 0번 행</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">{</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">},</span> <span class="err"> </span> <span class="err"> </span><span class="c1">// 1번 행</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">{</span><span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">}</span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="c1">// 2번 행</span>
<span class="o">};</span>
<span class="c1">// 각 행의 열 개수가 다를 수도 있습니다 (가변 배열).</span>
</code></pre></div></div>

<h3 id="-이차원-배열-요소-접근">✅ 이차원 배열 요소 접근</h3>

<p>이차원 배열의 각 요소는 <code class="language-plaintext highlighter-rouge">배열이름[행인덱스][열인덱스]</code> 형식으로 접근합니다. 인덱스는 모두 0부터 시작합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">},</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">{</span><span class="mi">30</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">50</span><span class="o">}</span>
<span class="o">};</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]);</span> <span class="c1">// 0번 행의 0번 열: 10</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span> <span class="c1">// 0번 행의 1번 열: 20</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]);</span> <span class="c1">// 1번 행의 2번 열: 50</span>

<span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">25</span><span class="o">;</span> <span class="c1">// 0번 행의 1번 열의 값을 변경</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span> <span class="c1">// 변경된 값 출력: 25</span>
</code></pre></div></div>

<h3 id="-이차원-배열-순회-중첩-for문-활용">✅ 이차원 배열 순회 (중첩 <code class="language-plaintext highlighter-rouge">for</code>문 활용)</h3>

<p>이차원 배열의 모든 요소를 순회하려면, 중첩 <code class="language-plaintext highlighter-rouge">for</code>문을 사용합니다. 바깥 <code class="language-plaintext highlighter-rouge">for</code>문은 행을, 안쪽 <code class="language-plaintext highlighter-rouge">for</code>문은 열을 제어합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TwoDimArrayTraversal</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">classroom</span> <span class="o">=</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">{</span><span class="mi">80</span><span class="o">,</span> <span class="mi">90</span><span class="o">,</span> <span class="mi">75</span><span class="o">},</span> <span class="err"> </span> <span class="c1">// 0번 학생의 국어, 영어, 수학 점수</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">{</span><span class="mi">95</span><span class="o">,</span> <span class="mi">88</span><span class="o">,</span> <span class="mi">92</span><span class="o">},</span> <span class="err"> </span> <span class="c1">// 1번 학생의 국어, 영어, 수학 점수</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">{</span><span class="mi">70</span><span class="o">,</span> <span class="mi">65</span><span class="o">,</span> <span class="mi">80</span><span class="o">}</span> <span class="err"> </span> <span class="err"> </span><span class="c1">// 2번 학생의 국어, 영어, 수학 점수</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">};</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--- 학생별 과목 점수 출력 ---"</span><span class="o">);</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">classroom</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// classroom.length는 행의 개수 (3)</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">"번 학생: "</span><span class="o">);</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">classroom</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// classroom[i].length는 i번 행의 열 개수 (각 행의 길이)</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">classroom</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">}</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span> <span class="c1">// 한 학생의 점수 출력이 끝나면 줄바꿈</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">}</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>출력 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--- 학생별 과목 점수 출력 ---
1번 학생: 80 90 75 
2번 학생: 95 88 92 
3번 학생: 70 65 80 
</code></pre></div></div>

<hr />

<h2 id="다차원-배열-multi-dimensional-array"><strong>다차원 배열</strong> (Multi-dimensional Array)</h2>

<p>다차원 배열은 이차원 배열의 개념을 확장한 것입니다. 세 개의 대괄호를 사용하면 삼차원 배열이 되며, 이는 부피를 가진 3D 공간을 표현할 때 유용할 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// 삼차원 배열 선언 및 생성 (2개의 면, 각 면은 3행 4열)</span>
<span class="kt">int</span><span class="o">[][][]</span> <span class="n">building</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">][</span><span class="mi">3</span><span class="o">][</span><span class="mi">4</span><span class="o">];</span>

<span class="c1">// 초기화 예시</span>
<span class="kt">int</span><span class="o">[][][]</span> <span class="n">tensor</span> <span class="o">=</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">{</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">}</span> <span class="o">},</span> <span class="c1">// 0번 면</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">{</span> <span class="o">{</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">},</span> <span class="o">{</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">}</span> <span class="o">}</span> <span class="err"> </span><span class="c1">// 1번 면</span>
<span class="o">};</span>

<span class="c1">// 요소 접근 예시</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tensor</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span> <span class="c1">// 0번 면의 1번 행의 1번 열: 4</span>

</code></pre></div></div>

<p>실제 프로그래밍에서는 이차원 배열이 가장 흔하게 사용되며, 삼차원 이상의 배열은 특정 목적(예: 이미지 처리, 과학 계산 등)을 제외하고는 많이 사용되지 않습니다.</p>

<hr />

<h2 id="배열-복사-array-copying"><strong>배열 복사</strong> (Array Copying)</h2>

<p>자바에서 배열은 참조 타입이므로, 단순히 <code class="language-plaintext highlighter-rouge">arr2 = arr1;</code> 와 같이 대입 연산자를 사용하면 두 변수가 <strong>동일한 배열 객체를 참조</strong>하게 됩니다. 이는 원본 배열의 요소를 변경하면 복사본처럼 보이는 배열의 요소도 함께 변경됨을 의미합니다. 진정한 의미의 독립적인 복사본을 만들려면 특별한 방법을 사용해야 합니다.</p>

<h3 id="️-얕은-복사shallow-copy와-깊은-복사deep-copy">⚠️ 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)</h3>

<ul>
  <li><strong>얕은 복사 (Shallow Copy)</strong>: 배열 자체는 복사되지만, 배열이 참조하는 객체(요소)는 복사되지 않고 기존 객체를 그대로 참조합니다. 이차원 배열의 경우, 바깥 배열만 복사되고 안쪽 배열들은 동일한 참조를 가집니다.</li>
  <li><strong>깊은 복사 (Deep Copy)</strong>: 배열의 모든 요소(객체 포함)까지 완전히 새로운 메모리 공간에 복사합니다. 원본과 복사본이 완전히 독립적입니다.</li>
</ul>

<h3 id="-배열-복사-방법">✅ 배열 복사 방법</h3>

<h4 id="1-for-문을-이용한-수동-복사-깊은-복사">1. <code class="language-plaintext highlighter-rouge">for</code> 문을 이용한 수동 복사 (깊은 복사)</h4>

<p>가장 기본적인 방법으로, 반복문을 사용하여 원본 배열의 요소를 하나씩 새로운 배열에 복사합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayCopyByForLoop</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="kt">int</span><span class="o">[]</span> <span class="n">original</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">50</span><span class="o">};</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">original</span><span class="o">.</span><span class="na">length</span><span class="o">];</span> <span class="c1">// 원본과 동일한 크기의 새 배열 생성</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">original</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">copy</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">original</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// 각 요소를 직접 복사</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">}</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">original</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span> <span class="c1">// 원본 배열 변경</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"원본 배열: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">original</span><span class="o">));</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"복사된 배열: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">copy</span><span class="o">));</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>출력 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>원본 배열: [100, 20, 30, 40, 50]
복사된 배열: [10, 20, 30, 40, 50]
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">original</code> 배열의 첫 번째 요소가 변경되었지만, <code class="language-plaintext highlighter-rouge">copy</code> 배열은 영향을 받지 않았습니다. (깊은 복사)</p>

<h4 id="2-systemarraycopy-메서드-깊은-복사">2. <code class="language-plaintext highlighter-rouge">System.arraycopy()</code> 메서드 (깊은 복사)</h4>

<p>Java에서 배열을 빠르고 효율적으로 복사하기 위해 제공하는 네이티브 메서드입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayCopyBySystemArrayCopy</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">String</span><span class="o">[]</span> <span class="n">original</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Apple"</span><span class="o">,</span> <span class="s">"Banana"</span><span class="o">,</span> <span class="s">"Cherry"</span><span class="o">};</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">String</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">original</span><span class="o">.</span><span class="na">length</span><span class="o">];</span> <span class="c1">// 새 배열 생성</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="c1">// System.arraycopy(원본배열, 원본시작인덱스, 대상배열, 대상시작인덱스, 복사할개수)</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">original</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">copy</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">original</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">original</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s">"Avocado"</span><span class="o">;</span> <span class="c1">// 원본 배열 변경</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"원본 배열: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">original</span><span class="o">));</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"복사된 배열: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">copy</span><span class="o">));</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>출력 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>원본 배열: [Avocado, Banana, Cherry]
복사된 배열: [Apple, Banana, Cherry]
</code></pre></div></div>

<h4 id="3-arrayscopyof-또는-arrayscopyofrange-메서드-깊은-복사">3. <code class="language-plaintext highlighter-rouge">Arrays.copyOf()</code> 또는 <code class="language-plaintext highlighter-rouge">Arrays.copyOfRange()</code> 메서드 (깊은 복사)</h4>

<p><code class="language-plaintext highlighter-rouge">java.util.Arrays</code> 클래스에서 제공하는 편리한 복사 메서드입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span> <span class="c1">// Arrays 클래스 사용을 위해 임포트</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayCopyByArraysCopyOf</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="kt">double</span><span class="o">[]</span> <span class="n">original</span> <span class="o">=</span> <span class="o">{</span><span class="mf">1.1</span><span class="o">,</span> <span class="mf">2.2</span><span class="o">,</span> <span class="mf">3.3</span><span class="o">,</span> <span class="mf">4.4</span><span class="o">,</span> <span class="mf">5.5</span><span class="o">};</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="c1">// Arrays.copyOf(원본배열, 새로운 배열의 길이)</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="c1">// 새로운 배열의 길이가 원본보다 짧으면 잘리고, 길면 기본값(0.0)으로 채워짐</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="kt">double</span><span class="o">[]</span> <span class="n">copy1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">original</span><span class="o">,</span> <span class="n">original</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="c1">// Arrays.copyOfRange(원본배열, 시작인덱스, 끝인덱스(포함 안됨))</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="kt">double</span><span class="o">[]</span> <span class="n">copy2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">original</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span> <span class="c1">// 인덱스 1부터 3까지 복사 (2.2, 3.3, 4.4)</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">original</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mf">9.9</span><span class="o">;</span> <span class="c1">// 원본 배열 변경</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"원본 배열: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">original</span><span class="o">));</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"copyOf로 복사된 배열: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">copy1</span><span class="o">));</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"copyOfRange로 복사된 배열: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">copy2</span><span class="o">));</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>출력 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>원본 배열: [9.9, 2.2, 3.3, 4.4, 5.5]
copyOf로 복사된 배열: [1.1, 2.2, 3.3, 4.4, 5.5]
copyOfRange로 복사된 배열: [2.2, 3.3, 4.4]
</code></pre></div></div>

<h4 id="4-clone-메서드-얕은-복사-일차원-배열의-경우-깊은-복사처럼-동작">4. <code class="language-plaintext highlighter-rouge">clone()</code> 메서드 (얕은 복사, 일차원 배열의 경우 깊은 복사처럼 동작)</h4>

<p>배열은 <code class="language-plaintext highlighter-rouge">Object</code> 클래스의 <code class="language-plaintext highlighter-rouge">clone()</code> 메서드를 오버라이드하여 제공합니다. 일차원 배열의 경우 <code class="language-plaintext highlighter-rouge">clone()</code>은 내부 요소를 새 배열에 직접 복사하므로 깊은 복사처럼 동작합니다. 하지만 <strong>이차원 이상의 배열에서는 얕은 복사</strong>가 이루어집니다. 즉, 바깥 배열만 복사되고 안쪽 배열들은 원본과 동일한 참조를 공유합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayCopyByClone</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">original1D</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy1D</span> <span class="o">=</span> <span class="n">original1D</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span> <span class="c1">// 1차원 배열 복사</span>

        <span class="n">original1D</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"1차원 원본: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">original1D</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"1차원 복사본: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">copy1D</span><span class="o">));</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\n--- 이차원 배열의 clone() (얕은 복사) ---"</span><span class="o">);</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">original2D</span> <span class="o">=</span> <span class="o">{{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">}};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">copy2D</span> <span class="o">=</span> <span class="n">original2D</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span> <span class="c1">// 2차원 배열 복사 (얕은 복사 발생)</span>

        <span class="n">original2D</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">99</span><span class="o">;</span> <span class="c1">// 원본의 0번 행 0번 열 변경</span>
        <span class="n">original2D</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span> <span class="c1">// 원본의 1번 행 자체를 새로운 배열로 교체</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"2차원 원본 (변경 후): "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">original2D</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"2차원 복사본 (얕은 복사): "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">copy2D</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p><strong>출력 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1차원 원본: [100, 20, 30]
1차원 복사본: [10, 20, 30]

--- 이차원 배열의 clone() (얕은 복사) ---
2차원 원본 (변경 후): [[99, 2], [5, 6]]
2차원 복사본 (얕은 복사): [[99, 2], [3, 4]]
</code></pre></div></div>

<p>위 결과를 보면 <code class="language-plaintext highlighter-rouge">original2D[0][0]</code>을 변경했을 때 <code class="language-plaintext highlighter-rouge">copy2D[0][0]</code>도 함께 변경된 것을 볼 수 있습니다 (얕은 복사). 하지만 <code class="language-plaintext highlighter-rouge">original2D[1]</code> 자체를 새로운 배열로 교체했을 때는 <code class="language-plaintext highlighter-rouge">copy2D[1]</code>은 그대로 유지되는 것을 볼 수 있습니다. 이는 <code class="language-plaintext highlighter-rouge">copy2D</code>가 <code class="language-plaintext highlighter-rouge">original2D</code>의 내부 배열(<code class="language-plaintext highlighter-rouge">{1,2}</code>와 <code class="language-plaintext highlighter-rouge">{3,4}</code>)에 대한 <strong>참조만 복사</strong>했기 때문입니다.</p>

<hr />

<h2 id="향상된-for문을-활용하여-배열-순회"><strong>향상된 <code class="language-plaintext highlighter-rouge">for</code>문을 활용하여 배열 순회</strong></h2>

<p>일차원 배열에서 향상된 <code class="language-plaintext highlighter-rouge">for</code>문의 간결성을 이미 살펴보았지만, 이차원 배열에서도 매우 유용하게 사용될 수 있습니다. 특히 배열의 모든 요소를 단순히 읽기만 할 때 편리합니다.</p>

<h3 id="-이차원-배열에서-향상된-for문-활용">✅ 이차원 배열에서 향상된 <code class="language-plaintext highlighter-rouge">for</code>문 활용</h3>

<p>이차원 배열을 향상된 <code class="language-plaintext highlighter-rouge">for</code>문으로 순회할 때는 두 번 중첩해야 합니다. 바깥 <code class="language-plaintext highlighter-rouge">for</code>문은 각 ‘행’ (즉, 내부 배열)을 가져오고, 안쪽 <code class="language-plaintext highlighter-rouge">for</code>문은 그 ‘행’의 각 요소를 가져옵니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EnhancedForLoopTwoDimArray</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">String</span><span class="o">[][]</span> <span class="n">students</span> <span class="o">=</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">{</span><span class="s">"김철수"</span><span class="o">,</span> <span class="s">"수학"</span><span class="o">},</span> <span class="err"> </span><span class="c1">// 0번 학생의 이름과 전공</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">{</span><span class="s">"이영희"</span><span class="o">,</span> <span class="s">"영어"</span><span class="o">},</span> <span class="err"> </span><span class="c1">// 1번 학생의 이름과 전공</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">{</span><span class="s">"박민수"</span><span class="o">,</span> <span class="s">"컴퓨터"</span><span class="o">}</span> <span class="c1">// 2번 학생의 이름과 전공</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">};</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--- 향상된 for문을 이용한 이차원 배열 순회 ---"</span><span class="o">);</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="c1">// 바깥 루프: 각 내부 배열 (행)을 순회</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">for</span> <span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">studentInfo</span> <span class="o">:</span> <span class="n">students</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// studentInfo는 {"김철수", "수학"} 같은 내부 배열을 참조</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"학생 정보: "</span><span class="o">);</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="c1">// 안쪽 루프: 각 내부 배열 (행)의 요소를 순회</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">info</span> <span class="o">:</span> <span class="n">studentInfo</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// info는 "김철수", "수학" 같은 개별 문자열을 참조</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">info</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">}</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="o">}</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>출력 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--- 향상된 for문을 이용한 이차원 배열 순회 ---
학생 정보: 김철수 수학 
학생 정보: 이영희 영어 
학생 정보: 박민수 컴퓨터 
</code></pre></div></div>

<p><strong>참고:</strong> 향상된 <code class="language-plaintext highlighter-rouge">for</code>문은 인덱스에 직접 접근할 수 없으므로, 특정 인덱스의 값만 변경하거나 순회 중 인덱스 값을 활용해야 하는 경우에는 일반 <code class="language-plaintext highlighter-rouge">for</code>문을 사용해야 합니다.</p>

<hr />

<h3 id="-배열-복사-퀴즈">💡 배열 복사 퀴즈</h3>

<p>다음 코드를 실행했을 때, <code class="language-plaintext highlighter-rouge">arr2[0]</code>의 최종 값은 무엇일까요?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayCopyQuiz</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">};</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">arr1</span><span class="o">,</span> <span class="n">arr1</span><span class="o">.</span><span class="na">length</span><span class="o">);</span> <span class="c1">// arr1을 arr2로 복사</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="n">arr1</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">50</span><span class="o">;</span> <span class="c1">// arr1의 첫 번째 값 변경</span>

<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr2</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span> <span class="c1">// arr2의 첫 번째 값 출력</span>
<span class="err"> </span> <span class="err"> </span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<details>
<summary>정답 보기</summary>
<br />
정답은: 10
<br />
설명:<br />
`Arrays.copyOf()` 메서드는 원본 배열의 요소를 새로운 배열에 '깊은 복사'합니다. 즉, `arr1`과 `arr2`는 메모리상에서 완전히 별개의 공간을 차지하는 독립적인 배열이 됩니다. 따라서 `arr1[0] = 50;`은 `arr1` 배열의 값만 변경할 뿐, 이미 복사되어 생성된 `arr2` 배열에는 어떠한 영향도 주지 않습니다.
<br />
</details>

<hr />

<h3 id="-마치며">🔚 마치며</h3>

<p>이번 글에서는 배열의 활용을 심화하여 <strong>이차원 배열</strong>과 <strong>다차원 배열</strong>의 개념을 이해하고, 중첩 <code class="language-plaintext highlighter-rouge">for</code>문을 통해 이를 순회하는 방법을 배웠습니다. 또한, 참조 타입인 배열을 안전하게 다루기 위한 다양한 <strong>배열 복사</strong> 방법을 (<code class="language-plaintext highlighter-rouge">for</code>문, <code class="language-plaintext highlighter-rouge">System.arraycopy()</code>, <code class="language-plaintext highlighter-rouge">Arrays.copyOf()</code>, <code class="language-plaintext highlighter-rouge">clone()</code>) 살펴보았습니다. 마지막으로 <strong>향상된 <code class="language-plaintext highlighter-rouge">for</code>문</strong>이 이차원 배열 순회에 어떻게 적용되는지도 확인했습니다.</p>]]></content><author><name>Lorem</name><email>loremipsum0115@gmail.com</email></author><category term="java" /><summary type="html"><![CDATA[]]></summary></entry><entry xml:lang="ko"><title type="html">자바 참조타입 - 일차원 배열</title><link href="https://loremipsum0116.github.io/ko/java-array/" rel="alternate" type="text/html" title="자바 참조타입 - 일차원 배열" /><published>2025-06-16T07:38:46+00:00</published><updated>2025-06-16T07:38:46+00:00</updated><id>https://loremipsum0116.github.io/ko/java-array</id><content type="html" xml:base="https://loremipsum0116.github.io/ko/java-array/"><![CDATA[<hr />

<h2 id="자바의-데이터-타입-기본-타입과-참조-타입">자바의 데이터 타입: 기본 타입과 <strong>참조 타입</strong></h2>

<p>자바의 데이터 타입은 크게 **기본 타입(Primitive Type)**과 **참조 타입(Reference Type)**으로 나뉩니다. 기본 타입이 실제 값을 변수 내부에 직접 저장하는 반면, 참조 타입은 실제 객체(데이터)가 저장된 메모리 공간의 **주소(번지)**를 변수에 저장합니다. 이 주소를 통해 실제 객체에 접근하게 되므로 ‘참조’라는 이름이 붙었습니다.</p>

<p>일반적으로 클래스, 인터페이스, 배열, 열거(enum) 타입 등이 참조 타입에 해당합니다. <code class="language-plaintext highlighter-rouge">String</code> 타입도 문자열 객체를 참조하므로 참조 타입입니다.</p>

<p><strong>기본 타입 예시</strong>: <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">boolean</code>, <code class="language-plaintext highlighter-rouge">char</code> 등
<strong>참조 타입 예시</strong>: <code class="language-plaintext highlighter-rouge">String</code>, 배열(<code class="language-plaintext highlighter-rouge">int[]</code>, <code class="language-plaintext highlighter-rouge">String[]</code>), <code class="language-plaintext highlighter-rouge">Scanner</code>, <code class="language-plaintext highlighter-rouge">List</code> 등</p>

<hr />

<h2 id="자바-일차원-배열">자바 <strong>일차원 배열</strong></h2>

<p>배열(Array)은 <strong>동일한 타입의 값들을 하나의 변수에 묶어서 저장하는 연속적인 메모리 공간</strong>입니다. 특히 일차원 배열은 가장 기본적인 배열 형태로, 데이터들이 일렬로 나열된 구조를 가집니다.</p>

<h3 id="-배열-선언-및-생성">✅ 배열 선언 및 생성</h3>

<p>배열은 선언과 동시에 크기를 지정하여 생성하거나, 나중에 생성할 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 배열 선언만 하기</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">scores</span><span class="o">;</span> <span class="c1">// int 타입의 배열을 참조할 변수 scores 선언</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">names</span><span class="o">;</span> <span class="c1">// String 타입의 배열을 참조할 변수 names 선언</span>

<span class="c1">// 2. 배열 선언과 동시에 생성 (크기 지정)</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span> <span class="c1">// 5개의 int 값을 저장할 수 있는 배열 생성. 초기값은 0</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">fruits</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span> <span class="c1">// 3개의 String 값을 저장할 수 있는 배열 생성. 초기값은 null</span>

<span class="c1">// 3. 배열 선언과 동시에 초기화</span>
<span class="c1">// 배열의 크기는 초기화하는 값의 개수에 따라 자동으로 결정됩니다.</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">ages</span> <span class="o">=</span> <span class="o">{</span><span class="mi">20</span><span class="o">,</span> <span class="mi">21</span><span class="o">,</span> <span class="mi">22</span><span class="o">,</span> <span class="mi">23</span><span class="o">};</span> <span class="c1">// 4개의 int 값을 가지는 배열 생성</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">colors</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Red"</span><span class="o">,</span> <span class="s">"Green"</span><span class="o">,</span> <span class="s">"Blue"</span><span class="o">};</span> <span class="c1">// 3개의 String 값을 가지는 배열 생성</span>
</code></pre></div></div>

<h3 id="-배열-요소-접근">✅ 배열 요소 접근</h3>

<p>배열의 각 요소는 <code class="language-plaintext highlighter-rouge">배열이름[인덱스]</code> 형식으로 접근합니다. <strong>배열의 인덱스는 0부터 시작</strong>합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">};</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span> <span class="c1">// 첫 번째 요소: 10</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span> <span class="c1">// 두 번째 요소: 20</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span> <span class="c1">// 세 번째 요소: 30</span>

<span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">25</span><span class="o">;</span> <span class="c1">// 두 번째 요소의 값을 20에서 25로 변경</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span> <span class="c1">// 변경된 값 출력: 25</span>
</code></pre></div></div>

<hr />

<h2 id="일차원-배열-값-for문-이용하여-출력하기">일차원 배열 값 <code class="language-plaintext highlighter-rouge">for</code>문 이용하여 출력하기</h2>

<p>배열의 모든 요소를 순회하며 출력할 때는 <code class="language-plaintext highlighter-rouge">for</code>문을 사용하는 것이 일반적입니다. 배열의 길이를 나타내는 <code class="language-plaintext highlighter-rouge">length</code> 속성을 활용합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrintArrayWithFor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">scores</span> <span class="o">=</span> <span class="o">{</span><span class="mi">85</span><span class="o">,</span> <span class="mi">92</span><span class="o">,</span> <span class="mi">78</span><span class="o">,</span> <span class="mi">60</span><span class="o">,</span> <span class="mi">95</span><span class="o">};</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--- 일반 for문을 이용한 배열 출력 ---"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">scores</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// scores.length는 배열의 길이 (5)</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"scores["</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">"] = "</span> <span class="o">+</span> <span class="n">scores</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\n--- 향상된 for문을 이용한 배열 출력 ---"</span><span class="o">);</span>
        <span class="c1">// 향상된 for문 (for-each 루프)은 배열의 모든 요소를 순차적으로 접근할 때 유용합니다.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">score</span> <span class="o">:</span> <span class="n">scores</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"점수: "</span> <span class="o">+</span> <span class="n">score</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>출력 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--- 일반 for문을 이용한 배열 출력 ---
scores[0] = 85
scores[1] = 92
scores[2] = 78
scores[3] = 60
scores[4] = 95

--- 향상된 for문을 이용한 배열 출력 ---
점수: 85
점수: 92
점수: 78
점수: 60
점수: 95
</code></pre></div></div>

<hr />

<h3 id="-배열-기초-퀴즈">💡 배열 기초 퀴즈</h3>

<p>다음 코드를 실행했을 때, 어떤 결과가 출력될까요?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayQuiz</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">greetings</span> <span class="o">=</span> <span class="o">{</span><span class="sc">'H'</span><span class="o">,</span> <span class="sc">'e'</span><span class="o">,</span> <span class="sc">'l'</span><span class="o">,</span> <span class="sc">'l'</span><span class="o">,</span> <span class="sc">'o'</span><span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">greetings</span><span class="o">[</span><span class="mi">4</span><span class="o">]);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">greetings</span><span class="o">[</span><span class="mi">3</span><span class="o">]);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">greetings</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">greetings</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">greetings</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<details>
<summary>정답 보기</summary>
<br />
정답은: olleh
<br />
설명:<br />
배열의 인덱스는 0부터 시작합니다.
greetings[4]는 'o' (인덱스 4)
greetings[3]는 'l' (인덱스 3)
greetings[2]는 'l' (인덱스 2)
greetings[1]는 'e' (인덱스 1)
greetings[0]는 'H' (인덱스 0)

따라서 출력되는 순서는 'o', 'l', 'l', 'e', 'H'가 됩니다. System.out.print는 줄바꿈을 하지 않으므로 모두 한 줄에 이어서 출력됩니다.
<br />

</details>

<hr />

<h2 id="배열-값-출력---랜덤값으로-초기화">배열 값 출력 - 랜덤값으로 초기화</h2>

<p>배열을 생성한 후, <code class="language-plaintext highlighter-rouge">Math.random()</code> 함수 등을 이용하여 배열의 각 요소를 무작위 값으로 초기화할 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span> <span class="c1">// Random 클래스 사용을 위해 임포트</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RandomArrayInitialization</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">randomNumbers</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span> <span class="c1">// 크기가 10인 정수형 배열 생성</span>
        <span class="nc">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span> <span class="c1">// Random 객체 생성</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"--- 랜덤값으로 초기화된 배열 ---"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">randomNumbers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 0부터 99까지의 랜덤 정수를 생성하여 배열에 저장</span>
            <span class="n">randomNumbers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span> 
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"randomNumbers["</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">"] = "</span> <span class="o">+</span> <span class="n">randomNumbers</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>출력 예시 (실행할 때마다 다름):</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--- 랜덤값으로 초기화된 배열 ---
randomNumbers[0] = 45
randomNumbers[1] = 73
randomNumbers[2] = 12
randomNumbers[3] = 88
randomNumbers[4] = 5
randomNumbers[5] = 91
randomNumbers[6] = 29
randomNumbers[7] = 67
randomNumbers[8] = 3
randomNumbers[9] = 54
</code></pre></div></div>

<hr />

<h2 id="배열에서-최대최소-구하기">배열에서 최대/최소 구하기</h2>

<p>배열에 저장된 값들 중에서 가장 크거나 작은 값을 찾으려면, 반복문을 사용하여 배열의 모든 요소를 순회하며 현재까지의 최대/최소값과 비교하여 갱신하는 방법을 사용합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FindMinMaxInArray</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span> <span class="o">=</span> <span class="o">{</span><span class="mi">45</span><span class="o">,</span> <span class="mi">73</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">88</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">91</span><span class="o">,</span> <span class="mi">29</span><span class="o">,</span> <span class="mi">67</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">54</span><span class="o">};</span>

        <span class="c1">// 초기값 설정: 배열의 첫 번째 요소를 최대값과 최소값으로 가정합니다.</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> 
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="c1">// 배열의 두 번째 요소부터 끝까지 순회</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// 현재 요소가 max보다 크면 max 갱신</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// 현재 요소가 min보다 작으면 min 갱신</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"배열 요소: "</span> <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">numbers</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"최대값: "</span> <span class="o">+</span> <span class="n">max</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"최소값: "</span> <span class="o">+</span> <span class="n">min</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>출력 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>배열 요소: [45, 73, 12, 88, 5, 91, 29, 67, 3, 54]
최대값: 91
최소값: 3
</code></pre></div></div>

<hr />

<h2 id="중복-없는-배열-만드는-방법">중복 없는 배열 만드는 방법</h2>

<p>중복 없는 요소를 가지는 배열을 만들려면, 배열에 값을 추가하기 전에 이미 존재하는 값인지 확인하는 로직을 구현합니다.</p>

<h3 id="1-반복문과-조건문을-활용하는-방법-직접-구현">1. 반복문과 조건문을 활용하는 방법 (직접 구현)</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UniqueArrayManual</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">originalArray</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">tempUniqueArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">originalArray</span><span class="o">.</span><span class="na">length</span><span class="o">];</span> <span class="c1">// 최대 크기로 임시 배열 생성</span>
        <span class="kt">int</span> <span class="n">uniqueCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 중복 없는 요소의 실제 개수</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">originalArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">boolean</span> <span class="n">isDuplicate</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="c1">// 현재 요소가 이미 uniqueCount까지의 tempUniqueArray에 있는지 확인</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">uniqueCount</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">originalArray</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">tempUniqueArray</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">isDuplicate</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span> <span class="c1">// 중복 발견, 더 이상 확인할 필요 없음</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">isDuplicate</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">tempUniqueArray</span><span class="o">[</span><span class="n">uniqueCount</span><span class="o">++]</span> <span class="o">=</span> <span class="n">originalArray</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="c1">// 중복이 아니면 추가</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// 실제 중복 없는 요소의 개수만큼만 새 배열 생성</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">uniqueArray</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">tempUniqueArray</span><span class="o">,</span> <span class="n">uniqueCount</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"원본 배열: "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">originalArray</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"중복 제거된 배열 (수동 구현): "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">uniqueArray</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>출력 결과:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>원본 배열: [1, 2, 3, 2, 4, 1, 5, 3]
중복 제거된 배열 (수동 구현): [1, 2, 3, 4, 5]
</code></pre></div></div>

<hr />

<h3 id="-마치며">🔚 마치며</h3>

<p>이번 글에서는 자바의 참조 타입 개념을 시작으로, 가장 기본적인 데이터 구조인 <strong>일차원 배열</strong>에 대해 알아보았습니다. 배열의 선언, 초기화, 그리고 <code class="language-plaintext highlighter-rouge">for</code>문을 활용하여 배열의 요소를 효율적으로 출력하는 방법, 랜덤값으로 배열을 초기화하고 최대/최소값을 찾는 방법까지 다루었습니다.</p>

<p>특히, <strong>중복 없는 배열을 만드는 방법</strong>에서는 <code class="language-plaintext highlighter-rouge">Set</code> 컬렉션을 활용하는 효율적인 방법과 직접 반복문을 통해 중복을 제거하는 방법을 비교하여 제시했습니다. 각 상황에 맞는 적절한 방법을 선택하여 코드를 작성하는 것이 중요합니다.</p>]]></content><author><name>Lorem</name><email>loremipsum0115@gmail.com</email></author><category term="java" /><summary type="html"><![CDATA[]]></summary></entry></feed>